#!/bin/bash

set -u

declare -i namespaces=1
declare -i depsPerNamespace=1
declare -i secrets=0
declare -i replicas=1
declare -i parallel=1
declare -i containers=1
declare -i sleeptime=0
declare -i doit=1
declare -i blocksize=1
declare -i blockitemcount=0
declare -i port=7777
declare dataRate=0
declare podType=ClusterBuster
declare podsleeptime=infinity
declare basename=clusterbuster
declare opt
declare -r nl='
'

function help() {
    cat <<EOF
Usage: $0 [options] [name]
       Default 1 namespace
    Options:
       -n              Print what would be done without doing it
       -P podtype      Pod type (classic, pause, server)
       -B basename     Base name of pods (default clusterbuster)
       -b blocksize    Number of objects to create in one oc call (default 1)
       -c containers   Number of containers per pod
       -D data rate    Data rate for client/server (MB/sec) (default 1)
       -d deployments  Number of deployments per namespace (default 1)
       -N namespaces   Number of namespaces to create (default 1)
       -p parallel     Number of operations to perform in parallel (default 1)
       -r replicas     Number of replicas per deployment (default 1)
       -s secrets      Number of secrets per deployment (default 0)
       -w wait         Number of seconds to wait between ops (default 0)
       -z podsleep     Amount of time in seconds for pod to sleep before exit
                       (default infinity).  This may be an expression evaluated
                       as an argument to sleep(1) and need not be a numeric
                       constant.
EOF
    exit 1
}

trap exit INT

while getopts ":B:b:c:ns:D:d:p:r:w:z:hN:P:" opt ; do
    case "$opt" in
	n) doit=0			;;
	P) podType="$OPTARG"		;;
	B) basename="$OPTARG"		;;
	b) blocksize="$OPTARG"          ;;
	c) containers="$OPTARG"         ;;
	N) namespaces="$OPTARG"         ;;
	D) dataRate="$OPTARG"           ;;
	d) depsPerNamespace="$OPTARG"   ;;
	s) secrets="$OPTARG"            ;;
	r) replicas="$OPTARG"           ;;
	p) parallel="$OPTARG"           ;;
	w) sleeptime="$OPTARG"          ;;
	z) podsleeptime="$OPTARG"	;;
	h) help				;;
	*) help "$OPTARG"               ;;
    esac
done

shift $((OPTIND - 1))

case "$podType" in
    classic|ClusterBuster) podType=ClusterBuster ;;
    server)                podType=Server        ;;
    pause|PausePod|*)      podType=PausePod      ;;
esac

if [[ -n ${1:-} ]] ; then
    basename="$1"
    shift
fi

[[ -z "$*" ]] || echo "Warning: extraneous arguments $# after basename will be ignored!" 1>&2

function indent() {
    local -i column="$1"
    shift
    if [[ -n "$*" ]] ; then
	while IFS= read -r 'line' ; do
	    if [[ -n "$line" ]] ; then
		printf "%${column}s%s\n" " " "$line"
	    fi
	done <<< "$*"
    else
	while IFS= read -r 'line' ; do
	    if [[ -n "$line" ]] ; then
		printf "%${column}s%s\n" " " "$line"
	    fi
	done
    fi
}

function finishCreation() {
    if (( doit )) ; then
	if [[ -n $accumulateddata ]] ; then
	    oc apply -f - <<< "$accumulateddata"
	    accumulateddata=
	fi
    fi
}

declare accumulateddata=

function createObject() {
    local data=
    while IFS='' read -r line ; do
	if [[ -n $line ]] ; then
	    if [[ -z $data ]] ; then
		data="---$nl"
	    fi
	    data+="$line$nl"
	fi
    done
    data+="$nl"
    if (( doit )) ; then
	accumulateddata+="$data"
	if (( ++blockitemcount >= blocksize )) ; then
	    oc apply -f - <<< "$accumulateddata"
	    accumulateddata=
	    blockitemcount=0
	    if (( sleeptime )) ; then
		sleep "$sleeptime"
	    fi
	fi
    else
	echo "$data"
    fi
}

function createNamespace() {
    local namespace=$1
    createObject <<EOF
apiVersion: v1
kind: Namespace
metadata:
  name: "${namespace}"
  labels:
    ${basename}: "true"
EOF
}

function createSecretYAML() {
    local namespace=$1
    local deployment=$2
    local i=$3
    cat <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: "secret-${namespace}-${deployment}-${i}"
  namespace: "$namespace"
  labels:
    ${basename}: "true"
data:
  key1: "$(base64 <<< "${namespace}X${deployment}Y${i}Z1")"
  key2: "$(base64 <<< "${namespace}X${deployment}Y${i}Z2")"
type: Opaque
EOF
}

function createSecrets() {
    local namespace=$1
    local depsPerNamespace=${2:-1}
    local secrets=${3:-1}
    local -i i
    local -i j
    for i in $(seq 0 $((depsPerNamespace - 1))) ; do
	for j in $(seq 0 $((secrets - 1))) ; do
	    createObject <<< "$(createSecretYAML "$namespace" "$i" "$j")"
	done
    done
}    

function createVolumeMountsYAML() {
    local namespace=$1
    local deployment=${2:-1}
    local secrets=${3:-1}
    local -i i
    if (( secrets )) ; then
	echo "volumeMounts:"
	for i in $(seq 0 $((secrets - 1))) ; do
	    local name="secret-${namespace}-${deployment}-$i"
	    indent 2 <<EOF
- name: $name
  mountPath: /etc/$name
  readOnly: true
EOF
	done
    fi
}

function createVolumesYAML() {
    local namespace=$1
    local deployment=${2:-1}
    local secrets=${3:-1}
    local -i i
    if (( secrets )) ; then
	echo "volumes:"
	for i in $(seq 0 $((secrets - 1))) ; do
	    local name="secret-${namespace}-${deployment}-$i"
	    indent 2 <<EOF
- name: $name
  secret:
    secretName: $name
EOF
	done
    fi
}

function createContainersClusterBusterYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i pods=$4
    local -i containers=$5
    local -i j
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: ${namespace}-$i-$j
  imagePullPolicy: IfNotPresent
  image: "busybox"
# resources:
#   requests:
#     cpu: 1m
#     memory: 5Mi
  securityContext:
    privileged: false
  command:
    - /bin/sh
  args:
    - -c
    - |
      trap 'exit 0' TERM
      (while : ; do date ; sleep 60 ; done)&
      sleep $podsleeptime
      exit 1
$(createVolumeMountsYAML "$namespace" "$i" "$secretCount" | indent 2)
EOF
    done
}

function createContainersPausePodYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i pods=$4
    local -i containers=$5
    local -i j
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: ${namespace}-$i-$j
  imagePullPolicy: IfNotPresent
  securityContext:
    privileged: false
  image: "gcr.io/google_containers/pause-amd64:3.0"
$(createVolumeMountsYAML "$namespace" "$i" "$secretCount" | indent 2)
EOF
    done
}

function createDeploymentClassicYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i pods=$4
    local -i containers=$5
    cat <<EOF
kind: Deployment
apiVersion: apps/v1
metadata:
  name: ${namespace}-$i
  namespace: $namespace
  labels:
    ${basename}: "true"
spec:
  replicas: $pods
  selector:
    matchLabels:
      app: ${namespace}-$i
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        ${basename}: "true"
        name: ${namespace}-$i
        app: ${namespace}-$i
    spec:
      terminationGracePeriodSeconds: 1
      restartPolicy: Always
      containers:
$(createContainers${podType}YAML "$@" | indent 8)
$(createVolumesYAML "$namespace" "$i" "$secretCount" | indent 6)
EOF
}

function createService() {
    local namespace=$1
    local deployment=$2
    createObject <<EOF
apiVersion: v1
kind: Service
metadata:
  name: "service-${deployment}"
  namespace: "$namespace"
  labels:
    ${basename}: "true"
spec:
  ports:
    - port: $port
      targetPort: $port
  selector:
    name: "${deployment}"
EOF
}

function createRoute() {
    local namespace=$1
    local deployment=$2
    createObject <<EOF
apiVersion: v1
kind: Route
metadata:
  name: "route-${deployment}"
  namespace: "$namespace"
  labels:
    ${basename}: "true"
spec:
  host: "service-${deployment}"
  to:
    kind: Service
    name: "service-${deployment}"
  selector:
    name: "${deployment}"
EOF
}

function createServerContainerPerl() {
    cat <<'EOF'
#!/usr/bin/perl
use Socket;
use strict;
use Time::Piece;
use Time::HiRes qw(gettimeofday);
$SIG{TERM} = sub { exit 0; };
sub timestamp($) {
    my ($str) = @_;
    my (@now) = gettimeofday();
    sprintf "%s.%06d %s", localtime($now[0])->strftime("%Y-%m-%d.%T"), $now[1], $str;
}    
my $listen_port = $ARGV[0];
my $sockaddr = "S n a4 x8";
socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp')) || die "socket: $!";
setsockopt(SOCK,SOL_SOCKET, SO_REUSEADDR, pack("l",1)) || die "setsockopt reuseaddr: $!\n";
setsockopt(SOCK,SOL_SOCKET, SO_KEEPALIVE, pack("l",1)) || die "setsockopt keepalive: $!\n";
bind(SOCK, pack($sockaddr, PF_INET, $listen_port, "\0\0\0\0")) || die "bind: $!\n";
listen(SOCK, 1) || die "listen: $!";
my $mysockaddr = getsockname(SOCK);
my ($junk, $port, $addr) = unpack($sockaddr, $mysockaddr);
die "can't get port $port: $!\n" if ($port ne $listen_port);
print STDERR timestamp("Listening on port $listen_port\n");

for (;;) {
    accept(CLIENT, SOCK) or next;
    if ((my $child = fork()) == 0) {
        close(SOCK);
        my $peeraddr = getpeername(CLIENT);
        my ($port, $addr) = sockaddr_in($peeraddr);
        my $peerhost = gethostbyaddr($addr, AF_INET);
        my $peeraddr = inet_ntoa($addr);
        print STDERR timestamp("Accepted connection from $peerhost ($peeraddr) on $port!\n");
        while (1) {
            my $buffer;
            my $nread;
            my $ntotal = 0;
            while ($ntotal < 32768 && ($nread = sysread(CLIENT, $buffer, 32768, $ntotal)) > 0) {
                $ntotal += $nread;
            }
            if ($nread < 0) {
                die "Write failed: $!\n";
            }
            if ($ntotal == 0) {
                print STDERR timestamp("Exiting $port\n");
                exit(0);
            }
            my $nwrite;
            while ($ntotal > 0 && ($nwrite = syswrite(CLIENT, $buffer, $ntotal)) > 0) {
                $ntotal -= $nwrite;
            }
            if ($nwrite < 0) {
                die timestamp("Write failed: $!\n");
            }
        }
    } else {
        close(CLIENT);
    }
}
EOF
}

function createServerContainerYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    cat <<EOF
- name: ${namespace}-${i}-server
  image: perl
  ports:
    - containerPort:
        $port
  command:
    - perl
  args:
    - -e
    - |
$(createServerContainerPerl | indent 6)
    - "$port"
$(createVolumeMountsYAML "$namespace" "$i" "$secretCount" | indent 2)
EOF
}

function createServerDeploymentYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    cat <<EOF
kind: Deployment
apiVersion: apps/v1
metadata:
  name: ${namespace}-${i}-server
  namespace: $namespace
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${namespace}-$i
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        name: ${namespace}-$i
        app: ${namespace}-$i
        k8s-app: ${namespace}-${i}-server
        ${basename}: "true"
    spec:
      terminationGracePeriodSeconds: 1
      containers:
$(createServerContainerYAML "$namespace" "$i" "$secretCount" | indent 8)
$(createVolumesYAML "$namespace" "$i" "$secretCount" | indent 6)
EOF
}

function createClientContainerPerl() {
    cat << 'EOF'
#!/usr/bin/perl

use Socket;
use POSIX;
use strict;
use Time::HiRes qw(gettimeofday usleep);
use Time::Piece;
$SIG{TERM} = sub { exit 0; };
sub timestamp($) {
    my ($str) = @_;
    my (@now) = gettimeofday();
    sprintf "%s.%06d %s", localtime($now[0])->strftime("%Y-%m-%d.%T"), $now[1], $str;
}    
my $connect_port = $ARGV[0];
my $sockaddr = "S n a4 x8";
my ($fname,$faliases,$ftype,$flen,$faddr)= gethostbyname($ARGV[1]);
my $sockmeta = pack($sockaddr, PF_INET, $connect_port, $faddr);
socket(CONN, PF_INET, SOCK_STREAM, getprotobyname('tcp')) || die "can't make socket: $!";
while (! connect(CONN, $sockmeta)) {
    print STDERR timestamp(" Could not connect to $ARGV[1] on port $connect_port: $!\n");
    sleep(5);
}
my $peeraddr = getpeername(CONN);
my ($port, $addr) = sockaddr_in($peeraddr);
my $peerhost = gethostbyaddr($addr, AF_INET);
$peeraddr = inet_ntoa($addr);
print STDERR timestamp("Connected to $peerhost ($peeraddr) on $port!\n");
my $buffer = "0";
my $tbuf;
my $nread;
for (my $i = 0; $i < 15; $i++) {
    $buffer = "$buffer$buffer"
}
my $bufsize = length($buffer);
my $starttime = gettimeofday();
my $MBSec = $ARGV[2] * 1;
if ($MBSec <= 0) {
    pause();
    exit 0;
}
while (1) {
    print STDERR timestamp("Read/Write $MBSec MiB  ");
    for (my $i = 0; $i < $MBSec * 32; $i++) {
        my $nwrite;
        my $nleft = $bufsize;
        while ($nleft > 0 && ($nwrite = syswrite(CONN, $buffer, $nleft)) > 0) {
            $nleft -= $nwrite;
        }
        if ($nwrite == 0) {
            exit 0;
        } elsif ($nwrite < 0) {
            die "Write failed: $!\n";
        }
        $nleft = $bufsize;
        my $tbuf;
        while (($nread = sysread(CONN, $tbuf, $nleft)) > 0) {
            $nleft -= $nread;
        }
        if ($nread < 0) {
            die "Read failed: $!\n";
        }
    }
    my $curtime = gettimeofday();
    $starttime += 1;
    if ($curtime < $starttime) {
        printf STDERR "Sleeping %8.6f\n", ($starttime - $curtime);
        usleep(($starttime - $curtime) * 1000000);
    } else {
        print STDERR "Not sleeping\n";
    }
}
EOF
}

function createClientContainerYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local dataRate=$4
    cat <<EOF
- name: ${namespace}-${i}-client
  image: "perl"
  command:
    - perl
  args:
    - -e
    - |
$(createClientContainerPerl | indent 6)
    - "$port"
    - "service-${namespace}-$i"
    - "$dataRate"
$(createVolumeMountsYAML "$namespace" "$i" "$secretCount" | indent 2)
EOF
}

function createClientDeploymentYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local replicas=$4
    local dataRate=$5
    cat <<EOF
kind: Deployment
apiVersion: apps/v1
metadata:
  name: ${namespace}-${i}-client
  namespace: $namespace
spec:
  replicas: $replicas
  selector:
    matchLabels:
      app: ${namespace}-${i}-client
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        name: ${namespace}-${i}-client
        app: ${namespace}-${i}-client
        ${basename}: "true"
    spec:
      terminationGracePeriodSeconds: 1
#      affinity:
#        podAntiAffinity:
#          requiredDuringSchedulingPreferredDuringExecution:
#            podAffinityTerm:
#              labelSelector:
#                matchExpressions:
#                  - key: k8s-app
#                    operator: In
#                    values:
#                      - ${namespace}-${i}-server
#              topologyKey: kubernetes.io/hostname
      containers:
$(createClientContainerYAML "$namespace" "$i" "$secretCount" "$dataRate" | indent 8)
$(createVolumesYAML "$namespace" "$i" "$secretCount" | indent 6)
EOF
}

function createDeploymentPausePod() {
    local namespace=$1
    local count=${2:-1}
    local secretCount=${3:-1}
    local pods=${4:-1}
    local containers=${5:-1}
    local -i i
    for i in $(seq 0 $((count - 1))) ; do
	createObject <<< "$(createDeploymentClassicYAML "$namespace" "$i" "$secretCount"  "$replicas" "$containers")"
    done
}

function createDeploymentClusterBuster() {
    createDeploymentPausePod "$@"
}

function createDeploymentServer() {
    local namespace=$1
    local count=${2:-1}
    local secretCount=${3:-1}
    local pods=${4:-1}
    local -i i
    for i in $(seq 0 $((count - 1))) ; do
	createService "$namespace" "$namespace-$i"
	createRoute "$namespace" "$namespace-$i"
	createObject <<< "$(createServerDeploymentYAML "$namespace" "$i" "$secretCount")"
	createObject <<< "$(createClientDeploymentYAML "$namespace" "$i" "$secretCount" "$replicas" "$dataRate")"
    done
}

function heartbeat() {
    trap exit INT
    while : ; do
	printf '%(%Y-%m-%dT%H:%M:%S%z)T\n' -1
	sleep 10
    done
}

function stop_heartbeat() {
    exec 3>&2 2>/dev/null
    jobs -p | while read -r job ; do
	kill "$job"
    done
    wait
    exec 2>&3 3>&-
}

function createNamespaces_n() {
    trap exit INT
    local parallel=$1; shift
    local rotor=$1; shift
    while (( rotor < namespaces )) ; do
	local j=0
	while (( j < blocksize && j + rotor < namespaces )) ; do
	    createNamespace "${basename}-$((rotor + j))"
	    j=$((j+1))
	done
	rotor=$((rotor + (parallel * blocksize)))
    done
    finishCreation
}

function createSecrets_n() {
    trap exit INT
    local parallel=$1; shift
    local rotor=$1; shift
    while (( rotor < namespaces )) ; do
	local j=0
	while (( j < blocksize && j + rotor < namespaces )) ; do
	    createSecrets "${basename}-$((rotor + j))" "$@"
	    j=$((j+1))
	done
	rotor=$((rotor + (parallel * blocksize)))
    done
    finishCreation
}

function createDeployments_n() {
    trap exit INT
    local parallel=$1; shift
    local rotor=$1; shift
    while (( rotor < namespaces )) ; do
	local j=0
	while (( j < blocksize && j + rotor < namespaces )) ; do
	    "createDeployment${podType}" "${basename}-$((rotor + j))" "$@"
	    j=$((j+1))
	done
	rotor=$((rotor + (parallel * blocksize)))
    done
    finishCreation
}

function run_clusterbuster_1() {
    trap 'kill -9 $(jobs -p); exit' INT
    for i in $(seq 0 "$((parallel - 1))") ; do
	createNamespaces_n "$parallel" "$((i * blocksize))" &
    done
    wait

    for i in $(seq 0 "$((parallel - 1))") ; do
	createSecrets_n "$parallel" "$((i * blocksize))" "$depsPerNamespace" "$secrets" &
    done
    wait

    for i in $(seq 0 "$((parallel - 1))") ; do
	createDeployments_n "$parallel" "$((i * blocksize))" "$depsPerNamespace" "$secrets" "$replicas" "$containers" &
    done
    wait
}

trap stop_heartbeat INT EXIT
heartbeat&
(run_clusterbuster_1)
