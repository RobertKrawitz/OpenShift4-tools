#!/bin/bash

set -u

declare -i namespaces=1
declare -i depsPerNamespace=1
declare -i secrets=0
declare -i replicas=1
declare -i parallel=1
declare -i containers=1
declare -i sleeptime=0
declare -i doit=1
declare -i blocksize=1
declare -i blockitemcount=0
declare -i port=7777
declare -i affinity=0
declare dataRate=0
declare podType=ClusterBuster
declare podsleeptime=infinity
declare basename=clusterbuster
declare opt
declare -r nl='
'

declare accumulateddata=

declare OC
OC=$(type -p oc)
OC=${OC:-$(type -p kubectl)}	# kubectl might not work, though...

declare _helpmsg
read -r -d '' _helpmsg <<'EOF'
Usage: $0 [options] [name]
       Default 1 namespace
    Options:
       -H              Print extended help
       -n              Print what would be done without doing it
       -P podtype      Pod type (classic, pause, server)
       -B basename     Base name of pods (default clusterbuster).
                       All objects are labeled with this name.
       -b blocksize    Number of objects to create in one oc call (default 1)
       -c containers   Number of containers per pod
       -D data rate    Data rate for client/server (MB/sec) (default 0)
       -d deployments  Number of deployments per namespace (default 1)
       -N namespaces   Number of namespaces to create (default 1)
       -p parallel     Number of operations to perform in parallel (default 1)
       -r replicas     Number of replicas per deployment (default 1)
       -s secrets      Number of secrets per deployment (default 0)
       -w wait         Number of seconds to wait between ops (default 0)
       -x              Use pod affinity between client and server (default no)
       -X              Use pod anti-affinity between client/server (default no)
       -z podsleep     Amount of time in seconds for pod to sleep before exit
                       (default infinity).  This may be an expression evaluated
                       as an argument to sleep(1) and need not be a numeric
                       constant.
EOF

function help() {
    echo "$_helpmsg"
    exit 1
}

function _helpExtended() {
    echo "$_helpmsg"
    cat <<'EOF'

Clusterbuster is a tool to permit you to load a configurable workload
onto an OpenShift cluster.  This is not a full-featured workload
generator like clusterloader; it generates very specific types of load
that for the most part focus on API objects.

Clusterbuster allows you to create three kinds of pods (via
deployments).  The type of pod is selected by the -P option.

- A simple pause-type implementation written in perl that emits a log
  heartbeat once a minute.

- Pause pod (uses the least resources)

- A client-server workload, with optional bidirectional data transfer
  at a specified data rate.


All three types allow you to configure the following load parameters:

- Number of namespaces created (-N)

- Number of deployments per namespace (-d)

- Number of replicas per deployment (-r)

- Number of containers per replica (-c)

- Number of secrets per deployment (-s)

The total number of pods created is (N * d * r) and the total number
of containers is (N * d * r * c).  The number of secrets is (N * d).
This is useful for testing of scaling of both nodes and apiserver/etcd
combination on the control plane.

The client-server workload consists of one server pod, with one
container, per deployment.  The clients and server can optionally
engage in ping-pong data transfer.  The number of client pods is
controlled by the number of replicas.  Therefore, each server will
service (r * c) connections.  Each container will attempt to transmit
up to the specified data rate (-D) megabytes/second, and then receive
the amount of data.  Via -x and -X it is possible to specify whether
clients will be colocated with their server (-x) or forced onto
different nodes (-X).  If neither option is specified, clusterbuster
allows OpenShift to place pods as it sees fit.  You can use `oc logs`
on a client pod (or use Prometheus metrics) to get data transfer
information.


You can run multiple concurrent clusterbusters by choosing different
basenames for each instance (-B).  All objects created by that run
will be tagged with the basename, in addition to 'clusterbusterbase'
(to allow you to easily find or delete all objects created by
clusterbuster).


Examples:

- You have a 30 node cluster and wish to test 500 pods per node, all
  in one namespace:

  clusterbuster -d 15000

- You wish to use 1000 namespaces for the same test:

  clusterbuster -N 1000 -d 15

- You wish to add 150,000 secrets to further stress the apiserver and
  etcd:

  clusterbuster -N 1000 -d 15 -s 10

- You wish to exchange data at 10 MB/sec, with 5 deployments in 2
  namespaces each of which uses 4 replica clients and 3 containers.
  You wish to place the clients on nodes other than the servers:

  clusterbuster -P server -N 2 -d 5 -r 4 -c 3 -X

EOF
}

function helpExtended() {
    _helpExtended | "${PAGER:-more}"
    exit 1
}

trap exit INT

while getopts ":B:b:c:ns:D:d:p:r:w:z:hHN:P:xX" opt ; do
    case "$opt" in
	n) doit=0			;;
	P) podType="$OPTARG"		;;
	B) basename="$OPTARG"		;;
	b) blocksize="$OPTARG"          ;;
	c) containers="$OPTARG"         ;;
	N) namespaces="$OPTARG"         ;;
	D) dataRate="$OPTARG"           ;;
	d) depsPerNamespace="$OPTARG"   ;;
	s) secrets="$OPTARG"            ;;
	r) replicas="$OPTARG"           ;;
	p) parallel="$OPTARG"           ;;
	w) sleeptime="$OPTARG"          ;;
	z) podsleeptime="$OPTARG"	;;
	x) affinity=1			;;
	X) affinity=2			;;
	h) help				;;
	H) helpExtended			;;
	*) help "$OPTARG"               ;;
    esac
done

shift $((OPTIND - 1))

if [[ -z $OC && $doit -gt 0 ]] ; then
    echo "Cannot find oc or kubectl command, exiting!"
    exit 1
fi

case "$podType" in
    classic|ClusterBuster) podType=ClusterBuster ;;
    server)                podType=Server        ;;
    pause|PausePod|*)      podType=PausePod      ;;
esac

if [[ -n ${1:-} ]] ; then
    basename="$1"
    shift
fi

[[ -z "$*" ]] || echo "Warning: extraneous arguments $# after basename will be ignored!" 1>&2

function indent_1() {
    local -i column="$1"
    local -r indent="$(printf "%${column}s")"
    while IFS= read -r 'line' ; do
	 [[ -z "$line" ]] || echo "${indent}${line}"
    done
}

function indent() {
    local -i column="$1"
    shift
    if [[ -n "$*" ]] ; then
	"$@" | indent_1 "$column"
    else
	indent_1 "$column"
    fi
}

function finishCreation() {
    if [[ $doit -ne 0 && -n $accumulateddata ]] ; then
	"${OC}" apply -f - <<< "$accumulateddata"
	accumulateddata=
    fi
}

function createObject() {
    local data=
    while IFS='' read -r line ; do
	if [[ -n $line ]] ; then
	    [[ -n $data ]] || data="---$nl"
	    data+="$line$nl"
	fi
    done
    data+="$nl"
    if (( doit )) ; then
	accumulateddata+="$data"
	if (( ++blockitemcount >= blocksize )) ; then
	    "${OC}" apply -f - <<< "$accumulateddata"
	    accumulateddata=
	    blockitemcount=0
	    (( !sleeptime )) || sleep "$sleeptime"
	fi
    else
	echo "$data"
    fi
}

function createNamespace() {
    local namespace=$1
    createObject <<EOF
apiVersion: v1
kind: Namespace
metadata:
  name: "${namespace}"
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
EOF
}

function createSecrets() {
    local namespace=$1
    local depsPerNamespace=${2:-1}
    local secrets=${3:-1}
    local -i i
    local -i j
    (( secrets )) || return;
    for i in $(seq 0 $((depsPerNamespace - 1))) ; do
	for j in $(seq 0 $((secrets - 1))) ; do
	    createObject <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: "secret-${namespace}-${i}-${j}"
  namespace: "$namespace"
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
data:
  key1: "$(base64 <<< "${namespace}X${i}Y${j}Z1")"
  key2: "$(base64 <<< "${namespace}X${i}Y${j}Z2")"
type: Opaque
EOF
	done
    done
}    

function createVolumeMountsYAML() {
    local namespace=$1
    local deployment=${2:-1}
    local secrets=${3:-1}
    (( secrets )) || return;
    echo "volumeMounts:"
    local -i i
    for i in $(seq 0 $((secrets - 1))) ; do
	local name="secret-${namespace}-${deployment}-$i"
	cat <<EOF
- name: $name
  mountPath: /etc/$name
  readOnly: true
EOF
    done
}

function createVolumesYAML() {
    local namespace=$1
    local deployment=${2:-1}
    local secrets=${3:-1}
    (( secrets )) || return;
    local -i i
    echo "volumes:"
    for i in $(seq 0 $((secrets - 1))) ; do
	local name="secret-${namespace}-${deployment}-$i"
	cat<<EOF
- name: $name
  secret:
    secretName: $name
EOF
    done
}

function createContainersClusterBusterYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i pods=$4
    local -i containers=$5
    local -i j
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: ${namespace}-$i-$j
  imagePullPolicy: IfNotPresent
  image: "busybox"
  command:
  - /bin/sh
  args:
  - -c
  - |
    trap 'exit 0' TERM
    (while : ; do date ; sleep 60 ; done)&
    sleep $podsleeptime
    exit 1
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createContainersPausePodYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i pods=$4
    local -i containers=$5
    local -i j
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: ${namespace}-$i-$j
  image: "gcr.io/google_containers/pause-amd64:3.0"
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createDeploymentClassicYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i pods=$4
    local -i containers=$5
    cat <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-$i
  namespace: $namespace
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  replicas: $pods
  selector:
    matchLabels:
      app: ${namespace}-$i
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        ${basename}: "true"
        clusterbusterbase: "true"
        name: ${namespace}-$i
        app: ${namespace}-$i
    spec:
      terminationGracePeriodSeconds: 1
      restartPolicy: Always
      containers:
$(indent 6 createContainers${podType}YAML "$@")
$(indent 6 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

function createService() {
    local namespace=$1
    local deployment=$2
    createObject <<EOF
apiVersion: v1
kind: Service
metadata:
  name: "service-${deployment}"
  namespace: "$namespace"
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  ports:
  - port: $port
    targetPort: $port
  selector:
    name: "${deployment}"
EOF
}

function createRoute() {
    local namespace=$1
    local deployment=$2
    createObject <<EOF
apiVersion: v1
kind: Route
metadata:
  name: "route-${deployment}"
  namespace: "$namespace"
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  host: "service-${deployment}"
  to:
    kind: Service
    name: "service-${deployment}"
  selector:
    name: "${deployment}"
EOF
}

declare serverContainerPerl
read -r -d '' serverContainerPerl <<'EOF'
#!/usr/bin/perl
use Socket;
use strict;
use Time::Piece;
use Time::HiRes qw(gettimeofday);
$SIG{TERM} = sub { exit 0; };
sub timestamp($) {
    my ($str) = @_;
    my (@now) = gettimeofday();
    sprintf "%s.%06d %s", localtime($now[0])->strftime("%Y-%m-%d.%T"), $now[1], $str;
}    
my $listen_port = $ARGV[0];
my $sockaddr = "S n a4 x8";
socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp')) || die "socket: $!";
setsockopt(SOCK,SOL_SOCKET, SO_REUSEADDR, pack("l",1)) || die "setsockopt reuseaddr: $!\n";
setsockopt(SOCK,SOL_SOCKET, SO_KEEPALIVE, pack("l",1)) || die "setsockopt keepalive: $!\n";
bind(SOCK, pack($sockaddr, PF_INET, $listen_port, "\0\0\0\0")) || die "bind: $!\n";
listen(SOCK, 1) || die "listen: $!";
my $mysockaddr = getsockname(SOCK);
my ($junk, $port, $addr) = unpack($sockaddr, $mysockaddr);
die "can't get port $port: $!\n" if ($port ne $listen_port);
print STDERR timestamp("Listening on port $listen_port\n");

for (;;) {
    accept(CLIENT, SOCK) || next;
    if ((my $child = fork()) == 0) {
        close(SOCK);
        my $peeraddr = getpeername(CLIENT);
        my ($port, $addr) = sockaddr_in($peeraddr);
        my $peerhost = gethostbyaddr($addr, AF_INET);
        my $peeraddr = inet_ntoa($addr);
        print STDERR timestamp("Accepted connection from $peerhost ($peeraddr) on $port!\n");
        while (1) {
            my $buffer;
            my $nread;
            my $ntotal = 0;
            while ($ntotal < 32768 && ($nread = sysread(CLIENT, $buffer, 32768, $ntotal)) > 0) {
                $ntotal += $nread;
            }
            if ($nread < 0) {
                die "Write failed: $!\n";
            }
            if ($ntotal == 0) {
                print STDERR timestamp("Exiting $port\n");
                exit(0);
            }
            my $nwrite;
            while ($ntotal > 0 && ($nwrite = syswrite(CLIENT, $buffer, $ntotal)) > 0) {
                $ntotal -= $nwrite;
            }
            if ($nwrite < 0) {
                die timestamp("Write failed: $!\n");
            }
        }
    } else {
        close(CLIENT);
    }
}
EOF

function createServerContainerYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    cat <<EOF
- name: ${namespace}-${i}-server
  image: perl
  ports:
  - containerPort: $port
  command:
  - perl
  args:
  - -e
  - |
$(indent 4 <<< "$serverContainerPerl")
  - "$port"
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
}

function createServerDeployment() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    createObject <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-${i}-server
  namespace: $namespace
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${namespace}-$i
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        name: ${namespace}-$i
        app: ${namespace}-$i
        k8s-app: ${namespace}-${i}-server
        ${basename}: "true"
        clusterbusterbase: "true"
    spec:
      terminationGracePeriodSeconds: 1
      containers:
$(indent 6 createServerContainerYAML "$namespace" "$i" "$secretCount")
$(indent 6 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

declare clientContainerPerl
read -r -d '' clientContainerPerl <<'EOF'
#!/usr/bin/perl

use Socket;
use POSIX;
use strict;
use Time::HiRes qw(gettimeofday usleep);
use Time::Piece;
$SIG{TERM} = sub { exit 0; };
sub timestamp($) {
    my ($str) = @_;
    my (@now) = gettimeofday();
    sprintf "%s.%06d %s", localtime($now[0])->strftime("%Y-%m-%d.%T"), $now[1], $str;
}    
my $connect_port = $ARGV[0];
my $sockaddr = "S n a4 x8";
my ($fname,$faliases,$ftype,$flen,$faddr)= gethostbyname($ARGV[1]);
my $sockmeta = pack($sockaddr, PF_INET, $connect_port, $faddr);
socket(CONN, PF_INET, SOCK_STREAM, getprotobyname('tcp')) || die "can't make socket: $!";
while (! connect(CONN, $sockmeta)) {
    print STDERR timestamp(" Could not connect to $ARGV[1] on port $connect_port: $!\n");
    sleep(5);
}
my $peeraddr = getpeername(CONN);
my ($port, $addr) = sockaddr_in($peeraddr);
my $peerhost = gethostbyaddr($addr, AF_INET);
$peeraddr = inet_ntoa($addr);
print STDERR timestamp("Connected to $peerhost ($peeraddr) on $port!\n");
my $buffer = "0";
my $tbuf;
my $nread;
for (my $i = 0; $i < 15; $i++) {
    $buffer = "$buffer$buffer"
}
my $bufsize = length($buffer);
my $starttime = gettimeofday();
my $MBSec = $ARGV[2] * 1;
if ($MBSec <= 0) {
    print STDERR "Not sending data (use -D to actually send data)\n";
    pause();
    exit 0;
}
while (1) {
    print STDERR timestamp("Read/Write $MBSec MiB  ");
    for (my $i = 0; $i < $MBSec * 32; $i++) {
        my $nwrite;
        my $nleft = $bufsize;
        while ($nleft > 0 && ($nwrite = syswrite(CONN, $buffer, $nleft)) > 0) {
            $nleft -= $nwrite;
        }
        if ($nwrite == 0) {
            exit 0;
        } elsif ($nwrite < 0) {
            die "Write failed: $!\n";
        }
        $nleft = $bufsize;
        my $tbuf;
        while (($nread = sysread(CONN, $tbuf, $nleft)) > 0) {
            $nleft -= $nread;
        }
        if ($nread < 0) {
            die "Read failed: $!\n";
        }
    }
    my $curtime = gettimeofday();
    $starttime += 1;
    if ($curtime < $starttime) {
        printf STDERR "Sleeping %8.6f\n", ($starttime - $curtime);
        usleep(($starttime - $curtime) * 1000000);
    } else {
        print STDERR "Not sleeping\n";
    }
}
EOF

function createClientContainerYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local dataRate=$4
    local containers=$5
    local -i j
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: ${namespace}-${i}-${j}-client
  image: "perl"
  command:
  - perl
  args:
  - -e
  - |
$(indent 4 <<< "$clientContainerPerl")
  - "$port"
  - "service-${namespace}-$i"
  - "$dataRate"
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createClientAffinityYAML() {
    (( affinity )) || return 0
    local server=$1
    local affinityType
    case "$affinity" in
	1) affinityType=Affinity     ;;
	*) affinityType=AntiAffinity ;;
    esac
    cat << EOF
affinity:
  pod$affinityType:
    requiredDuringSchedulingIgnoredDuringExecution:
    - labelSelector:
        matchExpressions:
        - key: k8s-app
          operator: In
          values:
          - "$server"
      topologyKey: kubernetes.io/hostname
EOF
}

function createClientDeployment() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local replicas=$4
    local dataRate=$5
    local containers=$6
    createObject <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-${i}-client
  namespace: $namespace
spec:
  replicas: $replicas
  selector:
    matchLabels:
      app: ${namespace}-${i}-client
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        name: ${namespace}-${i}-client
        app: ${namespace}-${i}-client
        ${basename}: "true"
        clusterbusterbase: "true"
    spec:
      terminationGracePeriodSeconds: 1
$(indent 6 createClientAffinityYAML "${namespace}-${i}-server")
      containers:
$(indent 6 createClientContainerYAML "$namespace" "$i" "$secretCount" "$dataRate" "$containers")
$(indent 6 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

function createDeploymentPausePod() {
    local namespace=$1
    local count=${2:-1}
    local secretCount=${3:-1}
    local pods=${4:-1}
    local containers=${5:-1}
    local -i i
    for i in $(seq 0 $((count - 1))) ; do
	createObject <<< "$(createDeploymentClassicYAML "$namespace" "$i" "$secretCount"  "$replicas" "$containers")"
    done
}

function createDeploymentClusterBuster() {
    createDeploymentPausePod "$@"
}

function createDeploymentServer() {
    local namespace=$1
    local count=${2:-1}
    local secretCount=${3:-1}
    local pods=${4:-1}
    local containers=${5:-1}
    local -i i
    for i in $(seq 0 $((count - 1))) ; do
	createService "$namespace" "$namespace-$i"
	createRoute "$namespace" "$namespace-$i"
	createServerDeployment "$namespace" "$i" "$secretCount"
	createClientDeployment "$namespace" "$i" "$secretCount" "$replicas" "$dataRate" "$containers"
    done
}

function createDeployment() {
    "createDeployment${podType}" "$@"
}

function heartbeat() {
    trap exit INT
    while : ; do
	printf '%(%Y-%m-%dT%H:%M:%S%z)T\n' -1
	sleep 10
    done
}

function stop_heartbeat() {
    exec 3>&2 2>/dev/null
    jobs -p | while read -r job ; do
	kill "$job"
    done
    wait
    exec 2>&3 3>&-
}

function createObjects_n() {
    trap exit INT
    local objtype=$1; shift
    local parallel=$1; shift
    local rotor=$1; shift
    while (( rotor < namespaces )) ; do
	local j=0
	while (( j < blocksize && j + rotor < namespaces )) ; do
	    "create${objtype}" "${basename}-$((rotor + j))" "$@"
	    j=$((j+1))
	done
	rotor=$((rotor + (parallel * blocksize)))
    done
    finishCreation
}

function run_clusterbuster_1() {
    trap 'kill -9 $(jobs -p); exit' INT
    for i in $(seq 0 "$((parallel - 1))") ; do
	createObjects_n Namespace "$parallel" "$((i * blocksize))" &
    done
    wait

    for i in $(seq 0 "$((parallel - 1))") ; do
	createObjects_n Secrets "$parallel" "$((i * blocksize))" "$depsPerNamespace" "$secrets" &
    done
    wait

    for i in $(seq 0 "$((parallel - 1))") ; do
	createObjects_n Deployment "$parallel" "$((i * blocksize))" "$depsPerNamespace" "$secrets" "$replicas" "$containers" &
    done
    wait
}

trap stop_heartbeat INT EXIT
heartbeat&
(run_clusterbuster_1)
