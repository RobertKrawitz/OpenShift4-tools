#!/bin/bash

# Copyright 2019-2021 Robert Krawitz/Red Hat
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -u

declare -i namespaces=1
declare useNamespaces=1
declare -i depsPerNamespace=1
declare -i secrets=0
declare -i replicas=1
declare -i parallel=1
declare -i firstDeployment=0
declare -i sleepSecrets=0
declare -i sleepConfigMaps=0
declare -i sleepNamespaces=0
declare -i sleepDeployments=0
declare -i parallelSecrets=0
declare -i parallelConfigMaps=0
declare -i parallelNamespaces=0
declare -i parallelDeployments=0
declare -i blocksize=1
declare -i blocksizeSecrets=0
declare -i blocksizeConfigMaps=0
declare -i blocksizeNamespaces=0
declare -i blocksizeDeployments=0
declare -i containers=1
declare -i createRoutes=0	# Is this even useful?
declare -i sleeptime=0
declare -i doit=1
declare -i blockitemcount=0
declare -i port=7777
declare -i syncPort=7778
declare syncHost=
declare -i affinity=0
declare -i verbose=0
declare -i wait_for_secrets=1
declare dataRate=0
declare -i bytes=0
declare -i bytesMax=0
declare -i msgSize=32768
declare -i poddelay=0
declare -i xferTime=0
declare -i xferTimeMax=0
declare -i exitAtEnd=1
declare -i reportObjectCreation=1
declare -i defaultBytes=1000000000
declare -A objectsCreated=()
declare baseoffset=0
declare podType=ClusterBuster
declare podsleeptime=infinity
declare basename=clusterbuster
declare deploymentType=pod
declare -i basetime
declare opt
declare -r nl=$'\n'
declare -a resource_requests=()
declare -a resource_limits=()
declare -A namespaces_in_use=()
declare -a namespaces_to_create=()
declare -i scale_ns=0
declare -i scale_deployments=1
declare -i syncStart=1
declare runtimeClass=
declare -a emptydirs=()
declare -a volumes=()
declare -A volume_mount_paths=()
declare -A volume_types=()
declare -A volume_type_keys=()
declare -A volume_scoped_names=()
declare -a sysbench_generic_options=()
declare -a sysbench_fileio_options=()
declare -A sysbench_fileio_tests=()
declare sysbench_fileio_test_string='seqwr,seqrd,rndwr,rndrd'
declare -a fio_generic_options=()
declare common_workdir=
declare -i report=0
declare report_format=
declare logStrategy=poll
declare -i precleanup=0
declare -i cleanup=0
declare -i timeout=-1
declare pathdir=${0%/*}
declare -a unknown_opts=()
declare -i totalObjectsCreated=0
# <name, filename with contents>
declare -a configMapFiles=()
declare -a tolerations=()
declare configmapMountDir=/etc/map
declare systemConfigmapMountDir=/etc/bootstrap
declare -i hasSystemConfigMap=0
declare nodeSelector='node-role.kubernetes.io/worker'
declare get_logs_pid
declare -i pbenchControllerPort=0
declare pbenchControllerAddress=
declare -i file_size=1024
declare -i file_block_size=0
declare -i file_volumes=0
declare -i file_dirs_per_volume=1
declare -i files_per_dir=1
declare -i processes_per_pod=1

declare -i log_bytes_per_line=1
declare -i log_bytes_per_io=1
declare -i log_xfer_count=1
declare -i log_processes=1
declare -i log_delay_usec=0
declare -i log_xfertime=0
declare -i log_exit_at_end=0
declare -r syncFlagFile="/tmp/syncfile";
# shellcheck disable=2155
declare -r runUUID=$(uuidgen -r)

declare kataRuntimeClass=kata
declare imagePullPolicy=Always
declare containerImage=quay.io/rkrawitz/bench-army-knife

declare accumulateddata=
declare -a plurals=('s' '')
declare KUBECTL_VALIDATE=

declare OC=${OC:-${KUBECTL:-}}
OC=${OC:-$(type -p oc)}
OC=${OC:-$(type -p kubectl)}	# kubectl might not work, though...

function fatal() {
    echo "$*" 1>&2
    exit 1
}

function warn() {
    echo "$*" 1>&2
}

if [[ -z "$OC" ]] ; then
    fatal "Can't find kubectl or oc"
elif [[ $OC = 'kubectl'* ]] ; then
    KUBECTL_VALIDATE=--validate=false
fi

declare __me__
__me__=$(realpath -e "$0")

if [[ -z "$__me__" ]] ; then
    echo "Can't find my path!" 1>&2
    exit 1
fi

declare __mydir__=${__me__%/*}
declare __libdir__=${__mydir__}/lib/clusterbuster

if [[ ! -d "$__libdir__" ]] ; then
    echo "Can't find my library dir!" 1>&2
    exit 1
fi

function _helpmsg() {
    local opt
    for opt in "$@" ; do
	echo "Unknown option $opt"
    done
cat <<EOF
Usage: $0 [options] [name]
    Help:
       -h              Print basic help information.
       -H              Print extended help.
       --help-everything
                       Print extended help, and in addition print a detailed
                       description including examples.

    Options:
       -B basename     Base name of pods (default clusterbuster).
                       All objects are labeled with this name.
       -b blocksize    Number of objects to create in one oc call (default 1)
       -c containers   Number of containers per pod
       -d deployments  Number of deployments per namespace (default 1)
       -E              Don't exit after all operations are complete.
       -e              Exit after all operations are complete (default).
       -f jobfile      Job file containing settings
       -n              Print what would be done without doing it
       -N namespaces   Number of namespaces to create (default 1)
                       If 0 is specified, then no namespaces are created
                       and the current namespace is used.
       -P podtype      Pod type, one of:
                       - cpu
                       - files
                       - fio
                       - log
                       - pause
                       - server
                       - sysbench
                       - classic
       -p parallel     Number of operations to perform in parallel (default 1)
       -Q              Don't report creation of individual objects (default
                       report them)
       -R processes    Number of processes per pod (default 1)
                       Applies to cpu and files only.
       -r replicas     Number of replicas per deployment (default 1)
       -S              Scale up (add namespaces to existing load) (default no)
       -s secrets      Number of secrets per deployment (default 0)
       -T type         Use the specified deployment type:
                       pod or deployment (default $deploymentType)
       -w wait         Number of seconds to wait between ops (default 0)
       -W              Wait for secrets to be created (default 1)
       -z podsleep     Amount of time in seconds for pod to sleep before exit
                       (default infinity).  This may be an expression evaluated
                       as an argument to sleep(1) and need not be a numeric
                       constant.
       --opt[=val]     Set the specified option.  Use -H or --help-everything
                       to get a list.
       -Y              Sync start of data transfer or CPU load (default yes)

    Client/server options:
       -D data rate    Data rate for client/server (MB/sec) (default 0)
                       May be a decimal number.
       -M MB[,max]     Amount of data to transfer.  If two values are
                       specified, the amount will be randomly chosen
                       per container.
       -m msgsize      Message size in data transfer
       -t time[,max]   Time (in seconds) to transfer data (default 0
                       means no time limit).  If two values are specified,
                       the amount will be randomly chosen per container.
       -v              Print verbose log messages.  Useful with
                       clusterbuster-connstat.
       -x              Use pod affinity between client and server (default no)
       -X              Use pod anti-affinity between client/server (default no)
EOF
}

function _helpExtended() {
    _helpmsg "$@"
    cat <<'EOF'

Extended Options:
    General Extended Options (short equivalents):
       --pod_type=type  Specify the type of pod (-P)
       --basename=name  Specify the base name (-B)
       --containers=N   Number of containers per pod (-c)
       --namespaces=N   Number of namespaces (-N)
       --secrets=N      Number of secrets (-s)
       --processes=N    Number of processes per pod (-R)
       --replicas=N     Number of replicas per deployment (-r)
       --podsleep=N     Time for pod to sleep before exit (-z)
       --baseoffset=N   Add specified offset to base time
                        for calculation of start time offset
                        to correct for clock skew.  May be float.
       --sync           Sync start of data transfer or CPU load
                        (default no) (-Y)
       --doit=<1,0>     Run the command or not (default 1) (inverse of -n)
       --report-format=<format>
                        Print report in specified format.  Meaning of
                        report types is by type.
                        - summary
                        - raw
                        - json
                        - verbose
       --report         Print summary report (client/server, soaker,
                        fio, sysbench only) (deprecated)
       --verbose-report Print detailed report (deprecated)
       --json-report    Print JSON report (deprecated)
       --raw-report     Print unprocessed report (deprecated)
       --precleanup     Clean up any prior objects
       --cleanup        Clean up generated objects
       --timeout=N      Time out reporting
       --image_pull_policy=<policy>
                        Image pull policy (default $imagePullPolicy)
       --report_object_creation=<1,0>
                        Report creation of individual objects (default 1)
                        (inverse of -Q)
       --log-strategy={poll,listen}
                        Use the desired logging strategy to retrieve logs.
                        - Poll indicates that sync pods should be polled
                          for logs.
                        - Listen indicates that pods should report log
                          data directly to this tool, which will listen
                          for the data.
                        The default strategy is polling, which should work
                        in all cases.  The older listen strategy will not
                        work if pods cannot connect to the host from which
                        this tool is run.  Polling should be used unless
                        there is reason to believe it is not functioning.
       --uuid=<uuid>    Use the specified UUID for the run.  Default is to
                        generate a random-based UUID.

    Tuning object creation (short equivalents):
       --scale-ns=[0,1] Scale up the number of namespaces.
                        (default 0)
       --scale-deployments=[0,1]
                        Scale up the number of deployments.
                        (default 1) (-S)
       --first_deployment=N
                        Specify the index of the first deployment.
                        Default is 0 (but see --scale_deployments)
       --first_secret=N
       --first_namespace=N
       --first_deployment=N
       --blocksize=N    Number of objects per oc call (-b)
                        Below options default to blocksize
       --blocksize_secrets=N
       --blocksize_namespaces=N
       --blocksize_deployments=N
       --sleep=N        Number of seconds between object creations (-w)
                        Below options default to sleeptime
       --sleep_secrets=N
       --sleep_namespaces=N
       --sleep_deployments=N
       --parallel=N     Number of operations in parallel (-p)
                        Below options default to parallel
       --parallel_secrets=N
       --parallel_namespaces=N
       --parallel_deployments=N
       --node_selector=selector
                        Annotate pods with the specified node selector
                        Default $nodeSelector
                        Specify empty value to not provide a node selector.

    Pod Options:
       --container_image=<image>
                        Image to use (default $containerImage).
                        Does not apply to "classic" or "pause" pod types.
       --deployment_type=<pod,deployment>
                        Deploy via individual pods or deployments (default $deploymentType)
                        (-T)
       --external_sync=host:port
                        Sync to external host rather than internally
       --<type>=<resource=value>
                        Resource requests and limits
                        <type> is request or limit.
       --runtimeclass=class
                        Run the pods in the designated runtimeclass.
       -K
       --kata           Synonym for --runtimeclass=${kataRuntimeClass}
       --emptydir=dir   Mount an emptydir volume at the specified mount point.
       --tolerate=<key:operator:effect>
                        Apply the specified tolerations to created pods.

    Using PBench:
       If pbench is to be used, both arguments below must be provided.
       --pbench_controller_address=address
                        Use the specified address to connect to the controller.
       --pbench_controller_port=port
                        Use the specified port to connect to the controller.

    Using Files:
       --volumes=N      Use the specified number of volumes.
                        If not provided, /tmp (writable layer) is used.
       -V name:type:name_type:mount_name:mount_path
       --volume=name:type:name_type:mount_name:mount_path
                        Mount a specified persistent volume.
                        name is the name of the volume (required).
                        type is the type of volume (required).
                        mount_path is the path on which to mount the volume
                            (required).
                        type_key is the key for the volume (e. g.
                            claimName for persistentVolumeClaim)
                        scoped_name is the volume's name as recognized
                            by the description.
       --dirs-per-volume=N
                        Create the specified number of directories per volume.
                        Default 1.
       --files-per-dir=N
                        Create the specified number of files per directory.
       --file-size=N
                        Each file should be of the specified size.
                        Sizes may be in bytes, [KMGT]iB, or [KMGT]B.
       --file-block-size=N
                        Write files using the specified I/O chunk size.
                        If unspecified, it defaults to the file size.
                        This should be a divisor of the file size; if not,
                        the results are unspecified.

    Client/server options:
       --affinity       Force affinity between client and server pods
                        in a deployment.  Default is neither affinity nor
                        anti-affinity.
       --anti-affinity  Force anti-affinity between client and server pods
                        in a deployment.  Default is neither affinity nor
                        anti-affinity.
       --bytes=N[,M]    Number of bytes to transfer
                        Also --kb, --kib, --mb, --mib, --gb, --gib, --tb, --tib
                        (-M is equivalent to --mb)
       --create_routes  Create routes for services (default 0)
       --datarate=N     Data transfer rate (-D)
       --exit_at_end    Exit upon completion of transfer (-e/-E)
       --msgsize=N      Message size for data transfer (-m)
       --poddelay=N     Time in seconds to wait for pods to start data xfer
       --transfertime=N Time to transfer data (-t).  Two comma-separated
                        numbers may be used to specify maximum time.
       --verbose        Print verbose log messages (-v)
       --wait_secrets   Wait for secrets to be created (-W) (default 1)

    Fio and Sysbench Common Options:

    Fio General Options:
       --fio-general-options=<options>
                        Space or comma separated general fio options
       --workdir=<dir>  Use the specified working directory for file I/O
       --fio-jobfile=<file>
                        Name of fio job file to use.  May be repeated.

    Sysbench General Options:
       --sysbench-general-options=<options>
                        Space or comma separated general Sysbench options

    Sysbench FileIO Options:
       --sysbench-fileio-tests=<modes>
                        Space of comma separated list of file test modes
                        to use (seqwr, seqrewr, seqrd, rndrd, rndwr, rndrw)
                        If multiple modes are specified, modes are
                        spread around.
       --sysbench-fileio-options=<options>
                        Space or comma separated fileio Sysbench options

    Log Options:
       --log-bytes-per-line=<bytes_per_line>
                        Number of bytes per line to log.
                        Default $log_bytes_per_line.
       --log-bytes-per-io=<bytes_per_io>
                        Number of bytes per message to log.
                        Rounded up to full lines.  Default $log_bytes_per_io.
       --log-xfer-count=<count>
                        Number of messages to log (in I/Os)
                        Default $log_xfer_count.  If zero, log
                        continuously (subject to log-xfertime).
       --log-processes=<processes>
                        Number of processes per pod.
                        Default $log_processes.
       --log-delay-usec=<usecs>
                        Time in microseconds to delay between I/O.
       --log-xfertime=<time>
                        Number of seconds to log.
                        Default $log_xfertime.  If zero, log continuously
                        (subject to log-xfer-count
       --log-exit-at-end=<bool>
                        Whether to exit when complete, or just stick around.
                        Default $log_exit_at_end.
EOF
}

function _helpEverything() {
    _helpExtended "$@"
    cat <<'EOF'


Clusterbuster is a tool to permit you to load a configurable workload
onto an OpenShift cluster.  This is not a full-featured workload
generator like clusterloader; it generates very specific types of load
that for the most part focus on API objects.

Clusterbuster allows you to create three kinds of pods (via
deployments).  The type of pod is selected by the -P option.

- A simple pause-type implementation written in perl that emits a log
  heartbeat once a minute.

- Pause pod (uses the least resources).  Useful for testing the control
  plane, but not the data plane.

- A client-server workload, with optional bidirectional data transfer
  at a specified data rate.  Allows load testing of the data plane.


All three types allow you to configure the following load parameters:

- Number of namespaces created (-N)

- Number of deployments per namespace (-d)

- Number of replicas per deployment (-r)

- Number of containers per replica (-c)

- Number of secrets per deployment (-s)

The total number of pods created is (N * d * r) and the total number
of containers is (N * d * r * c).  The number of secrets is (N * d).
This is useful for testing of scaling of both nodes and apiserver/etcd
combination on the control plane.


The client-server workload consists of one server pod, with one
container, per deployment.  The clients and server can optionally
engage in ping-pong data transfer.  The number of client pods is
controlled by the number of replicas.  Therefore, each server will
service (r * c) connections.  Each container will attempt to transmit
up to the specified data rate (-D) megabytes/second, and then receive
the amount of data.  The amount of data to be sent can be specified
via -M, in megabytes; the size of each message can be specified via
-m, in bytes.  By default, no data is sent.  The amount of time to
perform data transfer can be specified by -t (default is none).

Via -x and -X it is possible to specify whether clients will be
colocated with their server (-x) or forced onto different nodes (-X).
If neither option is specified, clusterbuster allows OpenShift to
place pods as it sees fit.  You can use `oc logs` on a client pod (or
use Prometheus metrics) to get data transfer information; with -v,
verbose information about each transfer is printed.

The client logs the following at the end of any data transfer:

STATS <atime> <stime> <gtime> <etime> <endtime> <user> <sys> <interval> <data> <detime> <rate> <mean> <stdev>

defined as:

atime           Time (seconds from start of run) of "oc apply" to
                create the client
stime           Time when the client started running
gtime           Time when "gethostbyname" completed
etime           Time when connection to server succeeded
endtime         Time when client completed
user            User CPU time
system          System CPU time
interval        Duration between first attempt to connect and
                successful connection
data            Number of data bytes sent and received
detime          Elapsed time for data transmission/reception
rate            Rate (MB/sec) of data transfer, if any
mean            Mean time sleeping between messages to attempt to
                achieve the desired transmission rate
stdev           Standard deviation of sleep interval between messages

You can use `clusterbuster-connstat` to extract client information about a
running or completed test run, including the above data.  Running
`clusterbuster -v` allows `clusterbuster-connstat` to extract data about
transfers completed thus far.


You can run multiple concurrent clusterbusters by choosing different
basenames for each instance (-B).  All objects created by that run
will be tagged with the basename, in addition to 'clusterbusterbase'
(to allow you to easily find or delete all objects created by
clusterbuster).


Examples:

- You have a 30 node cluster and wish to test 500 pods per node, all
  in one namespace:

  clusterbuster -d 15000

- You wish to use 1000 namespaces for the same test:

  clusterbuster -N 1000 -d 15

- You wish to add 150,000 secrets to further stress the apiserver and
  etcd:

  clusterbuster -N 1000 -d 15 -s 10

- You wish to exchange data at 10 MB/sec with a total of 2 GB per client,
  with 5 deployments in 2 namespaces each of which uses 4 replica clients
  and 3 containers.  You wish to place the clients on nodes other than the
  servers:

  clusterbuster -P server -N 2 -d 5 -r 4 -c 3 -X -v

EOF
}

function help() {
    _helpmsg "$@" | "${PAGER:-more}"
    exit 1
}

function help_extended() {
    _helpExtended "$@" | "${PAGER:-more}"
    exit 1
}

# shellcheck disable=SC2120
function help_everything() {
    _helpEverything "$@" | "${PAGER:-more}"
    exit 1
}

function ts() {
    local dt
    dt=$(date '+%s.%N')
    local sec=${dt%.*}
    local ns=${dt#*.}
    echo "${sec}.${ns:0:6}"
}

function timestamp() {
    while IFS= read -r 'LINE' ; do
	printf "%s %s\n" "$(TZ=GMT-0 date '+%Y-%m-%dT%T.%N' | cut -c1-26)" "$LINE"
    done
}

trap exit INT

function monitor_pods() {
    exec 0</dev/null 1>/dev/null
    local arg
    local -i timeout=-1
    local -i ppid=0
    OPTIND=0
    while getopts "t:p:" arg "$@" ; do
	case "$arg" in
	    p) ppid="$OPTARG"    ;;
	    t) timeout="$OPTARG" ;;
	    *)                   ;;
	esac
    done
    shift $((OPTIND - 1))
    if ((timeout > 0)) ; then
	timeout=$(($(date +%s) + timeout))
    fi
    while : ; do
	# shellcheck disable=2034
	while read -r name rdy status rest ; do
	    case "${status,,}" in
		error|failed)
		    echo "Pod $name $status!" 1>&2
		    if (( ppid > 0 )) ; then
			exec 2>/dev/null
			kill -USR1 "$ppid"
		    fi
		    return 1
		    ;;
		*)  ;;
	    esac
	done <<< "$(__OC get pods -A --no-headers "$@" 2>/dev/null)"
	if ((timeout > 0 && $(date +%s) > timeout)) ; then
	    echo "Monitor pods timeout!" 1>&2
	    if (( ppid > 0 )) ; then
		exec 2>/dev/null
		kill -USR1 "$ppid"
	    fi
	    return 1
	fi
	sleep 5
    done
}

function run_logger() {
    local -a pids_to_kill=()
    OPTIND=0
    while getopts "p:" arg "$@" ; do
	case "$arg" in
	    p) pids_to_kill+=("$OPTARG") ;;
	    *)                           ;;
	esac
    done
    shift $((OPTIND-1))
    trap '[[ -n "${pids_to_kill[*]}" ]] && exec 2>/dev/null && kill $(jobs -p) && "${pids_to_kill[@]}" && return 1' TERM INT HUP
    "$@" </dev/null &
    # shellcheck disable=2207
    pids_to_kill+=($(jobs -p))
    wait
    # shellcheck disable=SC2046
    if [[ -n "${pids_to_kill[*]}" ]] ; then
	exec 2>/dev/null
	kill -USR2 "${pids_to_kill[@]}"
	[[ -n "$(jobs -p)" ]] && kill $(jobs -p)
    fi
}

function get_logs_poll() {
    local pod
    local status
    local counter=$#
    for pod in "$@" ; do
	pod_status_found=0
	while : ; do
	    # shellcheck disable=SC2086
	    status=$(oc get pod $pod -o jsonpath="{.status.phase}" 2>/dev/null)
	    case "$status" in
		Running)
		    break
		    ;;
		Pending)
		    pod_status_found=1
		    sleep 1
		    ;;
		Error|Failed)
		    pod_status_found=1
		    echo "Status of pod $pod failed!" 1>&2
		    return 1
		    ;;
		''|Succeeded)	# Might be an old pod not yet deleted
		    if ((pod_status_found)) ; then
			echo "Unexpected status '$status' of pod $pod!" 1>&2
			return 1
		    else
			sleep 1
		    fi
		    ;;
		*)
		    pod_status_found=1
		    echo "Unexpected status '$status' of pod $pod!" 1>&2
		    return 1
		    ;;
	    esac
	done
	# shellcheck disable=SC2086
	local cleanupCommand="; sleep 1; rm -f '$syncFlagFile'"
	trap 'exec 2>/dev/null; [[ -n "$(jobs -p)" ]] && kill $(jobs -p); return 1' INT TERM HUP
	trap 'exec 2>/dev/null; kill $(jobs -p); return 1' USR1
	trap 'exec 3>&2 2>/dev/null ; kill $(jobs -p) && wait ; exec 2>&3 3>&-' USR2
	local mypid=$BASHPID
	monitor_pods -p "$mypid" -- -l "${basename}-id=$runUUID" &
	# shellcheck disable=SC2086
	run_logger -p "$mypid" oc rsh -T $pod sh -c "while [[ ! -f '$syncFlagFile' ]] ; do sleep 5; done; cat '$syncFlagFile' $cleanupCommand" &
	wait
	# shellcheck disable=SC2046
	if [[ -n "$(jobs -p)" ]] ; then
	    exec 3>&2 2>/dev/null
	    kill $(jobs -p)
	    wait
	    exec 2>&3 3>&-
	fi
	if ((--counter > 0)) ; then
	    echo ','
	fi
    done
}

function get_logs_listen() {
    "${__libdir__}/get_logs" "$@"
}

function _get_logs() {
    echo '{"clusterbusterResults": ['
    "$@"
    echo ']}'
}

function get_logs() {
    local extra_arg=
    case "$report_format" in
	json)    extra_arg=-j ;;
	verbose) extra_arg=-v ;;
	raw)     extra_arg=-R ;;
	*)                    ;;
    esac
    log_cmd=get_logs_poll
    if [[ ${logStrategy,,} = 'listen'* ]] ; then
	log_cmd=get_logs_listen
    fi
#    _get_logs "$log_cmd" "$@" | "${pathdir:-.}/clusterbuster-connstat" -l "${basename}-id=$runUUID" -s -f - "$extra_arg"
    _get_logs "$log_cmd" "$@"
    return $((PIPESTATUS[0] || PIPESTATUS[1]))
}

function set_xfer() {
    local sizespec=$1
    local -i scale=${2:-1}
    if [[ $sizespec = *','* ]] ; then
	bytes=$((${sizespec#*,} * scale))
	bytesMax=$((${sizespec%%,*} * scale))
	if (( bytes > bytesMax )) ; then
	    local -i tmp=$bytes
	    bytes=$bytesMax
	    bytesMax=$tmp
	fi
    else
	bytes=$((sizespec * scale))
	bytesMax=$((sizespec * scale))
    fi
}

function set_xfer_time() {
    local timespec=$1
    if [[ $timespec = *','* ]] ; then
	xferTime=${timespec#*,}
	xferTimeMax=${timespec%%,*}
	if (( xferTime > xferTimeMax )) ; then
	    local -i tmp=$xferTime
	    xferTime=$xferTimeMax
	    xferTimeMax=$tmp
	fi
    else
	xferTime=$timespec
	xferTimeMax=$timespec
    fi
}

function process_volume() {
    local volspec=$1
    local vname=
    local vtype=
    local vmount_path=
    IFS=':' read -r vname vtype vmount_path vtype_key vscoped_name <<< "$volspec"
    if [[ -z "$vname" || -z "$vtype" || -z "$vmount_path" ]] ; then
	echo "name, type, type_key, scoped name, and mount path must be provided"
	echo "for volumes"
	exit 1
    fi
    volumes+=("$vname")
    volume_mount_paths["$vname"]=$vmount_path
    volume_types["$vname"]=$vtype
    volume_type_keys["$vname"]=$vtype_key
    volume_scoped_names["$vname"]=$vscoped_name
}

function parse_size() {
    if [[ $1 =~ ([[:digit:]]+)([[:alpha:]]*) ]] ; then
	local size=${BASH_REMATCH[1]}
	local size_modifier=${BASH_REMATCH[2],,}
	local -i size_multiplier=1
	case "$size_modifier" in
	    ''|b)          size_multiplier=1                ;;
	    kb|kilobytes)  size_multiplier=1000             ;;
	    ki|kib|kibibytes) size_multiplier=1024          ;;
	    mb|megabytes)  size_multiplier=1000000          ;;
	    mi|mib|mebibytes) size_multiplier=1048576       ;;
	    gb|gigabytes)  size_multiplier=1000000000       ;;
	    gi|gib|gibibytes) size_multiplier=1073741824    ;;
	    tb|terabytes)  size_multiplier=1000000000000    ;;
	    ti|tib|tebibytes) size_multiplier=1099511627776 ;;
	    *) fatal "Cannot parse size $optvalue"          ;;
	esac
	echo $((size*size_multiplier))
    else
	fatal "Cannot parse filesize $optvalue"
    fi
}

function process_option() {
    local option=$1
    option=${option%% }
    option=${option## }
    [[ -n "$option" ]] || return
    local optname
    local optvalue
    optname=${option%%=*}
    optname=${optname,,}
    optvalue=${option#*=}
    noptname=${optname//-/_}
    if [[ $option != *'='* ]] ; then
	if [[ $noptname = "no_"* || $optname = "dont_"* ]] ; then
	    noptname=${noptname#dont_}
	    noptname=${noptname#no_}
	    optvalue=0
	else
	    optvalue=1
	fi
    fi
    local noptname1=${noptname//_/}
    # shellcheck disable=SC2206
    # shellcheck disable=SC2119
    case "$noptname1" in
	helpall*)		    help_extended				;;
	helpeverything*)	    help_everything				;;
	help*)			    help					;;
	podtype)		    podType=$optvalue				;;
	basename)		    basename=$optvalue				;;
	blocksize)		    blocksize=$optvalue				;;
	containers)		    containers=$optvalue			;;
	deployments|depspername*)   depsPerNamespace=$optvalue			;;
	namespaces)		    namespaces=$optvalue			;;
	datarate)		    dataRate=$optvalue				;;
	bytes)			    set_xfer "$(parse_size "$optvalue")"	;;
	kb|kilobytes)		    set_xfer "$optvalue" 1000			;;
	ki|kib|kibibytes)	    set_xfer "$optvalue" 1024			;;
	mb|megabytes)		    set_xfer "$optvalue" 1000000		;;
	mi|mib|mebibytes)	    set_xfer "$optvalue" 1048576		;;
	gb|gigabytes)		    set_xfer "$optvalue" 1000000000		;;
	gi|gib|gibibytes)	    set_xfer "$optvalue" 1073741824		;;
	tb|terabytes)		    set_xfer "$optvalue" 1000000000		;;
	ti|tib|tebibytes)	    set_xfer "$optvalue" 1099511627776		;;
	msgsize)		    msgSize=$optvalue				;;
	secrets)		    secrets=$optvalue				;;
	verbose)		    verbose=$optvalue				;;
	doit)			    doit=$optvalue				;;
	quiet)			    verbose=$((!optvalue))			;;
	processes)		    processes_per_pod=$optvalue			;;
	replicas)		    replicas=$optvalue				;;
	parallel)		    parallel=$optvalue				;;
	sleep)			    sleeptime=$optvalue				;;
	podsleep)		    podsleeptime=$optvalue			;;
	poddelay)		    poddelay=$optvalue				;;
	transfertime)		    set_xfer_time "$optvalue"			;;
	firstdeployment)	    firstDeployment=$optvalue			;;
	parallelconfigmaps)	    parallelConfigMaps=$optvalue		;;
	parallelsecrets)	    parallelSecrets=$optvalue			;;
	parallelnamespaces)	    parallelNamespaces=$optvalue		;;
	paralleldeployments)	    parallelDeployments=$optvalue		;;
	blocksizeconfigmaps)	    blocksizeConfigMaps=$optvalue		;;
	blocksizesecrets)	    blocksizeSecrets=$optvalue			;;
	blocksizenamespaces)	    blocksizeNamespaces=$optvalue		;;
	blocksizedeployments)	    blocksizeDeployments=$optvalue		;;
	containerimage)		    containerImage=$optvalue			;;
	imagepullpolicy)	    imagePullPolicy=$optvalue			;;
	sleepconfigmaps)	    sleepConfigMaps=$optvalue			;;
	sleepsecrets)		    sleepSecrets=$optvalue			;;
	sleepnamespaces)	    sleepNamespaces=$optvalue			;;
	sleepdeployments)	    sleepDeployments=$optvalue			;;
	nodeselector)		    nodeSelector=$optvalue			;;
	exitatend)		    exitAtEnd=$optvalue				;;
	resourcerequest)	    resource_requests+=("$optvalue")		;;
	resourcelimit)		    resource_limits+=("$optvalue")		;;
	createroutes)		    createRoutes=$optvalue			;;
	waitsecrets)		    wait_for_secrets=$optvalue			;;
	scalens)	   	    scale_ns=$optvalue				;;
	scaledeployments)   	    scale_deployments=$optvalue			;;
	deploymenttype)		    deploymentType=$optvalue			;;
	runtimeclass)		    runtimeClass=$optvalue			;;
	reportobjectcreation)	    reportObjectCreation=$optvalue		;;
	kata)			    runtimeClass=${kataRuntimeClass}		;;
	volumes)		    file_volumes=$optvalue			;;
	dirspervolume)	    	    file_dirs_per_volume=$optvalue		;;
	filesperdir)		    files_per_dir=$optvalue			;;
	fileblocksize)	    	    file_block_size=$(parse_size $optvalue)	;;
	filesize)		    file_size=$(parse_size $optvalue)		;;
	logbytesperline)	    log_bytes_per_line=$optvalue		;;
	logbytesperio)		    log_bytes_per_io=$optvalue			;;
	logxfercount)		    log_xfer_count=$optvalue			;;
	logprocesses)		    log_processes=$optvalue			;;
	logdelayusec)		    log_delay_usec=$optvalue			;;
	logxfertime)		    log_xfertime=$optvalue			;;
	logexitatend)		    log_exit_at_end=$optvalue			;;
	reportformat)		    report_format=$optvalue			;;
	report)		    	    report_format=summary			;;
	verbosereport)		    report_format=verbose			;;
	jsonreport)		    report_format=json				;;
	rawreport)		    report_format=raw				;;
	precleanup)		    precleanup=$optvalue			;;
	cleanup)		    cleanup=$optvalue				;;
	logstrategy)		    logStrategy=$optvalue			;;
	timeout)		    timeout=$optvalue				;;
	emptydir)		    emptydirs+=("$optvalue")			;;
	volume)			    process_volume "$optvalue"			;;
	sync|syncstart)		    syncStart=$((1-syncStart))			;;
	baseoffset)		    baseoffset=$optvalue			;;
	configmapfile)		    configMapFiles+=("$optvalue")		;;
	tolerate|toleration)	    tolerations+=("$optvalue")			;;
	pbenchcontrollerport)	    pbenchControllerPort=$optvalue		;;
	pbenchcontrolleraddress)    pbenchControllerAddress=$optvalue		;;
	workdir)		    common_workdir=$optvalue			;;
	uuid)			    runUUID=$optvalue				;;
	sysbenchgeneraloptions)     sysbench_generic_options+=(${optvalue//,/ });;
	sysbenchgenericoptions)     sysbench_generic_options+=(${optvalue//,/ });;
	sysbenchfileiooptions)      sysbench_fileio_options+=(${optvalue//,/ }) ;;
	sysbenchfileiotests)	    sysbench_fileio_test_string=$optvalue	;;
	fiogenericoptions)	   fio_generic_options+=(${optvalue//,/ })      ;;
	fiojobfile)
	    if [[ ! -f "$optvalue" ]] ; then
	       echo "Job file $optvalue does not exist"
	       help
	    fi
	    configMapFiles+=("$optvalue")
	    ;;
	affinity)
	    case "$optvalue" in
		1|'') affinity=1      ;;
		2|anti) affinity=2    ;;
		*) affinity=0         ;;
	    esac
	    ;;
	antiaffinity)
	    case "$optvalue" in
		1|'') affinity=2      ;;
		*) affinity=0         ;;
	    esac
	    ;;
	externalsync)
	    if [[ $optvalue =~ ^(-|([[:alnum:]][-_[:alnum:]]*[[:alnum:]]\.)*([[:alnum:]][-_[:alnum:]]*[[:alnum:]])):([1-9][[:digit:]]{0,4})$ ]] ; then
		syncHost=${BASH_REMATCH[1]}
		syncPort=${BASH_REMATCH[4]}
		if (( syncPort > 65535 )) ; then
		    echo "Illegal external sync port (must be 1 <= port <= 65535)"
		    help
		fi
		syncStart=1
	    else
		echo "Undecipherable external sync host:port $optvalue"
		help
	    fi
	    ;;
	*) unknown_opts+=("$noptname ($noptname1)") ;;
    esac
    if [[ $deploymentType != pod && $deploymentType != deployment ]] ; then
	echo "-T/--deployment_type must be either pod or deployment"
	help
    fi
}

function checkConfigMaps() {
    local errors=0
    for mapfile in "$@" ; do
	if [[ ! -r "$mapfile" ]] ; then
	    echo "Can't find configmap file $mapfile"
	    errors=$((errors+1))
	fi
    done
    if (( errors )) ; then
	exit 1
    fi
}

function process_job_file() {
    local jobfile="$1"
    if [[ ! -f $jobfile || ! -r $jobfile ]] ; then
	fatal "Job file $jobfile cannot be read"
    fi
    while IFS= read -r line ; do
	if [[ -z "$line" ]] ; then continue; fi
	line=${line%%#*}
	process_option "$line"
    done < "$jobfile"
}

while getopts ":B:b:c:D:d:Eef:HhKM:m:N:nP:p:QqR:r:Ss:T:t:V:vWw:XxYz:-:" opt ; do
    case "$opt" in
	B) basename="$OPTARG"		    ;;
	b) blocksize="$OPTARG"              ;;
	c) containers="$OPTARG"             ;;
	D) dataRate="$OPTARG"               ;;
	d) depsPerNamespace="$OPTARG"       ;;
	E) exitAtEnd=0			    ;;
	e) exitAtEnd=1			    ;;
	f) process_job_file "$OPTARG"	    ;;
	h) help				    ;;
	H) help_extended		    ;;
	K) runtimeClass="$kataRuntimeClass" ;;
	m) msgSize="$OPTARG"		    ;;
	M) set_xfer "$OPTARG" 1000000	    ;;
	n) doit=0			    ;;
	N) namespaces="$OPTARG"             ;;
	p) parallel="$OPTARG"               ;;
	P) podType="$OPTARG"		    ;;
	Q) reportObjectCreation=0	    ;;
	q) verbose=0			    ;;
	R) processes_per_pod="$OPTARG"	    ;;
	r) replicas="$OPTARG"               ;;
	S) scale_ns=1			    ;;
	s) secrets="$OPTARG"                ;;
	T) deploymentType="$OPTARG"	    ;;
	t) set_xfer_time "$OPTARG"	    ;;
	V) process_volume "$OPTARG"	    ;;
	v) verbose=1			    ;;
	w) sleeptime="$OPTARG"              ;;
	W) wait_for_secrets=0		    ;;
	x) affinity=1			    ;;
	X) affinity=2			    ;;
	Y) syncStart=$((1-syncStart))	    ;;
	z) podsleeptime="$OPTARG"	    ;;
	-) process_option "$OPTARG"	    ;;
	*) help "$OPTARG"                   ;;
    esac
done
[[ -n "${unknown_opts[*]:-}" ]] && help "${unknown_opts[@]}"

if (( namespaces <= 0 )) ; then
    namespaces=1
    useNamespaces=
fi
(( !parallelConfigMaps )) && parallelConfigMaps=$parallel
(( !parallelSecrets )) && parallelSecrets=$parallel
(( !parallelNamespaces )) && parallelNamespaces=$parallel
(( !parallelDeployments )) && parallelDeployments=$parallel

(( !blocksizeConfigMaps )) && blocksizeConfigMaps=$blocksize
(( !blocksizeSecrets )) && blocksizeSecrets=$blocksize
(( !blocksizeNamespaces )) && blocksizeNamespaces=$blocksize
(( !blocksizeDeployments )) && blocksizeDeployments=$blocksize

[[ -n $runtimeClass ]] && runtimeClass="runtimeClassName: \"$runtimeClass\""
[[ -n "$report_format" ]] && report=1

shift $((OPTIND - 1))

if [[ -z $OC && $doit -gt 0 ]] ; then
    fatal "Cannot find oc or kubectl command, exiting!"
fi

if (( msgSize <= 0 )) ; then
    fatal "Message size must be positive, exiting!"
fi

if [[ -z "$pbenchControllerAddress" && $pbenchControllerPort -ne 0 ]] ; then
    fatal "Both pbench_controller_address and pbench_controller_port must be specified"
fi

if [[ -n "$pbenchControllerAddress" && $pbenchControllerPort -eq 0 ]] ; then
    fatal "Both pbench_controller_address and pbench_controller_port must be specified"
fi

for ftest in ${sysbench_fileio_test_string//,/ } ; do
    sysbench_fileio_tests[$ftest]=1
done

function validate_resource() {
    local rtype=$1
    local token
    local status=0
    shift
    for token in "$@" ; do
	if [[ $token != *'='* ]] ; then
	    warn "Invalid $rtype specification $token (must be <resource>=<quantity>)"
	    status=1
	fi
    done
    return $status
}

resource_validation_failed=0
validate_resource resource_request "${resource_requests[@]}" || resource_validation_failed=1
validate_resource resource_limit "${resource_limits[@]}" || resource_validation_failed=1
if ((resource_validation_failed)) ; then
    exit 1
fi

if (( file_block_size <= 0)) ; then
    file_block_size=file_size
fi

for i in $(seq 0 $((file_volumes-1)) ) ; do
    emptydirs+=("/mnt/volume-$i")
done

logStrategy=${logStrategy,,}
if [[ $logStrategy != poll && $logStrategy != listen ]] ; then
    fatal "Unknown --log_stragey (must be 'poll' or 'listen')"
fi

if [[ $dataRate != 0 && $dataRate != '' && $xferTimeMax -eq 0 && bytesMax -eq 0 ]] ; then
    bytes=$defaultBytes
    bytesMax=$defaultBytes
fi

case "${podType,,}" in
    classic|clusterbuster) podType=ClusterBuster ;;
    server)                podType=Server        ;;
    cpu*|soaker)           podType=CPUSoaker     ;;
    sysbench)              podType=Sysbench      ;;
    fio)		   podType=Fio           ;;
    pause|pausepod)        podType=PausePod      ;;
    file|files)            podType=Files         ;;
    log|logger|logging)    podType=Log           ;;
    *)
	help_extended "(Unknown pod type '$podType')"
	;;
esac

if [[ -n ${1:-} ]] ; then
    basename="$1"
    shift
fi

[[ -z "$*" ]] || echo "Warning: extraneous arguments $# after basename will be ignored!" 1>&2

function __OC() {
    if [[ $1 = describe || $1 = get || $1 = status ]] ; then
	"$OC" "$@"
    elif ((reportObjectCreation)) ; then
	"$OC" "$@" 2>&1
    else
	"$OC" "$@" 2>&1 |grep -v -E '(^No resources found|deleted|created|labeled)$'
    fi
    return "${PIPESTATUS[0]}"
}

function _OC() {
    if ! __OC "$@" ; then
	echo "__KUBEFAIL__ $OC $* failed!"
	exit 1
    fi
}

function indent_1() {
    local -i column="$1"
    local line
    while IFS='' read -r 'line' ; do
	[[ -z "$line" ]] || printf "%${column}s%s\n" ' ' "$line"
    done
}

function indent() {
    local -i column="$1"
    shift
    if [[ -n "$*" ]] ; then
	# "$@" | indent_1 "$column" strips whitespace with bash 4.2
	indent_1 "$column" < <("$@")
    else
	indent_1 "$column"
    fi
}

function finishCreation() {
    if [[ $doit -ne 0 && -n $accumulateddata ]] ; then
	(_OC ${KUBECTL_VALIDATE} apply -f - <<< "$accumulateddata" | timestamp 1>&2) || exit 1
	accumulateddata=
    fi
}

function node_selector() {
    if [[ -n "$nodeSelector" ]] ; then
	cat <<EOF
nodeSelector:
  $nodeSelector: ""
EOF
    fi
}

function createResources() {
    local token
    for token in "$@" ; do
	local resource=${token%%=*}
	local value=${token#*=}
	echo "$resource: $value"
    done
}

function createTolerations() {
    local toleration
    (( ${#tolerations[@]} )) || return
    echo "tolerations:"
    for toleration in "${tolerations[@]}" ; do
	# shellcheck disable=SC2206
	local -a tol=(${toleration//:/ })
	cat <<EOF
- key: "${tol[0]:-}"
  operator: "${tol[1]:-}"
  effect: "${tol[2]:-}"
EOF
    done
}

function createContainerResources() {
    if (( ${#resource_limits[@]} + ${#resource_requests[@]} )) ; then
	echo "resources:"
	if (( ${#resource_limits[@]} )) ; then
	    echo "  limits:"
	    indent 4 createResources "${resource_limits[@]}"
	fi
	if (( ${#resource_requests[@]} )) ; then
	    echo "  requests:"
	    indent 4 createResources "${resource_requests[@]}"
	fi
    fi
}

function createObject() {
    local data=
    local line=
    while IFS='' read -r 'line' ; do
	if [[ -n $line ]] ; then
	    [[ -n $data ]] || data="---$nl"
	    data+="$line$nl"
	fi
    done
    data+="$nl"
    if (( doit )) ; then
	accumulateddata+="$data"
	if (( ++blockitemcount >= blocksize )) ; then
	    (_OC ${KUBECTL_VALIDATE} apply -f - <<< "$accumulateddata" | timestamp 1>&2) || exit 1
	    accumulateddata=
	    blockitemcount=0
	    (( !sleeptime )) || sleep "$sleeptime"
	fi
    else
	IFS= echo "$data"
    fi
}

function echoIfDesired() {
    if (( reportObjectCreation )) ; then
	cat
    else
	cat >/dev/null
    fi
}

function createObjectFromFile() {
    local objtype=$1; shift
    local namespace=$1; shift
    local objname=$1; shift
    local file
    for file in "$@" ; do
	if [[ ! -r "$file" ]] ; then
	    echo "Can't read file $file!"
	    exit 1
	fi
    done
    if (( doit )) ; then
	(_OC create ${useNamespaces:+-n "$namespace"} "$objtype" "$objname" "${@/#/--from-file=}" | echoIfDesired 1>&2) || exit 1
	(_OC label ${useNamespaces:+-n "$namespace"} "$objtype" "$objname" 'clusterbusterbase=true' "${basename}=true" | echoIfDesired 1>&2) || exit 1
	totalObjectsCreated=$((totalObjectsCreated+1))
	if [[ -z ${objectsCreated[$objtype]:-} ]] ; then
	    objectsCreated[$objtype]=1
	else
	    objectsCreated[$objtype]=$((${objectsCreated[$objtype]}+1))
	fi
	(( !sleeptime )) || sleep "$sleeptime"
    else
	echo _OC create ${useNamespaces:+-n "$namespace"} "$objtype" "$objname" "${@/#/--from-file=}"
	echo _OC label ${useNamespaces:+-n "$namespace"} "$objtype" "$objname" 'clusterbusterbase=true' "${basename}=true" || exit 1
    fi
}

function createNamespace() {
    local namespace=$1
    [[ -z "$useNamespaces" ]] && return
    createObject <<EOF
apiVersion: v1
kind: Namespace
metadata:
  name: "${namespace}"
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
EOF
}

function createSecrets() {
    local namespace=$1
    local depsPerNamespace=${2:-1}
    local secrets=${3:-1}
    local -i i
    local -i j
    local nsline=${useNamespaces:+  namespace: "$namespace"}
    (( secrets )) || return;
    for i in $(seq $firstDeployment $((depsPerNamespace + firstDeployment - 1))) ; do
	for j in $(seq 0 $((secrets - 1))) ; do
	    createObject <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: "secret-${namespace}-${i}-${j}"
$nsline
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
data:
  key1: "$(base64 <<< "${namespace}X${i}Y${j}Z1")"
  key2: "$(base64 <<< "${namespace}X${i}Y${j}Z2")"
type: Opaque
EOF
	done
    done
}

function createConfigMaps() {
    local namespace=$1; shift
    local mapname=$1; shift
    (( $# )) || return;
    createObjectFromFile configmap "$namespace" "${mapname}-${namespace}" "$@"
}

function genericCommand() {
    local command=$1
    cat <<EOF
command:
- bootstrap.sh
args:
- "$systemConfigmapMountDir/$command"
EOF
}

function createVolumeMountsYAML() {
    local namespace=$1
    local deployment=${2:-1}
    local secrets=${3:-1}
    (( secrets + ${#emptydirs[@]} + ${#configMapFiles[@]} + ${#volumes[@]} + hasSystemConfigMap )) || return;
    local -i i
    echo volumeMounts:
    for i in $(seq 0 $((secrets - 1))) ; do
	local name="secret-${namespace}-${deployment}-$i"
	cat <<EOF
- name: $name
  mountPath: /etc/$name
  readOnly: true
EOF
    done
    if [[ -n "${emptydirs[*]:-}" ]] ; then
	local vol
	for vol in "${emptydirs[@]}" ; do
	    cat <<EOF
- name: ${vol##*/}
  mountPath: "$vol"
EOF
	done
    fi
    if [[ -n "${configMapFiles[*]:-}" ]] ; then
	cat <<EOF
- name: "configmap-${namespace}"
  mountPath: "${configmapMountDir}"
  readOnly: true
EOF
    fi
    if [[ -n "${volumes[*]:-}" ]] ; then
	local vol
	for vol in "${volumes[@]:-}" ; do
	    cat <<EOF
- name: "$vol"
  mountPath: "${volume_mount_paths[$vol]}"
EOF
	done
    fi
    if (( hasSystemConfigMap )) ; then
	cat <<EOF
- name: "systemconfigmap-${namespace}"
  mountPath: "${systemConfigmapMountDir}"
  readOnly: true
EOF
    fi
}

function createPbenchAgentYAML() {
    if (( pbenchControllerPort > 0 )) ; then
	# This isn't ideal, as there still can be collisions.
	# Without a port server, this is certainly the most
	# expeditious.
	local sshPort=0
	while (( sshPort < 2023 )) ; do
	    sshPort=$RANDOM
	done
	cat <<EOF
- name: "pbench-agent"
  image: "$containerImage"
  imagePullPolicy: $imagePullPolicy
  securityContext:
    privileged: false
    capabilities:
      add:
      - AUDIT_WRITE
  env:
  - name: VERBOSE
    value: "0"
  command:
  - "/usr/local/bin/run-pbench-agent-container"
  args:
  - "$pbenchControllerPort"
  - "$pbenchControllerAddress"
#hostPID: true
serviceAccount: pbench
EOF
    fi
}

function createPrivilegeYAML() {
    if (( pbenchControllerPort > 0)) ; then
	cat <<EOF
openshift.io/scc: privileged
EOF
    fi
}

function createVolumesYAML() {
    local namespace=$1
    local deployment=${2:-1}
    local secrets=${3:-1}
    (( secrets + ${#emptydirs[@]} + ${#configMapFiles[@]} + ${#volumes[@]} + hasSystemConfigMap )) || return;
    local -i i
    echo "volumes:"
    for i in $(seq 0 $((secrets - 1))) ; do
	local name="secret-${namespace}-${deployment}-$i"
	cat<<EOF
- name: $name
  secret:
    secretName: $name
EOF
    done

    if [[ -n "${emptydirs[*]:-}" ]] ; then
	local vol
	for vol in "${emptydirs[@]}" ; do
	    cat <<EOF
- name: ${vol##*/}
  emptydDir: {}
EOF
	done
    fi
    if [[ -n "${configMapFiles[*]:-}" ]] ; then
	cat <<EOF
- name: "configmap-${namespace}"
  configMap:
    name: "configmap-${namespace}"
EOF
    fi
    if [[ -n "${volumes[*]:-}" ]] ; then
	local vol
	for vol in "${volumes[@]:-}" ; do
	    cat <<EOF
- name: "$vol"
EOF
	    if [[ -n "${volume_type_keys[$vol]}" ]] ; then
		cat <<EOF
  ${volume_types[$vol]}:
    ${volume_type_keys[$vol]}: "${volume_scoped_names[$vol]}"
EOF
	    else
		cat <<EOF
  ${volume_types[$vol]}: {}
EOF
	    fi
	done
    fi
    if (( hasSystemConfigMap )) ; then
	cat <<EOF
- name: "systemconfigmap-${namespace}"
  configMap:
    name: "systemconfigmap-${namespace}"
EOF
    fi
}

function createSyncYAML() {
    local syncCount=${1:-1}
    local namespace=$2
    local expectedClients=$3
    cat <<EOF
- name: ${namespace}-sync
  imagePullPolicy: $imagePullPolicy
  image: "$containerImage"
  ports:
  - containerPort: $port
$(indent 2 genericCommand sync.pl)
  - "-f"
  - "$syncFlagFile"
  - "$syncPort"
  - "$expectedClients"
  - "$syncCount"
$(indent 2 createVolumeMountsYAML "$namespace" 0 0)
EOF
}

function createSyncSpec() {
    cat <<EOF
spec:
$(indent 2 node_selector)
  terminationGracePeriodSeconds: 1
$(indent 2 createTolerations ${tolerations+"${tolerations[@]}"})
$(indent 2 <<< "$runtimeClass")
  containers:
$(indent 2 createSyncYAML "$@")
$(indent 2 createVolumesYAML "$namespace" 0 0)
EOF
}


function createSyncDeployment() {
    local syncCount=$1; shift
    local nsline=${useNamespaces:+  namespace: "$namespace"}
    if [[ $deploymentType = pod ]] ; then
	createObject <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${namespace}-sync
$nsline
$(indent 2 createPrivilegeYAML)
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-sync
  labels:
    ${basename}-id: "$runUUID"
    name: ${namespace}-sync
    app: ${namespace}-sync
    k8s-app: ${namespace}-sync
    ${basename}: "true"
    ${basename}-sync: "true"
    clusterbusterbase: "true"
$(createSyncSpec "$syncCount" "$@")
  restartPolicy: Never
EOF
    else
	createObject <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-sync
$(indent 2 createPrivilegeYAML)
$nsline
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  replicas: 1
  strategy:
    type: RollingUpdate
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-sync
  template:
    metadata:
      labels:
        ${basename}-id: "$runUUID"
        name: ${namespace}-sync
        app: ${namespace}-sync
        k8s-app: ${namespace}-sync
        ${basename}: "true"
        ${basename}-sync: "true"
        clusterbusterbase: "true"
$(indent 4 createSyncSpec -1 "$@")
EOF
    fi
}

function createService() {
    local namespace=$1
    local deployment=$2
    local portnum=$3
    local nsline=${useNamespaces:+  namespace: "$namespace"}
    createObject <<EOF
apiVersion: v1
kind: Service
metadata:
  name: "service-${deployment}"
$nsline
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  ports:
  - port: $portnum
    targetPort: $portnum
  selector:
    name: "${deployment}"
EOF
}

function createRoute() {
    local namespace=$1
    local deployment=$2
    local nsline=${useNamespaces:+  namespace: "$namespace"}
    createObject <<EOF
apiVersion: v1
kind: Route
metadata:
  name: "route-${deployment}"
$nsline
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  host: "service-${deployment}"
  to:
    kind: Service
    name: "service-${deployment}"
  selector:
    name: "${deployment}"
EOF
}

################################################################
# WORKLOADS ####################################################
################################################################

################################################################
# Simple workloads (pause pod, clusterbuster, logging)
################################################################

function createContainersClusterBusterYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i pods=$4
    local -i containers=$5
    local -i j
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: ${namespace}-$i-$j
  imagePullPolicy: $imagePullPolicy
  image: "busybox"
$(indent 2 createContainerResources)
  command:
  - /bin/sh
  args:
  - -c
  - |
    trap 'exit 0' TERM
    (while : ; do date ; sleep 60 ; done)&
    sleep $podsleeptime
    exit 1
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createContainersPausePodYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i pods=$4
    local -i containers=$5
    local -i j
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: ${namespace}-$i-$j
  imagePullPolicy: $imagePullPolicy
  image: "gcr.io/google_containers/pause-amd64:3.0"
$(indent 2 createContainerResources)
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createContainersLogYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    # shellcheck disable=2034
    local -i pods=$4
    local -i containers=$5
    local -i j
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: ${namespace}-$i-$j
  imagePullPolicy: $imagePullPolicy
  image: "$containerImage"
$(indent 2 createContainerResources)
  env:
  - name: VERBOSE
    value: "$verbose"
$(indent 2 genericCommand logger.pl)
  - "$namespace"
  - "${namespace}-sysbench-${i}"
  - "c${j}"
  - "$log_bytes_per_line"
  - "$log_bytes_per_io"
  - "$log_xfer_count"
  - "$log_processes"
  - "$log_delay_usec"
  - "$log_xfertime"
  - "$log_exit_at_end"
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function listConfigMapsLog() {
    cat <<EOF
${__libdir__}/logger.pl
EOF
}

function createClassicSpec() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i replicas=$4
    local -i containers=$5
cat <<EOF
spec:
$(indent 2 node_selector)
  terminationGracePeriodSeconds: 1
$(indent 2 <<< "$runtimeClass")
  containers:
$(indent 2 createContainers${podType}YAML "$@")
$(indent 2 createPbenchAgentYAML)
$(indent 2 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

function createDeploymentClassicYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i replicas=$4
    local -i containers=$5
    local nsline=${useNamespaces:+  namespace: "$namespace"}
    if [[ $deploymentType = pod ]] ; then
	local -i j=0
	while (( j++ < replicas )) ; do
	    createObject <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${namespace}-${i}-${j}
$nsline
$(indent 2 createPrivilegeYAML)
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-${i}
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    name: ${namespace}-${i}
    app: ${namespace}-${i}
    ${basename}: "true"
    ${basename}-client: "true"
    clusterbusterbase: "true"
$(createClassicSpec "$@")
EOF
	done
    else
	createObject <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-$i
$nsline
$(indent 2 createPrivilegeYAML)
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  replicas: $replicas
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-$i
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        ${basename}-id: "$runUUID"
        ${basename}: "true"
        clusterbusterbase: "true"
        name: ${namespace}-$i
        app: ${namespace}-$i
$(indent 4 createClassicSpec "$@")
EOF
    fi
}

function createDeploymentSimple() {
    local namespace=$1
    local count=${2:-1}
    local secretCount=${3:-1}
    local replicas=${4:-1}
    local containers=${5:-1}
    local -i i
    for i in $(seq $firstDeployment $((count + firstDeployment - 1))) ; do
	createDeploymentClassicYAML "$namespace" "$i" "$secretCount"  "$replicas" "$containers"
    done
}

function createDeploymentPausePod() {
    createDeploymentSimple "$@"
}

function createDeploymentClusterBuster() {
    createDeploymentSimple "$@"
}

function createDeploymentLog() {
    createDeploymentSimple "$@"
}

################################################################
# Client/server workload
################################################################

function createServerContainerYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local msgSize=$4
    local expectedClients=$5
    cat <<EOF
- name: server
  image: "$containerImage"
  imagePullPolicy: $imagePullPolicy
$(indent 2 createContainerResources)
  ports:
  - containerPort: $port
$(indent 2 genericCommand server.pl)
  - "$basetime"
  - "$baseoffset"
  - "$port"
  - "${namespace}-${i}-server"
  - "$msgSize"
  - "$(ts)"
  - "$expectedClients"
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
}

function createServerSpec() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local msgSize=$4
    local expectedClients=$5
    cat <<EOF
spec:
$(indent 2 node_selector)
  terminationGracePeriodSeconds: 1
$(indent 2 <<< "$runtimeClass")
  containers:
$(indent 2 createServerContainerYAML "$@")
$(indent 2 createPbenchAgentYAML)
$(indent 2 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

function createServerDeployment() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local msgSize=$4
    local expectedClients=$5
    local nsline=${useNamespaces:+  namespace: "$namespace"}
    if [[ $deploymentType = pod ]] ; then
	createObject <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${namespace}-${i}-server
$nsline
$(indent 2 node_selector)
$(indent 2 createPrivilegeYAML)
  selector:
    matchLabels:
      app: ${namespace}-${i}
  labels:
    ${basename}-id: "$runUUID"
    name: ${namespace}-${i}
    app: ${namespace}-${i}
    k8s-app: ${namespace}-${i}-server
    ${basename}: "true"
    ${basename}-server: "true"
    clusterbusterbase: "true"
$(createServerSpec "$@")
  restartPolicy: Never
EOF
    else
	createObject <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-${i}-server
$nsline
$(indent 2 createPrivilegeYAML)
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  replicas: 1
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-$i
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        ${basename}-id: "$runUUID"
        name: ${namespace}-${i}
        app: ${namespace}-${i}
        k8s-app: ${namespace}-${i}-server
        ${basename}: "true"
        ${basename}-server: "true"
        clusterbusterbase: "true"
$(indent 4 createServerSpec "$@")
EOF
    fi
}

function createClientContainerYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local dataRate=$4
    local bytes=$5
    local msgSize=$6
    local containers=$7
    local log_host=$8
    local log_port=$9
    local podname=${10}
    local replica=${11}
    local -i j
    local syncService=
    local syncPortNum=
    if (( syncStart )) ; then
	syncService="${syncHost:-service-${namespace}-sync}"
	syncPortNum=$syncPort
    fi
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: c${j}
  image: "$containerImage"
  imagePullPolicy: $imagePullPolicy
$(indent 2 createContainerResources)
  env:
  - name: VERBOSE
    value: "$verbose"
$(indent 2 genericCommand client.pl)
  - "$namespace"
  - "${namespace}-${i}-client-$replica"
  - "$j"
  - "$basetime"
  - "$baseoffset"
  - "$poddelay"
  - "$port"
  - "c${j}"
  - "service-${namespace}-$i"
  - "$dataRate"
  - "$bytes"
  - "$bytesMax"
  - "$msgSize"
  - "$xferTime"
  - "$xferTimeMax"
  - "$(ts)"
  - "$exitAtEnd"
  - "$syncService"
  - "$syncPortNum"
  - "$namespace"
  - "$log_host"
  - "$log_port"
  - "$podname"
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createClientAffinityYAML() {
    (( affinity )) || return 0
    local server=$1
    local affinityType
    case "$affinity" in
	1) affinityType=Affinity     ;;
	*) affinityType=AntiAffinity ;;
    esac
    cat << EOF
affinity:
  pod$affinityType:
    requiredDuringSchedulingIgnoredDuringExecution:
    - labelSelector:
        matchExpressions:
        - key: k8s-app
          operator: In
          values:
          - "$server"
      topologyKey: kubernetes.io/hostname
EOF
}

function createClientSpec() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local replicas=$4
    local dataRate=$5
    local bytes=$6
    local msgSize=$7
    local containers=$8
    local log_host=${9:-}
    local -i log_port=${10:-0}
    local podname=${11}
    local replica=${12}
    cat <<EOF
spec:
$(indent 2 node_selector)
  terminationGracePeriodSeconds: 1
$(indent 2 createClientAffinityYAML "${namespace}-${i}-server")
$(indent 2 <<< "$runtimeClass")
  containers:
$(indent 2 createClientContainerYAML "$namespace" "$i" "$secretCount" "$dataRate" "$bytes" "$msgSize" "$containers" "$log_host" "$log_port" "$podname" "$replica")
$(indent 2 createPbenchAgentYAML)
$(indent 2 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

function createClientDeployment() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local replicas=$4
    local dataRate=$5
    local bytes=$6
    local msgSize=$7
    local containers=$8
    local log_host=${9:-}
    local -i log_port=${10:-0}
    local nsline=${useNamespaces:+  namespace: "$namespace"}
    if [[ $deploymentType = pod ]] ; then
	local -i j=0
	while (( j++ < replicas )) ; do
	    local podname="${namespace}-${i}-client-${j}"
	    createObject <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: $podname
$nsline
$(indent 2 createPrivilegeYAML)
$(indent 2 node_selector)
$(indent 2 createPrivilegeYAML)
  selector:
    matchLabels:
      app: ${namespace}-${i}-client
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    name: ${namespace}-${i}-client
    app: ${namespace}-${i}-client
    ${basename}: "true"
    ${basename}-client: "true"
    clusterbusterbase: "true"
$(createClientSpec "$@" "$podname" "$j")
  restartPolicy: Never
EOF
	done
    else
	local podname="${namespace}-${i}-client"
	createObject <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: $podname
$(indent 2 createPrivilegeYAML)
$nsline
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  replicas: $replicas
$(indent 2 node_selector)
  restartPolicy: Always
  selector:
    matchLabels:
      app: ${namespace}-${i}-client
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        ${basename}-id: "$runUUID"
        name: ${namespace}-${i}-client
        app: ${namespace}-${i}-client
        ${basename}: "true"
        ${basename}-client: "true"
        clusterbusterbase: "true"
$(indent 4 createClientSpec "$@" "$podname" "x")
EOF
    fi
}

function createDeploymentServer() {
    local namespace=$1
    local count=${2:-1}
    local secretCount=${3:-1}
    local replicas=${4:-1}
    local containers=${5:-1}
    local log_host=${6:-}
    local -i log_port=${7:-0}
    local -i i
    if [[ syncStart -gt 0 && -z "$syncHost" ]] ; then
	createService "$namespace" "${namespace}-sync" "$syncPort"
	createSyncDeployment 2 "$namespace" "$((containers * replicas * count))"
    fi

    for i in $(seq $firstDeployment $((count + firstDeployment - 1))) ; do
	createService "$namespace" "$namespace-$i" "$port"
	(( createRoutes )) && createRoute "$namespace" "$namespace-$i"
	if [[ $deploymentType = pod ]] ; then
	    createServerDeployment "$namespace" "$i" "$secretCount" "$msgSize" "$((containers * replicas))"
	else
	    createServerDeployment "$namespace" "$i" "$secretCount" "$msgSize" "-1"
	fi
	createClientDeployment "$namespace" "$i" "$secretCount" "$replicas" "$dataRate" "$bytes" "$msgSize" "$containers" "$log_host" "$log_port"
    done
}

function listConfigMapsServer() {
    cat <<EOF
${__libdir__}/client.pl
${__libdir__}/server.pl
${__libdir__}/sync.pl
EOF
}

function calculateLogsRequiredServer() {
    local -i namespaces=$1
    local -i depsPerNamespace=${2:-1}
    local -i replicas=${3:-1}
    local -i containers=${4:-1}
    echo $((namespaces * containers * replicas * depsPerNamespace))
}

################################################################
# Files workload
################################################################

function createContainersFilesYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i replicas=$4
    local -i containers=$5
    local log_host=${6:-}
    local -i log_port=${7:-0}
    local -i j
    local syncService=
    local syncPortNum=
    local -i file_blocks=$((file_size/file_block_size))
    if (( syncStart )) ; then
	syncService="${syncHost:-service-${namespace}-sync}"
	syncPortNum=$syncPort
    fi
    # shellcheck disable=1340
    for j in $(seq 0 $((containers - 1))) ; do
	# shellcheck disable=2030
	cat <<EOF
- name: "c${j}"
  imagePullPolicy: $imagePullPolicy
  image: "$containerImage"
$(indent 2 createContainerResources)
  env:
  - name: VERBOSE
    value: "$verbose"
$(indent 2 genericCommand files.pl)
  - "$namespace"
  - "${namespace}-files-${i}"
  - "c${j}"
  - "$basetime"
  - "$baseoffset"
  - "$(ts)"
  - "$poddelay"
  - "$podsleeptime"
  - "$syncService"
  - "$syncPortNum"
  - "$file_dirs_per_volume"
  - "$files_per_dir"
  - "$file_block_size"
  - "$file_blocks"
  - "$processes_per_pod"
  - "$log_host"
  - "$log_port"
$(tmp_volume_paths=("${volume_mount_paths[@]/%/\"}"); IFS=$'\n'; echo "${tmp_volume_paths[*]/#/  - \"}")
$(emptydirs=("${emptydirs[@]/%/\"}"); IFS=$'\n'; echo "${emptydirs[*]/#/  - \"}")
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createFilesSpec() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i processes=$4
    local -i containers=$5
    cat <<EOF
spec:
$(indent 2 node_selector)
  terminationGracePeriodSeconds: 1
$(indent 2 <<< "$runtimeClass")
  containers:
$(indent 2 createContainersFilesYAML "$@")
$(indent 2 createPbenchAgentYAML)
$(indent 2 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

function createFilesDeployment() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i replicas=$4
    local -i containers=$5
    local nsline=${useNamespaces:+  namespace: "$namespace"}
    local podname="${namespace}-${i}-files"
    if [[ $deploymentType = pod ]] ; then
	local -i j=0
	while (( j++ < replicas )) ; do
	    createObject <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${namespace}-files-${i}-${j}
$nsline
$(indent 2 createPrivilegeYAML)
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-files-${i}
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
    name: ${namespace}-files-${i}
    app: ${namespace}-files-${i}
    ${basename}-files: "true"
    ${basename}-client: "true"
$(createFilesSpec "$@")
  restartPolicy: Never
EOF
	done
    else
	createObject <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-files-$i
$nsline
$(indent 2 createPrivilegeYAML)
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  replicas: $replicas
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-$i
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        ${basename}-id: "$runUUID"
        ${basename}: "true"
        clusterbusterbase: "true"
        name: ${namespace}-files-$i
        app: ${namespace}-files-$i
        ${basename}-files: "true"
        ${basename}-client: "true"
$(indent 4 createFilesSpec "$@")
EOF
    fi
}

function calculateLogsRequiredFiles() {
    local -i namespaces=$1
    local -i depsPerNamespace=${2:-1}
    local -i replicas=${3:-1}
    local -i containers=${4:-1}
    echo $((namespaces * containers * processes_per_pod * replicas * depsPerNamespace))
}

function createDeploymentFiles() {
    local namespace=$1
    local count=${2:-1}
    local secretCount=${3:-1}
    local replicas=${4:-1}
    local containers=${5:-1}
    local -i i
    if [[ syncStart -gt 0 && -z "$syncHost" ]] ; then
	createService "$namespace" "${namespace}-sync" "$syncPort"
	createSyncDeployment 4 "$namespace" "$((containers * processes_per_pod * replicas * count))"
    fi
    for i in $(seq $firstDeployment $((count + firstDeployment - 1))) ; do
	createFilesDeployment "$namespace" "$i" "$secretCount"  "$replicas" "$containers" "$log_host" "$log_port"
    done
}

function listConfigMapsFiles() {
    cat <<EOF
${__libdir__}/files.pl
${__libdir__}/sync.pl
EOF
}

################################################################
# FIO workload
################################################################

function createContainersFioYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i processes=$4
    local -i containers=$5
    local log_host=${6:-}
    local -i log_port=${7:-0}
    local -i j
    local syncService=
    local syncPortNum=
    if (( syncStart )) ; then
	syncService="${syncHost:-service-${namespace}-sync}"
	syncPortNum=$syncPort
    fi
    # shellcheck disable=2031
    local workdir=${common_workdir:-${emptydirs[0]:-/tmp}}
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: "c${j}"
  imagePullPolicy: $imagePullPolicy
  image: "$containerImage"
$(indent 2 createContainerResources)
  env:
  - name: VERBOSE
    value: "$verbose"
$(indent 2 genericCommand fio.pl)
  - "$namespace"
  - "${namespace}-fio-${i}"
  - "c${j}"
  - "$basetime"
  - "$baseoffset"
  - "$(ts)"
  - "$poddelay"
  - "$processes"
  - "$workdir"
  - "$xferTime"
  - "$exitAtEnd"
  - "$syncService"
  - "$syncPortNum"
  - "$log_host"
  - "$log_port"
  - "$configmapMountDir"
  - "${fio_generic_options[*]:-}"
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createFioSpec() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i processes=$4
    local -i containers=$5
    cat <<EOF
spec:
$(indent 2 node_selector)
  terminationGracePeriodSeconds: 1
$(indent 2 <<< "$runtimeClass")
  containers:
$(indent 2 createContainersFioYAML "$@")
$(indent 2 createPbenchAgentYAML)
$(indent 2 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

function createFioDeployment() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i processes=$4
    local -i containers=$5
    local nsline=${useNamespaces:+  namespace: "$namespace"}
    if [[ $deploymentType = pod ]] ; then
	createObject <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${namespace}-fio-${i}
$nsline
$(indent 2 createPrivilegeYAML)
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-fio-${i}
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
    name: ${namespace}-fio-${i}
    app: ${namespace}-fio-${i}
    ${basename}-fio: "true"
    ${basename}-client: "true"
$(createFioSpec "$@")
  restartPolicy: Never
EOF
    else
	createObject <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-fio-$i
$nsline
$(indent 2 createPrivilegeYAML)
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  replicas: 1
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-fio-$i
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        ${basename}-id: "$runUUID"
        ${basename}: "true"
        clusterbusterbase: "true"
        name: ${namespace}-fio-$i
        app: ${namespace}-fio-$i
        ${basename}-fio: "true"
        ${basename}-client: "true"
$(indent 4 createFioSpec "$@")
EOF
    fi
}
function calculateLogsRequiredFio() {
    local -i namespaces=$1
    local -i depsPerNamespace=${2:-1}
    local -i replicas=${3:-1}
    local -i containers=${4:-1}
    echo $((namespaces * containers * processes_per_pod * replicas * depsPerNamespace))
}

function createDeploymentFio() {
    local namespace=$1
    local count=${2:-1}
    local secretCount=${3:-1}
    local replicas=${4:-1}
    local containers=${5:-1}
    local log_host=${6:-}
    local -i log_port=${7:-0}
    local -i i
    if [[ syncStart -gt 0 && -z "$syncHost" ]] ; then
	createService "$namespace" "${namespace}-sync" "$syncPort"
	createSyncDeployment 2 "$namespace" "$((containers * replicas * count))"
    fi
    for i in $(seq $firstDeployment $((count + firstDeployment - 1))) ; do
	createFioDeployment "$namespace" "$i" "$secretCount"  "$replicas" "$containers" "$log_host" "$log_port"
    done
}

function listConfigMapsFio() {
    cat <<EOF
${__libdir__}/fio.pl
${__libdir__}/sync.pl
EOF
}

################################################################
# Sysbench workload
################################################################

function createContainersSysbenchYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i processes=$4
    local -i containers=$5
    local log_host=${6:-}
    local -i log_port=${7:-0}
    local -i j
    local syncService=
    local syncPortNum=
    if (( syncStart )) ; then
	syncService="${syncHost:-service-${namespace}-sync}"
	syncPortNum=$syncPort
    fi
    # shellcheck disable=2031
    local workdir=${common_workdir:-${emptydirs[0]:-/tmp}}
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: "c${j}"
  imagePullPolicy: $imagePullPolicy
  image: "$containerImage"
$(indent 2 createContainerResources)
  env:
  - name: VERBOSE
    value: "$verbose"
$(indent 2 genericCommand sysbench.pl)
  - "$namespace"
  - "${namespace}-sysbench-${i}"
  - "c${j}"
  - "$basetime"
  - "$baseoffset"
  - "$(ts)"
  - "$poddelay"
  - "$processes"
  - "$workdir"
  - "$xferTime"
  - "$exitAtEnd"
  - "$syncService"
  - "$syncPortNum"
  - "$log_host"
  - "$log_port"
  - "${sysbench_generic_options[*]:-}"
  - "fileio"
  - "${sysbench_fileio_options[*]:-}"
  - "${!sysbench_fileio_tests[*]}"
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createSysbenchSpec() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i processes=$4
    local -i containers=$5
    cat <<EOF
spec:
$(indent 2 node_selector)
  terminationGracePeriodSeconds: 1
$(indent 2 <<< "$runtimeClass")
  containers:
$(indent 2 createContainersSysbenchYAML "$@")
$(indent 2 createPbenchAgentYAML)
$(indent 2 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

function createSysbenchDeployment() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i processes=$4
    local -i containers=$5
    local nsline=${useNamespaces:+  namespace: "$namespace"}
    if [[ $deploymentType = pod ]] ; then
	createObject <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${namespace}-sysbench-${i}
$nsline
$(indent 2 createPrivilegeYAML)
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-sysbench-${i}
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
    name: ${namespace}-sysbench-${i}
    app: ${namespace}-sysbench-${i}
    ${basename}-sysbench: "true"
    ${basename}-client: "true"
$(createSysbenchSpec "$@")
  restartPolicy: Never
EOF
    else
	createObject <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-sysbench-$i
$nsline
$(indent 2 createPrivilegeYAML)
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  replicas: 1
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-sysbench-$i
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        ${basename}-id: "$runUUID"
        ${basename}: "true"
        clusterbusterbase: "true"
        name: ${namespace}-sysbench-$i
        app: ${namespace}-sysbench-$i
        ${basename}-sysbench: "true"
        ${basename}-client: "true"
$(indent 4 createSysbenchSpec "$@")
EOF
    fi
}

function createDeploymentSysbench() {
    local namespace=$1
    local count=${2:-1}
    local secretCount=${3:-1}
    local replicas=${4:-1}
    local containers=${5:-1}
    local log_host=${6:-}
    local -i log_port=${7:-0}
    local -i i
    if [[ syncStart -gt 0 && -z "$syncHost" ]] ; then
	createService "$namespace" "${namespace}-sync" "$syncPort"
	createSyncDeployment $(( (${#sysbench_fileio_tests[@]} * 3) + 1)) "$namespace" "$((containers * replicas * count))"
    fi
    for i in $(seq $firstDeployment $((count + firstDeployment - 1))) ; do
	createSysbenchDeployment "$namespace" "$i" "$secretCount"  "$replicas" "$containers" "$log_host" "$log_port"
    done
}

function listConfigMapsSysbench() {
    cat <<EOF
${__libdir__}/sysbench.pl
${__libdir__}/sync.pl
EOF
}

function calculateLogsRequiredSysbench() {
    local -i namespaces=$1
    local -i depsPerNamespace=${2:-1}
    local -i replicas=${3:-1}
    local -i containers=${4:-1}
    echo $((namespaces * containers * processes_per_pod * replicas * depsPerNamespace))
}

################################################################
# CPU soaker workload
################################################################

function createContainersCPUSoakerYAML() {
    local podname=$1
    local namespace=$2
    local i=$3
    local secretCount=$4
    local -i processes=$5
    local -i containers=$6
    local log_host=${7:-}
    local -i log_port=${8:-0}
    local -i j
    local syncService=
    local syncPortNum=
    if (( syncStart )) ; then
	syncService="${syncHost:-service-${namespace}-sync}"
	syncPortNum=$syncPort
    fi
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: "c$j"
  imagePullPolicy: $imagePullPolicy
  image: "$containerImage"
$(indent 2 createContainerResources)
  env:
  - name: VERBOSE
    value: "$verbose"
$(indent 2 genericCommand cpusoaker.pl)
  - "$namespace"
  - "$podname"
  - "c$j"
  - "$basetime"
  - "$baseoffset"
  - "$(ts)"
  - "$poddelay"
  - "$processes"
  - "$xferTime"
  - "$exitAtEnd"
  - "$syncService"
  - "$syncPortNum"
  - "$log_host"
  - "$log_port"
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createSoakerSpec() {
    local podname=$1
    local namespace=$2
    local i=$3
    local secretCount=$4
    local -i processes=$5
    local -i containers=$6
    cat <<EOF
spec:
$(indent 2 node_selector)
  terminationGracePeriodSeconds: 1
$(indent 2 <<< "$runtimeClass")
  containers:
$(indent 2 createContainersCPUSoakerYAML "$@")
$(indent 2 createPbenchAgentYAML)
$(indent 2 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

function createSoakerDeployment() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i processes=$4
    local -i containers=$5
    local nsline=${useNamespaces:+  namespace: "$namespace"}
    if [[ $deploymentType = pod ]] ; then
	local -i j=0
	while (( j++ < replicas )) ; do
	    createObject <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${namespace}-soaker-${i}-${j}
$nsline
$(indent 2 createPrivilegeYAML)
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-soaker-${i}
  labels:
    ${basename}-id: "$runUUID"
    ${basename}: "true"
    clusterbusterbase: "true"
    name: ${namespace}-soaker-${i}
    app: ${namespace}-soaker-${i}
    ${basename}-soaker: "true"
    ${basename}-client: "true"
$(createSoakerSpec "${namespace}-soaker-${i}-${j}" "$@")
  restartPolicy: Never
EOF
	done
    else
	createObject <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-soaker-$i
$nsline
$(indent 2 createPrivilegeYAML)
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  replicas: $replicas
$(indent 2 node_selector)
  selector:
    matchLabels:
      app: ${namespace}-soaker-$i
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        ${basename}-id: "$runUUID"
        ${basename}: "true"
        clusterbusterbase: "true"
        name: ${namespace}-soaker-$i
        app: ${namespace}-soaker-$i
        ${basename}-soaker: "true"
        ${basename}-client: "true"
$(indent 4 createSoakerSpec "${namespace}-soaker-${i}-deployment" "$@")
EOF
    fi
}

function createDeploymentCPUSoaker() {
    local namespace=$1
    local count=${2:-1}
    local secretCount=${3:-1}
    local replicas=${4:-1}
    local containers=${5:-1}
    local log_host=${6:-}
    local -i log_port=${7:-0}
    local -i i
    if [[ syncStart -gt 0 && -z "$syncHost" ]] ; then
	createService "$namespace" "${namespace}-sync" "$syncPort"
	createSyncDeployment 2 "$namespace" "$((containers * replicas * processes_per_pod * count))"
    fi
    for i in $(seq $firstDeployment $((count + firstDeployment - 1))) ; do
	createSoakerDeployment "$namespace" "$i" "$secretCount"  "$((processes_per_pod))" "$containers" "$log_host" "$log_port"
    done
}

function listConfigMapsCPUSoaker() {
    cat <<EOF
${__libdir__}/cpusoaker.pl
${__libdir__}/sync.pl
EOF
}

function calculateLogsRequiredCPUSoaker() {
    local -i namespaces=$1
    local -i depsPerNamespace=${2:-1}
    local -i replicas=${3:-1}
    local -i containers=${4:-1}
    echo $((namespaces * processes_per_pod * containers * replicas * depsPerNamespace))
}

################################################################
# APIs
################################################################

function doSetup() {
    if type -t "doSetup${podType}" >/dev/null ; then
	"doSetup${podType}"
    fi
}

function createDeployment() {
    "createDeployment${podType}" "$@"
}

function calculateLogsRequired() {
    if type -t "calculateLogsRequired${podType}" >/dev/null ; then
	"calculateLogsRequired${podType}" "$@"
    else
	echo 0
    fi
}

function createObjects_n() {
    trap exit INT
    local objtype=$1; shift
    local parallel=$1; shift
    local blocksize=$1; shift
    local rotor=$1; shift
    local sleeptime=$1; shift
    while (( rotor < namespaces )) ; do
	local j=0
	while (( j < blocksize && j + rotor < namespaces )) ; do
	    "create${objtype}" "${namespaces_to_create[$((rotor + j))]}" "$@"
	    if (( sleeptime )) ; then sleep "$sleeptime"; fi
	    j=$((j+1))
	done
	rotor=$((rotor + (parallel * blocksize)))
    done
    finishCreation
}

function allocate_namespaces() {
    local -i ns_count=0
    local -i ns_idx=0
    if (( scale_ns )) ; then
        while read -r ns ; do
	    if [[ -n "$ns" ]] ; then
		namespaces_in_use[${ns#namespace/}]=1
	    fi
        done < <(_OC get ns -l "$basename" --no-headers -o name 2>/dev/null)
    fi
    while (( ns_count++ < namespaces )) ; do
        while [[ -n "${namespaces_in_use[${basename}-$ns_idx]:-}" ]] ; do
            ns_idx=$((ns_idx+1))
        done
        namespaces_to_create+=("${basename}-$((ns_idx++))")
    done
}

function find_first_deployment() {
    if (( scale_deployments )) ; then
	local ns
	local deployment
	local stuff
	# shellcheck disable=SC2034
        while read -r ns deployment stuff ; do
	    if [[ -n "$deployment" ]] ; then
		deployment=${deployment#${ns}-}
		deployment=${deployment%-*}
		if (( deployment + 1 > firstDeployment )) ; then
		    firstDeployment=$((deployment + 1))
		fi
	    fi
        done < <(_OC get deployments -l "$basename" -A --no-headers 2>/dev/null)
    fi
}

function createAllNamespaces() {
    local i
    trap 'kill -9 $(jobs -p); exit' INT
    for i in $(seq 0 "$((parallelNamespaces - 1))") ; do
	createObjects_n Namespace "$parallelNamespaces" "$blocksizeNamespaces" "$((i * blocksizeNamespaces))" "$sleepNamespaces" &
    done
    wait || exit 1
}

function createAllSecrets() {
    local i
    trap 'kill -9 $(jobs -p); exit' INT
    for i in $(seq 0 "$((parallelSecrets - 1))") ; do
	createObjects_n Secrets "$parallelSecrets" "$blocksizeSecrets" "$((i * blocksizeSecrets))" "$sleepSecrets" "$depsPerNamespace" "$secrets" &
    done
    wait || exit 1
}

function createSystemConfigMap() {
    if type -t "listConfigMaps${podType}" >/dev/null ; then
	local -a systemfiles
	readarray -t systemfiles < <(listConfigMaps${podType})
	trap 'kill -9 $(jobs -p); exit' INT
	for i in $(seq 0 "$((parallelConfigMaps - 1))") ; do
	    createObjects_n ConfigMaps "$parallelConfigMaps" "$blocksizeConfigMaps" "$((i * blocksizeConfigMaps))" "$sleepConfigMaps" "systemconfigmap" "${systemfiles[@]}"&
	done
	wait || exit 1
    fi
}

function createAllConfigMaps() {
    createSystemConfigMap
    (( ${#configMapFiles[@]} )) || return;
    local i
    trap 'kill -9 $(jobs -p); exit' INT
    for i in $(seq 0 "$((parallelConfigMaps - 1))") ; do
	createObjects_n ConfigMaps "$parallelConfigMaps" "$blocksizeConfigMaps" "$((i * blocksizeConfigMaps))" "$sleepConfigMaps" "configmap" "${configMapFiles[@]}"&
    done
    wait || exit 1
}

function createAllDeployments() {
    local i
    trap 'kill -9 $(jobs -p); exit' INT
    for i in $(seq 0 "$((parallelDeployments - 1))") ; do
	export PARALLEL_ROTOR=$i
	createObjects_n Deployment "$parallelDeployments" "$blocksizeDeployments" "$((i * blocksizeDeployments))" "$sleepDeployments" "$depsPerNamespace" "$secrets" "$replicas" "$containers" "$log_host" "$log_port" &
    done
    wait || exit 1
}

function createAllObjects() {
    local found_objtype
    local objtype=$1
    shift
    while IFS= read -r 'line' ; do
	if [[ $line = *'__KUBEFAIL__ '* ]] ; then
	    echo "${line/__KUBEFAIL__ /}" 1>&2
	    return 1
	elif [[ $line =~ ^[[:digit:]]{4}(-[[:digit:]]{2}){2}T([[:digit:]]{2}:){2}[[:digit:]]{2}\.[[:digit:]]{6}\ +([-a-z0-9]+)/([-a-z0-9]+)\ +created$ ]] ; then
	    if (( reportObjectCreation )) ; then
		echo "$line" 1>&2
	    fi
	    totalObjectsCreated=$((totalObjectsCreated+1))
	    found_objtype=${BASH_REMATCH[3]}
	    if [[ -z ${objectsCreated[$found_objtype]:-} ]] ; then
		objectsCreated[$found_objtype]=1
	    else
		objectsCreated[$found_objtype]=$((${objectsCreated[$found_objtype]:-}+1))
	    fi
	elif [[ -n "$line" ]] ; then
	    (IFS=''; echo "$line" 1>&2)
	fi
    done < <("createAll${objtype}" "$@" 2>&1)
}

function doCleanup() {
    local -a objectsToClean
    local objtype
    (( doit )) || return
    if [[ -n "$useNamespaces" ]] ; then
	objectsToClean=(namespace)
    else
	objectsToClean=("$deploymentType" configmap secret route service)
    fi
    for objtype in "${objectsToClean[@]}" ; do
	if (( reportObjectCreation )) ; then
	    _OC delete "$objtype" -l "$basename" 1>&2
	else
	    local objects_deleted
	    objects_deleted=$(_OC delete "$objtype" -l "$basename" |grep -c "^${objtype}.*deleted\$")
	    if ((objects_deleted > 0 && reportObjectCreation)) ; then
		printf "Deleted %d %s%s\n" "$objects_deleted" "$objtype" "${plurals[$((objects_deleted == 1))]}" 1>&2
	    fi
	fi
    done
}

################################################################
# Main work loop
################################################################

function run_clusterbuster_1() {
    local -A expected_secrets=()
    local -i i
    local -i status=0
    if (( precleanup )) ; then
	doCleanup
    fi
    allocate_namespaces
    find_first_deployment
    trap 'if [[ -n "$(jobs -p)" ]] ; then kill -INT $(jobs -p); fi; exit' INT
    createAllObjects Namespaces

    # If previous secrets weren't all created, this will yield
    # the wrong result.
    if (( doit && wait_for_secrets )) ; then
	local -i i
	local -i j
	local -i k
	local ns
	local nsd
	for i in $(seq 0 $((namespaces - 1))) ; do
	    ns="secret/secret-${basename}-${namespaces_to_create[$i]##*-}"
	    for j in $(seq $firstDeployment $((depsPerNamespace + firstDeployment - 1))) ; do
		nsd="${ns}-$j"
		for k in $(seq 0 $((secrets - 1))) ; do
		    expected_secrets["${nsd}-$k"]=1
		done
	    done
	done
    fi

    createAllObjects Secrets
    (( ${#configMapFiles[@]} )) && checkConfigMaps "${configMapFiles[@]}"
    createAllObjects ConfigMaps
    if type -t "listConfigMaps${podType}" >/dev/null ; then
	hasSystemConfigMap=1
    fi

    if (( doit )) ; then
	local secname=""
	while (( ${#expected_secrets[@]} )) ; do
	    while read -r secname ; do
		[[ -n "${secname:-}" ]] && unset "expected_secrets[$secname]"
	    done < <(_OC get secret -oname --no-headers -l "$basename" -A)
	    if (( ${#expected_secrets[@]} )) ; then
		echo "Still waiting for ${#expected_secrets[@]} to be created."
		sleep 10
	    else
		break
	    fi
	done
    fi

    local -i logs_expected=0
    local log_host=
    local -i log_port=0
    basetime=$(printf '%(%s)T' -1)
    createAllObjects Deployments || exit 1
    if ((doit && report)) ; then
	logs_expected="$("calculateLogsRequired" "$namespaces" "$depsPerNamespace" "$replicas" "$containers")"
	if ((logs_expected)) ; then
	    if [[ $logStrategy = poll ]] ; then
		local -a syncPods=()
		if [[ -n "$useNamespaces" ]] ; then
		    local -i i
		    for i in $(seq 0 $((namespaces - 1))) ; do
			syncPods+=("-n ${basename}-${i} ${basename}-${i}-sync")
		    done
		else
		    syncPods=("${basename}-0-sync")
		fi
		get_logs "${syncPods[@]}" &
	    else
		log_host=$(hostname -f)
		log_port=$("${__libdir__}/find_free_port")
		(( log_port )) || fatal "Can't get port to listen for logs on!"
		get_logs -p "$log_port" -c "$logs_expected" &
	    fi
	    get_logs_pid=$!
	    trap '[[ -n "$(jobs -p)" ]] && kill -HUP $(jobs -p)' INT TERM HUP
	fi
    fi

    (( doit )) || return
    if ((report && logs_expected && timeout > 0)) ; then
	local -i finis=0
	while (( timeout < 0 || timeout-- )) ; do
	    # CreateContainerError is not necessarily fatal
	    if _OC get pods -A -l "$basename" |grep -q -E -e '([^r]Error|Evicted|Crash)' ; then
		echo "Run failed:" 1>&2
		_OC get pods -A -l "$basename" |grep -E -e '([^r]Error|Evicted|Crash)'
		break
	    fi
	    # This appears to be needed for the shell to actually reap
	    # any terminated jobs.  Without this, the test below always
	    # succeeds so the job doesn't exit.
	    jobs -l >/dev/null
	    if jobs -l |grep -q . ; then
		sleep 1
	    else
		finis=1
		break
	    fi
	done
	if (( ! finis )) ; then
	    if [[ -n "$get_logs_pid" ]] ; then
		echo "Killing logger '$get_logs_pid'"
		exec 3>&2 2>/dev/null
		kill "$get_logs_pid"
		sleep 3
		kill -9 "$get_logs_pid"
		get_logs_pid=
		exec 2>&3 3>&-
		wait "$get_logs_pid"
	    fi
	    echo "Run did not terminate" 1>&2
	    status=1
	fi
    fi
    if [[ -n "${get_logs_pid:-}" ]] ; then
	wait "$get_logs_pid"
	status=$?
    fi
    local objtype
    if (( reportObjectCreation )) ; then
	while read -r objtype ; do
	    [[ -n "${objtype:-}" ]] && printf "Created %${#totalObjectsCreated}d %s%s\n" "${objectsCreated[$objtype]}" "$objtype" "${plurals[$((${objectsCreated[$objtype]} == 1))]}" 1>&2
	done < <( (IFS=$'\n'; echo "${!objectsCreated[*]}") | sort)
	printf "Created %d object%s total\n" "$totalObjectsCreated" "${plurals[$((totalObjectsCreated == 1))]}" 1>&2
    fi
    if ((cleanup)) ; then
	doCleanup
    fi

    return $status
}

(run_clusterbuster_1)
