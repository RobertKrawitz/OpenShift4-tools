#!/bin/bash

set -u

declare -i namespaces=1
declare -i depsPerNamespace=1
declare -i secrets=0
declare -i replicas=1
declare -i parallel=1
declare -i containers=1
declare -i sleeptime=0
declare -i doit=1
declare -i blocksize=1
declare -i blockitemcount=0
declare -i port=7777
declare -i affinity=0
declare -i verbose=0
declare dataRate=0
declare -i bytes=1000000000
declare -i msgSize=32768
declare -i poddelay=0
declare podType=ClusterBuster
declare podsleeptime=infinity
declare basename=clusterbuster
declare -i basetime
declare opt
declare -r nl='
'

declare accumulateddata=

declare OC
OC=$(type -p oc)
OC=${OC:-$(type -p kubectl)}	# kubectl might not work, though...

declare _helpmsg
read -r -d '' _helpmsg <<'EOF'
Usage: $0 [options] [name]
       Default 1 namespace
    Options:
       -H              Print extended help
       -n              Print what would be done without doing it
       -P podtype      Pod type (classic, pause, server)
       -B basename     Base name of pods (default clusterbuster).
                       All objects are labeled with this name.
       -b blocksize    Number of objects to create in one oc call (default 1)
       -c containers   Number of containers per pod
       -D data rate    Data rate for client/server (MB/sec) (default 0)
       -M megabytes    Amount of data to transfer
       -m msgsize      Message size in data transfer
       -d deployments  Number of deployments per namespace (default 1)
       -N namespaces   Number of namespaces to create (default 1)
       -p parallel     Number of operations to perform in parallel (default 1)
       -r replicas     Number of replicas per deployment (default 1)
       -s secrets      Number of secrets per deployment (default 0)
       -v              Print verbose log messages.  Useful with
                       clusterbuster-connstat.
       -w wait         Number of seconds to wait between ops (default 0)
       -x              Use pod affinity between client and server (default no)
       -X              Use pod anti-affinity between client/server (default no)
       -z podsleep     Amount of time in seconds for pod to sleep before exit
                       (default infinity).  This may be an expression evaluated
                       as an argument to sleep(1) and need not be a numeric
                       constant.
EOF

function help() {
    echo "$_helpmsg"
    exit 1
}

function _helpExtended() {
    echo "$_helpmsg"
    cat <<'EOF'

Clusterbuster is a tool to permit you to load a configurable workload
onto an OpenShift cluster.  This is not a full-featured workload
generator like clusterloader; it generates very specific types of load
that for the most part focus on API objects.

Clusterbuster allows you to create three kinds of pods (via
deployments).  The type of pod is selected by the -P option.

- A simple pause-type implementation written in perl that emits a log
  heartbeat once a minute.

- Pause pod (uses the least resources).  Useful for testing the control
  plane, but not the data plane.

- A client-server workload, with optional bidirectional data transfer
  at a specified data rate.  Allows load testing of the data plane.


All three types allow you to configure the following load parameters:

- Number of namespaces created (-N)

- Number of deployments per namespace (-d)

- Number of replicas per deployment (-r)

- Number of containers per replica (-c)

- Number of secrets per deployment (-s)

The total number of pods created is (N * d * r) and the total number
of containers is (N * d * r * c).  The number of secrets is (N * d).
This is useful for testing of scaling of both nodes and apiserver/etcd
combination on the control plane.


The client-server workload consists of one server pod, with one
container, per deployment.  The clients and server can optionally
engage in ping-pong data transfer.  The number of client pods is
controlled by the number of replicas.  Therefore, each server will
service (r * c) connections.  Each container will attempt to transmit
up to the specified data rate (-D) megabytes/second, and then receive
the amount of data.  The amount of data to be sent can be specified
via -M, in megabytes; the size of each message can be specified via
-m, in bytes.  By default, no data is sent.

Via -x and -X it is possible to specify whether clients will be
colocated with their server (-x) or forced onto different nodes (-X).
If neither option is specified, clusterbuster allows OpenShift to
place pods as it sees fit.  You can use `oc logs` on a client pod (or
use Prometheus metrics) to get data transfer information; with -v,
verbose information about each transfer is printed.

The client logs the following at the end of any data transfer:

STATS <atime> <stime> <gtime> <etime> <endtime> <user> <sys> <interval> <data> <detime> <rate> <mean> <stdev>

defined as:

atime           Time (seconds from start of run) of "oc apply" to
                create the client
stime           Time when the client started running
gtime           Time when "gethostbyname" completed
etime           Time when connection to server succeeded
endtime         Time when client completed
user            User CPU time
user            System CPU time
interval        Duration between first attempt to connect and
                successful connection
data            Number of data bytes sent and received
detime          Elapsed time for data transmission/reception
rate            Rate (MB/sec) of data transfer, if any
mean            Mean time sleeping between messages to attempt to
                achieve the desired transmission rate
stdev           Standard deviation of sleep interval between messages

You can use `clusterbuster-connstat` to extract client information about a
running or completed test run, including the above data.  Running
`clusterbuster -v` allows `clusterbuster-connstat` to extract data about
transfers completed thus far.


You can run multiple concurrent clusterbusters by choosing different
basenames for each instance (-B).  All objects created by that run
will be tagged with the basename, in addition to 'clusterbusterbase'
(to allow you to easily find or delete all objects created by
clusterbuster).


Examples:

- You have a 30 node cluster and wish to test 500 pods per node, all
  in one namespace:

  clusterbuster -d 15000

- You wish to use 1000 namespaces for the same test:

  clusterbuster -N 1000 -d 15

- You wish to add 150,000 secrets to further stress the apiserver and
  etcd:

  clusterbuster -N 1000 -d 15 -s 10

- You wish to exchange data at 10 MB/sec with a total of 2 GB per client,
  with 5 deployments in 2 namespaces each of which uses 4 replica clients
  and 3 containers.  You wish to place the clients on nodes other than the
  servers:

  clusterbuster -P server -N 2 -d 5 -r 4 -c 3 -X -v

EOF
}

function helpExtended() {
    _helpExtended | "${PAGER:-more}"
    exit 1
}

function ts() {
    local dt
    dt=$(date '+%s.%N')
    local sec=${dt%.*}
    local ns=${dt#*.}
    echo "${sec}.${ns:0:6}"
}

function timestamp() {
    while read -r LINE ; do
	printf "%s %s\n" "$(TZ=GMT-0 date '+%Y-%m-%dT%T.%N' | cut -c1-26)" "$LINE"
    done
}

trap exit INT

function process_option() {
    local option=$1
    local optname
    local optvalue
    optname=${option%%=*}
    optname=${optname,,}
    optvalue=${option#*=}
    noptname=${optname//-/_}
    if [[ $option != *'='* ]] ; then
	if [[ $optname = "no_"* || $optname = "dont_"* ]] ; then
	    optname=${optname#dont_}
	    optname=${optname#no_}
	    optvalue=0
	else
	    optvalue=1
	fi
    fi
    case "$noptname" in
	help_all*)     help-extended			;;
	help*)         help				;;
	pod_type)      podType=$optvalue		;;
	basename)      basename=$optvalue		;;
	blocksize)     blocksize=$optvalue		;;
	containers)    containers=$optvalue		;;
	namespaces)    namespaces=$optvalue		;;
	datarate)      dataRate=$optvalue		;;
	bytes)         bytes=$((optvalue))		;;
	kb|kilobytes)  bytes=$((optvalue*1000))		;;
	kib|kibibytes) bytes=$((optvalue*1024))		;;
	mb|megabytes)  bytes=$((optvalue*1000000))	;;
	mib|mebibytes) bytes=$((optvalue*1048576))	;;
	gb|gigabytes)  bytes=$((optvalue*1000000000))	;;
	gib|gibibytes) bytes=$((optvalue*1073741824))	;;
	msgsize)       msgSize=$optvalue		;;
	secrets)       secrets=$optvalue		;;
	verbose)       verbose=$optvalue		;;
	quiet)         verbose=$((!optvalue))		;;
	replicas)      replicas=$optvalue		;;
	parallel)      parallel=$optvalue		;;
	sleep)         sleeptime=$optvalue		;;
	podsleep)      podsleeptime=$optvalue		;;
	poddelay)      poddelay=$optvalue		;;
	affinity)
	    case "$optvalue" in
		1|'') affinity=1   ;;
		2|anti) affinity=2 ;;
		*) affinity=0      ;;
	    esac
	    ;;
	antiaffinity|anti_affinity)
	    case "$optvalue" in
		1|'') affinity=2   ;;
		*) affinity=0      ;;
	    esac
	    ;;
	*) help "$optname" ;;
    esac
}

while getopts ":B:b:c:ns:D:M:m:d:p:r:w:z:hHN:P:xXqv-:" opt ; do
    case "$opt" in
	n) doit=0			;;
	P) podType="$OPTARG"		;;
	B) basename="$OPTARG"		;;
	b) blocksize="$OPTARG"          ;;
	c) containers="$OPTARG"         ;;
	N) namespaces="$OPTARG"         ;;
	D) dataRate="$OPTARG"           ;;
	M) bytes=$((OPTARG * 1000000))	;;
	m) msgSize="$OPTARG"		;;
	d) depsPerNamespace="$OPTARG"   ;;
	s) secrets="$OPTARG"            ;;
	q) verbose=0			;;
	r) replicas="$OPTARG"           ;;
	p) parallel="$OPTARG"           ;;
	v) verbose=1			;;
	w) sleeptime="$OPTARG"          ;;
	z) podsleeptime="$OPTARG"	;;
	x) affinity=1			;;
	X) affinity=2			;;
	h) help				;;
	H) helpExtended			;;
	-) process_option "$OPTARG"	;;
	*) help "$OPTARG"               ;;
    esac
done

shift $((OPTIND - 1))

if [[ -z $OC && $doit -gt 0 ]] ; then
    echo "Cannot find oc or kubectl command, exiting!"
    exit 1
fi

if (( msgSize <= 0 )) ; then
    echo "Message size must be positive, exiting!"
    exit 1
fi

case "$podType" in
    classic|ClusterBuster) podType=ClusterBuster ;;
    server)                podType=Server        ;;
    pause|PausePod|*)      podType=PausePod      ;;
esac

if [[ -n ${1:-} ]] ; then
    basename="$1"
    shift
fi

[[ -z "$*" ]] || echo "Warning: extraneous arguments $# after basename will be ignored!" 1>&2

function indent_1() {
    local -i column="$1"
    local -r indent="$(printf "%${column}s")"
    while IFS= read -r 'line' ; do
	 [[ -z "$line" ]] || echo "${indent}${line}"
    done
}

function indent() {
    local -i column="$1"
    shift
    if [[ -n "$*" ]] ; then
	"$@" | indent_1 "$column"
    else
	indent_1 "$column"
    fi
}

function finishCreation() {
    if [[ $doit -ne 0 && -n $accumulateddata ]] ; then
	"${OC}" apply -f - <<< "$accumulateddata" | timestamp
	accumulateddata=
    fi
}

function createObject() {
    local data=
    while IFS='' read -r line ; do
	if [[ -n $line ]] ; then
	    [[ -n $data ]] || data="---$nl"
	    data+="$line$nl"
	fi
    done
    data+="$nl"
    if (( doit )) ; then
	accumulateddata+="$data"
	if (( ++blockitemcount >= blocksize )) ; then
	    "${OC}" apply -f - <<< "$accumulateddata" | timestamp
	    accumulateddata=
	    blockitemcount=0
	    (( !sleeptime )) || sleep "$sleeptime"
	fi
    else
	echo "$data"
    fi
}

function createNamespace() {
    local namespace=$1
    createObject <<EOF
apiVersion: v1
kind: Namespace
metadata:
  name: "${namespace}"
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
EOF
}

function createSecrets() {
    local namespace=$1
    local depsPerNamespace=${2:-1}
    local secrets=${3:-1}
    local -i i
    local -i j
    (( secrets )) || return;
    for i in $(seq 0 $((depsPerNamespace - 1))) ; do
	for j in $(seq 0 $((secrets - 1))) ; do
	    createObject <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: "secret-${namespace}-${i}-${j}"
  namespace: "$namespace"
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
data:
  key1: "$(base64 <<< "${namespace}X${i}Y${j}Z1")"
  key2: "$(base64 <<< "${namespace}X${i}Y${j}Z2")"
type: Opaque
EOF
	done
    done
}

function createVolumeMountsYAML() {
    local namespace=$1
    local deployment=${2:-1}
    local secrets=${3:-1}
    (( secrets )) || return;
    echo "volumeMounts:"
    local -i i
    for i in $(seq 0 $((secrets - 1))) ; do
	local name="secret-${namespace}-${deployment}-$i"
	cat <<EOF
- name: $name
  mountPath: /etc/$name
  readOnly: true
EOF
    done
}

function createVolumesYAML() {
    local namespace=$1
    local deployment=${2:-1}
    local secrets=${3:-1}
    (( secrets )) || return;
    local -i i
    echo "volumes:"
    for i in $(seq 0 $((secrets - 1))) ; do
	local name="secret-${namespace}-${deployment}-$i"
	cat<<EOF
- name: $name
  secret:
    secretName: $name
EOF
    done
}

function createContainersClusterBusterYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i pods=$4
    local -i containers=$5
    local -i j
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: ${namespace}-$i-$j
  imagePullPolicy: IfNotPresent
  image: "busybox"
  command:
  - /bin/sh
  args:
  - -c
  - |
    trap 'exit 0' TERM
    (while : ; do date ; sleep 60 ; done)&
    sleep $podsleeptime
    exit 1
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createContainersPausePodYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i pods=$4
    local -i containers=$5
    local -i j
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: ${namespace}-$i-$j
  imagePullPolicy: IfNotPresent
  image: "gcr.io/google_containers/pause-amd64:3.0"
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createDeploymentClassicYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local -i pods=$4
    local -i containers=$5
    cat <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-$i
  namespace: $namespace
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  replicas: $pods
  selector:
    matchLabels:
      app: ${namespace}-$i
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        ${basename}: "true"
        clusterbusterbase: "true"
        name: ${namespace}-$i
        app: ${namespace}-$i
    spec:
      terminationGracePeriodSeconds: 1
      restartPolicy: Always
      containers:
$(indent 6 createContainers${podType}YAML "$@")
$(indent 6 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

function createService() {
    local namespace=$1
    local deployment=$2
    createObject <<EOF
apiVersion: v1
kind: Service
metadata:
  name: "service-${deployment}"
  namespace: "$namespace"
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  ports:
  - port: $port
    targetPort: $port
  selector:
    name: "${deployment}"
EOF
}

function createRoute() {
    local namespace=$1
    local deployment=$2
    createObject <<EOF
apiVersion: v1
kind: Route
metadata:
  name: "route-${deployment}"
  namespace: "$namespace"
  labels:
    ${basename}: "true"
    clusterbusterbase: "true"
spec:
  host: "service-${deployment}"
  to:
    kind: Service
    name: "service-${deployment}"
  selector:
    name: "${deployment}"
EOF
}

declare serverContainerPerl
read -r -d '' serverContainerPerl <<'EOF'
#!/usr/bin/perl
use Socket;
use POSIX;
use strict;
use Time::Piece;
use Time::HiRes qw(gettimeofday);
$SIG{TERM} = sub { POSIX::_exit(0); };
my ($basetime, $listen_port, $container, $msgSize, $ts) = @ARGV;
sub timestamp($) {
    my ($str) = @_;
    my (@now) = gettimeofday();
    printf STDERR  "$container %s.%06d %s\n", gmtime($now[0])->strftime("%Y-%m-%dT%T"), $now[1], $str;
}
timestamp("Clusterbuster server starting");
my $sockaddr = "S n a4 x8";
socket(SOCK, AF_INET, SOCK_STREAM, getprotobyname('tcp')) || die "socket: $!";
$SIG{TERM} = sub { close SOCK; POSIX::_exit(0); };
setsockopt(SOCK,SOL_SOCKET, SO_REUSEADDR, pack("l",1)) || die "setsockopt reuseaddr: $!\n";
setsockopt(SOCK,SOL_SOCKET, SO_KEEPALIVE, pack("l",1)) || die "setsockopt keepalive: $!\n";
bind(SOCK, pack($sockaddr, AF_INET, $listen_port, "\0\0\0\0")) || die "bind: $!\n";
listen(SOCK, 5) || die "listen: $!";
my $mysockaddr = getsockname(SOCK);
my ($junk, $port, $addr) = unpack($sockaddr, $mysockaddr);
die "can't get port $port: $!\n" if ($port ne $listen_port);
timestamp("Listening on port $listen_port");

for (;;) {
    accept(CLIENT, SOCK) || next;
    if ((my $child = fork()) == 0) {
	close(SOCK);
	$SIG{TERM} = sub { close CLIENT; POSIX::_exit(0); };
	my $peeraddr = getpeername(CLIENT);
	my ($port, $addr) = sockaddr_in($peeraddr);
	my $peerhost = gethostbyaddr($addr, AF_INET);
	my $peeraddr = inet_ntoa($addr);
	timestamp("Accepted connection from $peerhost ($peeraddr) on $port!");
	my ($consec_empty) = 0;
	while (1) {
	    my $buffer;
	    my $nread;
	    my $ntotal = 0;
	    while ($ntotal < $msgSize && ($nread = sysread(CLIENT, $buffer, $msgSize, $ntotal)) > 0) {
		$ntotal += $nread;
		$consec_empty=0;
	    }
	    if ($nread < 0) {
		die "Write failed: $!\n";
	    }
	    if ($ntotal == 0) {
	        if ($consec_empty > 1) {
		    timestamp("Exiting $port");
		    exit(0);
		}
	        $consec_empty++;
	    }
	    my $nwrite;
	    while ($ntotal > 0 && ($nwrite = syswrite(CLIENT, $buffer, $ntotal)) > 0) {
		$ntotal -= $nwrite;
	    }
	    if ($nwrite < 0) {
		die timestamp("Write failed: $!");
	    }
	}
    } else {
	close(CLIENT);
    }
}
while (wait() >= 0) {
}
EOF

function createServerContainerYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    cat <<EOF
- name: server
  image: perl
  imagePullPolicy: IfNotPresent
  ports:
  - containerPort: $port
  command:
  - perl
  args:
  - -e
  - |
$(indent 4 <<< "$serverContainerPerl")
  - "$basetime"
  - "$port"
  - "${namespace}-${i}-server"
  - "$msgSize"
  - "$(ts)"
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
}

function createServerDeployment() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    createObject <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-${i}-server
  namespace: $namespace
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${namespace}-$i
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        name: ${namespace}-$i
        app: ${namespace}-$i
        k8s-app: ${namespace}-${i}-server
        ${basename}: "true"
        ${basename}-server: "true"
        clusterbusterbase: "true"
    spec:
      terminationGracePeriodSeconds: 1
      containers:
$(indent 6 createServerContainerYAML "$namespace" "$i" "$secretCount")
$(indent 6 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

declare clientContainerPerl
read -r -d '' clientContainerPerl <<'EOF'
#!/usr/bin/perl

use Socket;
use POSIX;
use strict;
use Time::HiRes qw(gettimeofday usleep);
use Time::Piece;
$SIG{TERM} = sub { POSIX::_exit(0); };
my ($basetime, $poddelay, $connect_port, $container, $srvhost, $data_rate, $bytes, $msgSize, $crtime) = @ARGV;
my ($etime, $data_sent, $detime, $stime, $end_time, $dstime, $mean, $stdev, $user, $sys, $cuser, $csys, $elapsed);
my $start_time;
my $ghbn_time;
sub ts() {
    my (@now) = gettimeofday();
    return sprintf("%s.%06d", gmtime($now[0])->strftime("%Y-%m-%dT%T"), $now[1]);
}
sub timestamp($) {
    my ($str) = @_;
    printf STDERR "%s %s %s\n", $container, ts(), $str;
}
sub xtime() {
    my (@now) = gettimeofday();
    return $now[0] + ($now[1] / 1000000.0);
}
sub print_stats() {
    printf STDERR "STATS %.3f %.3f %.3f %.3f %.3f %.3f %.6f %.3f %.3f %d %.3f %.3f %.6f %.6f\n",
	   $crtime - $basetime, $start_time - $basetime, $ghbn_time - $basetime, $etime - $basetime, $dstime - $basetime, $end_time - $basetime, $elapsed, $user, $sys,
	   $data_sent, $detime, $data_sent / $detime / 1000000.0, $mean, $stdev;
}
timestamp("Clusterbuster client starting");
$start_time = xtime();
my ($connected) = 0;
my ($fname,$faliases,$ftype,$flen,$faddr);
do {
    ($fname,$faliases,$ftype,$flen,$faddr) = gethostbyname($srvhost);
    my $sockaddr = "S n a4 x8";
    my $straddr = inet_ntoa($faddr);
    timestamp("Connecting to $srvhost ($fname, $ftype, $straddr)");
    $ghbn_time = xtime();
    my $sockmeta = pack($sockaddr, AF_INET, $connect_port, $faddr);
    socket(CONN, AF_INET, SOCK_STREAM, getprotobyname('tcp')) || die "can't make socket: $!";
    $stime = xtime();
    if (connect(CONN, $sockmeta)) {
	$connected = 1;
    } else {
	timestamp("Could not connect to $srvhost on port $connect_port: $!");
	close CONN;
	sleep(1);
    }
} while (! $connected);
$SIG{TERM} = sub { close CONN; POSIX::_exit(0); };
$etime = xtime();
$elapsed = $etime - $stime;
my $peeraddr = getpeername(CONN);
my ($port, $addr) = sockaddr_in($peeraddr);
my $peerhost = gethostbyaddr($addr, AF_INET);
$peeraddr = inet_ntoa($addr);
timestamp("Connected to $peerhost ($peeraddr) on port tcp:$port");
my $buffer = "";
vec($buffer, $msgSize - 1, 8) = "A";
my $tbuf;
my $nread;
my $bufsize = length($buffer);
my $starttime = xtime();
my $MBSec = $data_rate * 1;
($dstime) = xtime();

$data_sent = 0;
$mean = 0;
$stdev = 0;
if ($MBSec > 0) {
    my $delaytime = $basetime + $poddelay - $dstime;
    my $pass = 0;
    my $e0 = 0;
    my $ex = 0;
    my $ex2 = 0;
    timestamp("Using $bufsize byte buffer");
    if ($delaytime > 0) {
	timestamp("Sleeping $delaytime seconds to synchronize");
	usleep($delaytime * 1000000);
    }
    $dstime = xtime();
    while ($data_sent < $bytes) {
	my $nwrite;
	my $nleft = $bufsize;
	while ($nleft > 0 && ($nwrite = syswrite(CONN, $buffer, $nleft)) > 0) {
	    $nleft -= $nwrite;
	    $data_sent += $nwrite;
	}
	if ($nwrite == 0) {
	    exit 0;
	} elsif ($nwrite < 0) {
	    die "Write failed: $!\n";
	}
	$nleft = $bufsize;
	my $tbuf;
	while (($nread = sysread(CONN, $tbuf, $nleft)) > 0) {
	    $nleft -= $nread;
	}
	if ($nread < 0) {
	    die "Read failed: $!\n";
	}
	if ($ENV{"VERBOSE"} > 0) {
	    timestamp("Write/Read $bufsize");
	}
	my $curtime = xtime();
	$starttime += $bufsize / ($MBSec * 1000000);
	if ($curtime < $starttime) {
	    if ($ENV{"VERBOSE"} > 0) {
		timestamp(sprintf("Sleeping %8.6f", $starttime - $curtime));
	    }
	    usleep(($starttime - $curtime) * 1000000);
	    if ($pass == 0) {
		$e0 = $starttime - $curtime;
	    }
	    my $en = ($starttime - $curtime) - $e0;
	    $ex += $en;
	    $ex2 += $en * $en;
	} else {
	    if ($ENV{"VERBOSE"} > 0) {
		timestamp("Not sleeping");
	    }
	    $ex -= $e0;
	    $ex2 += $e0 * $e0;
	}
	$pass++;
    }
    $mean = ($ex / $pass) + $e0;
    if ($pass > 1) {
	$stdev = sqrt(($ex2 - ($ex * $ex / $pass)) / ($pass - 1));
    }
}
($user, $sys, $cuser, $csys) = times;
$end_time = xtime();
$detime = $end_time - $dstime;
if ($detime <= 0) {
    $detime = 0.00000001;
}

timestamp("Done");
print_stats();
pause();
exit 0;
EOF

function createClientContainerYAML() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local dataRate=$4
    local bytes=$5
    local msgSize=$6
    local containers=$7
    local -i j
    for j in $(seq 0 $((containers - 1))) ; do
	cat <<EOF
- name: client-${j}
  image: "perl"
  imagePullPolicy: IfNotPresent
  env:
  - name: VERBOSE
    value: "$verbose"
  command:
  - perl
  args:
  - -e
  - |
$(indent 4 <<< "$clientContainerPerl")
  - "$basetime"
  - "$poddelay"
  - "$port"
  - "client-${j}"
  - "service-${namespace}-$i"
  - "$dataRate"
  - "$bytes"
  - "$msgSize"
  - "$(ts)"
$(indent 2 createVolumeMountsYAML "$namespace" "$i" "$secretCount")
EOF
    done
}

function createClientAffinityYAML() {
    (( affinity )) || return 0
    local server=$1
    local affinityType
    case "$affinity" in
	1) affinityType=Affinity     ;;
	*) affinityType=AntiAffinity ;;
    esac
    cat << EOF
affinity:
  pod$affinityType:
    requiredDuringSchedulingIgnoredDuringExecution:
    - labelSelector:
        matchExpressions:
        - key: k8s-app
          operator: In
          values:
          - "$server"
      topologyKey: kubernetes.io/hostname
EOF
}

function createClientDeployment() {
    local namespace=$1
    local i=$2
    local secretCount=$3
    local replicas=$4
    local dataRate=$5
    local bytes=$6
    local msgSize=$7
    local containers=$8
    createObject <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${namespace}-${i}-client
  namespace: $namespace
spec:
  replicas: $replicas
  restartPolicy: Never
  selector:
    matchLabels:
      app: ${namespace}-${i}-client
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        name: ${namespace}-${i}-client
        app: ${namespace}-${i}-client
        ${basename}: "true"
        ${basename}-client: "true"
        clusterbusterbase: "true"
    spec:
      terminationGracePeriodSeconds: 1
$(indent 6 createClientAffinityYAML "${namespace}-${i}-server")
      containers:
$(indent 6 createClientContainerYAML "$namespace" "$i" "$secretCount" "$dataRate" "$bytes" "$msgSize" "$containers")
$(indent 6 createVolumesYAML "$namespace" "$i" "$secretCount")
EOF
}

function createDeploymentPausePod() {
    local namespace=$1
    local count=${2:-1}
    local secretCount=${3:-1}
    local pods=${4:-1}
    local containers=${5:-1}
    local -i i
    for i in $(seq 0 $((count - 1))) ; do
	createObject <<< "$(createDeploymentClassicYAML "$namespace" "$i" "$secretCount"  "$replicas" "$containers")"
    done
}

function createDeploymentClusterBuster() {
    createDeploymentPausePod "$@"
}

function createDeploymentServer() {
    local namespace=$1
    local count=${2:-1}
    local secretCount=${3:-1}
    local pods=${4:-1}
    local containers=${5:-1}
    local -i i
    for i in $(seq 0 $((count - 1))) ; do
	createService "$namespace" "$namespace-$i"
	createRoute "$namespace" "$namespace-$i"
	createServerDeployment "$namespace" "$i" "$secretCount" "$msgSize"
	createClientDeployment "$namespace" "$i" "$secretCount" "$replicas" "$dataRate" "$bytes" "$msgSize" "$containers"
    done
}

function createDeployment() {
    "createDeployment${podType}" "$@"
}

function createObjects_n() {
    trap exit INT
    local objtype=$1; shift
    local parallel=$1; shift
    local rotor=$1; shift
    while (( rotor < namespaces )) ; do
	local j=0
	while (( j < blocksize && j + rotor < namespaces )) ; do
	    "create${objtype}" "${basename}-$((rotor + j))" "$@"
	    j=$((j+1))
	done
	rotor=$((rotor + (parallel * blocksize)))
    done
    finishCreation
}

function run_clusterbuster_1() {
    basetime=$(printf '%(%s)T' -1)
    trap 'kill -9 $(jobs -p); exit' INT
    for i in $(seq 0 "$((parallel - 1))") ; do
	createObjects_n Namespace "$parallel" "$((i * blocksize))" &
    done
    wait

    for i in $(seq 0 "$((parallel - 1))") ; do
	createObjects_n Secrets "$parallel" "$((i * blocksize))" "$depsPerNamespace" "$secrets" &
    done
    wait

    for i in $(seq 0 "$((parallel - 1))") ; do
	createObjects_n Deployment "$parallel" "$((i * blocksize))" "$depsPerNamespace" "$secrets" "$replicas" "$containers" &
    done
    wait
}

(run_clusterbuster_1)
