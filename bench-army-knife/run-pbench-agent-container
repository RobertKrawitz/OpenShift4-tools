#!/bin/bash

# Copyright 2020 Robert Krawitz/Red Hat
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

exec 1>&2
export LANG=en_US.UTF-8
export LANGUAGE=en_UT.UTF-8
export LC_ALL=C

set -u

declare sshd_port=2222
declare dns_server
declare -i run_forever=0
declare keyfile=
declare -a verbose=()
declare alias=
declare sshd_args='-o ListenAddress=127.0.0.1'
declare configdir= # Secret containing pbench config and public and private key
declare -i log_environment=0
declare -i unique_hostname=0
trap exit TERM INT

function usage() {
    cat 1>&2 <<EOF
Usage: $0 [options] controller_port [controller_host]
       -a alias       Alias to use.  Defaults to hostname.
       -D configdir   Directory containing pbench configuration and public
                      and private key for communication with pbench server.
                      NO DEFAULT.
       -n dns_server  DNS server used to look up the controller host name,
                      if needed.
       -S sshd_port   Port to listen for ssh connections if needed.
       -K keyfile     Public and private key files used to
                      communicate with the controller.
       -d             Run forever (daemon)
       -v             Increase ssh verbosity
       -L             Run sshd with global listener
       -q             Log stderr to /tmp/container.log on the pod
                      rather than to the container log stream if there
                      are problems with container logging.
       -u             Provide unique hostname to controller.
                      Useful for running standalone agents as
                      a daemonset or other replica set.
       -e             Log the environment.
EOF
    sleep infinity
    exit 1
}

while getopts ":a:D:n:S:K:C:dvLqeu" arg ; do
    case "$arg" in
	a) alias=$OPTARG	     ;;
	e) log_environment=1	     ;;
	D) configdir=$OPTARG	     ;;
	n) dns_server=$OPTARG	     ;;
	S) sshd_port=$OPTARG	     ;;
	K) keyfile=$OPTARG	     ;;
	d) run_forever=1	     ;;
	v) verbose+=("-v")	     ;;
	L) sshd_args=		     ;;
	q) exec 2>/tmp/container.log ;;
	u) unique_hostname=1	     ;;
	*) usage
    esac
done

shift $((OPTIND - 1))

(( $# == 1 || $# == 2 )) || usage

declare myhostname=$(ip route get 1 |awk '{print $(NF-2); exit}')
declare controller_port=$1
declare controller_host=${2:-$myhostname}
if [[ -z "${BAK_SERVER_CONFIG:-}" || -z "${BAK_SERVER_PRIVATE_KEY:-}" ]] ; then
    [[ -z "$configdir" ]] && usage "-D must be specified."
    [[ -d "$configdir" ]] || usage "-D $configdir does not exist."
    [[ -r "$configdir"/pbench-agent.cfg ]] || usage "Expected configuration file $configdir/pbench-agent.cfg does not exist"
    [[ -r "$configdir"/id_rsa ]] || usage "Expected private key $configdir/pbench-agent.cfg does not exist"
fi
[[ -z "$keyfile" && -r "$configdir/id_rsa" ]] && keyfile="$configdir/id_rsa"
[[ $keyfile == '/'* ]] || keyfile="$configdir/$keyfile"
[[ -r "$keyfile" ]] || usage "Private key file $keyfile does not exist."
[[ -r "${keyfile}.pub" ]] || usage "Public key file ${keyfile}.pub does not exist."

if [[ ! -r "$keyfile" || ! -r "${keyfile}.pub" ]] ; then
    echo "Can't find key files $keyfile or $keyfile.pub" 1>&2
    usage
fi
declare server_config=${BAK_SERVER_CONFIG:-$configdir/pbench-agent.cfg}
(umask 0333 && cp "$server_config" /opt/pbench-agent/config/pbench-agent.cfg && chown pbench:pbench /opt/pbench-agent/config/pbench-agent.cfg)

PATH=/usr/local/bin:$PATH

# Need -u disabled for this pending
# https://github.com/distributed-system-analysis/pbench/pull/1746
set +u
# shellcheck disable=1091
. /etc/profile.d/pbench-agent.sh
set -u

if (( log_environment )) ; then
    echo "Environment:" 1>&2
    env | sort 1>&2
fi

(mount |grep -q debugfs) || sudo mount -t debugfs none /sys/kernel/debug

[[ -z "$(shopt -s nullglob; echo "/etc/ssh/ssh_host"*)" ]] && ssh-keygen -A

# Make sure ssh authorized keys are set up correctly

cat "${keyfile}.pub" >> "$HOME/.ssh/authorized_keys"
chown root "$HOME/.ssh/authorized_keys"
chgrp root "$HOME/.ssh/authorized_keys"
# XXXXXX Careful about this...
rm -f /run/nologin
/usr/sbin/sshd -p "$sshd_port" $sshd_args

function run_pbench_agent_once() {
    echo "Running pbench agent" 1>&2
    ip addr 1>&2
    if [[ -n "${dns_server:-}" && $controller_host =~ ^[[:alnum:]][-[:alnum:]]*[[:alnum:]]\.[[:alnum:]][-[:alnum:]]*[[:alnum:]]$ ]] ; then
	echo "Looking for IP address for $controller_host from $dns_server" 1>&2
	while read -r line ; do
	    echo "$line" 1>&2
	    if [[ $line =~ ^$controller_host(\.svc.cluster.local)?\ has\ address\ (.*)$ ||
		      $line =~ (.*)\ has\ address\ (($controller_host)(\.svc.cluster.local)?)$ ]] ; then
		controller_host=${BASH_REMATCH[2]}
		break
	    fi
	done <<< "$(host "$controller_host.svc.cluster.local" "$dns_server")"
    fi

    # Let the controller know that we're ready to go
    # shellcheck disable=2155
    if (( unique_hostname )) ; then
	token=$(printf '%d %s %s %s-%09d.%s' "$sshd_port" "$(perl -e 'print int rand() * 999999999')" "$(hostname)" "$(hostname)" "$(perl -e 'print int rand() * 999999999')" "${alias:-$myhostname}")
    else
	token=$(printf '%d %s %s %s' "$sshd_port" "$(perl -e 'print int rand() * 999999999')" "$(hostname)" "${alias:-$myhostname}")
    fi
    # shellcheck disable=2155
    echo "Waiting for contact from controller" 1>&2
    declare sync_data=$(sync_to.pl "$controller_host" "$controller_port" "$token")
    echo "Got sync, data $sync_data" 1>&2
    declare ssh_tunnel_pid

    if [[ $sync_data = "PASV "* ]] ; then
	# shellcheck disable=2034
	read -r passive remote_ssh_port tunnel_port login <<< "$sync_data"
	echo "Start ssh tunnel" 1>&2
	echo ssh "${verbose[@]}" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i "$keyfile" -n -R "$tunnel_port:localhost:$sshd_port" -p "$remote_ssh_port" "${login:+$login@}$controller_host" sleep infinity 1>&2
	ssh "${verbose[@]}" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i "$keyfile" -n -R "$tunnel_port:localhost:$sshd_port" -p "$remote_ssh_port" "${login:+$login@}$controller_host" sleep infinity 1>&2 &
	ssh_tunnel_pid=$!
	# Controller will ping us to make sure we're up.
	# shellcheck disable=2064
	trap "kill -9 $ssh_tunnel_pid; exit" TERM INT EXIT
    fi

    # And wait around to be released after pbench-move-results
    echo "Waiting for release from controller" 1>&2
    sync_to.pl "$controller_host" "$controller_port"
}

while : ; do
    (run_pbench_agent_once) || {
	echo "Run pbench agent failed!"
	# So we don't "helpfully" get restarted by the controller and messing up
	# the synchronization
	sleep infinity
    }
    (( run_forever )) || break
done
