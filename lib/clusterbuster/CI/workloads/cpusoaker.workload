#!/bin/bash

# Copyright 2022 Robert Krawitz/Red Hat
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

declare -gi ___cpusoaker_starting_replicas=0
declare -gi ___cpusoaker_replica_increment=5
declare -gi ___cpusoaker_max_replicas=-1
declare -gi ___cpusoaker_job_runtime=0
declare -gi ___cpusoaker_job_timeout=0

function cpusoaker_test() {
    local default_job_runtime=$1
    if ((___cpusoaker_replica_increment < 1)) ; then
	echo "Replica increment must be at least 1" 1>&2
	return
    fi
    if ((___cpusoaker_job_runtime <= 0)) ; then
	___cpusoaker_job_runtime=$default_job_runtime
    fi
    ___cpusoaker_job_timeout=$(compute_timeout "$___cpusoaker_job_timeout")
    if ((___cpusoaker_starting_replicas <= 0)) ; then
	___cpusoaker_starting_replicas=$___cpusoaker_replica_increment
    fi
    replicas=$___cpusoaker_starting_replicas
    local -A runtimes_to_test=()
    local runtime
    for runtime in "${runtimeclasses[@]}" ; do
	runtime=${runtime:-runc}
	runtimes+=("$runtime")
	runtimes_to_test[$runtime]=1
    done
    while ((___cpusoaker_max_replicas == -1 || replicas <= ___cpusoaker_max_replicas)); do
	for runtime in "${runtimes[@]}" ; do
	    if [[ -n "${runtimes_to_test[$runtime]:-}" ]] ; then
		local xruntime=$runtime
		if [[ $xruntime = runc ]] ; then xruntime=''; fi
		job_name="$replicas"
		if run_clusterbuster_1 -r "$xruntime" -y  -j "$job_name" -w cpusoaker \
				       -t "$___cpusoaker_job_timeout" -R "$___cpusoaker_job_runtime" -- \
				       --replicas="$replicas" --failure-status='No Result' \
				       --cleanup-always=1 ; then
		    :
		else
		    unset runtimes_to_test[$runtime]
		fi
	    fi
	done
	if [[ -n "${runtimes_to_test[*]}" ]] ; then
	    counter=$((counter+1))
	    replicas=$((replicas+___cpusoaker_replica_increment))
	else
	    break
	fi
	if ((debugonly)) ; then
	    break
	fi
    done
}

function cpusoaker_process_option() {
    local opt=$1
    read -r noptname1 noptname optvalue <<< "$(parse_option "$opt")"
    case "$noptname1" in
	cpusoakerstarting*) ___cpusoaker_starting_replicas=$optvalue	;;
	cpusoakerreplicai*) ___cpusoaker_replica_increment=$optvalue	;;
	cpusoaker*runtime)  ___cpusoaker_job_runtime=$optvalue		;;
	cpusoaker*timeout)  ___cpusoaker_job_timeout=$optvalue		;;
	cpusoakermax*)      ___cpusoaker_max_replicas=$optvalue		;;
	*) 		    return 1					;;
    esac
    return 0
}


function cpusoaker_help_options() {
    cat <<'EOF'
    CPUsoaker options:
        --cpusoaker-starting-replicas=n
                                Start the test with the specified number of
                                replicas, incrementing until failure.
                                Default 5.
        --cpusoaker-replica-increment=n
                                Increment the number of replicas by the
                                specified number until failure or until
                                --cpusoaker-max-replicas is reached.  Default
                                is cpusoaker-starting-replicas.
        --cpusoaker-runtime=seconds
                                Allow the pods to run for the specified time.
                                Default is 0.  Typically set to 60 to collect
                                reliable metrics data.
        --cpusoaker-timeout=seconds
                                Time the job out after specified time.  Default
                                is the global timeout default.
        --cpusoaker-max-replicas=n
                                Maximum number of replicas to scale to.
                                Default is -1, equivalent to no upper limit.
EOF
}

function cpusoaker_document() {
cat <<'EOF'
* cpusoaker: a simple CPU soaker running a continuous tight loop.
EOF
}

register_workload cpusoaker cpu cpusoak scaling
