#!/usr/bin/perl

use strict;
use JSON;
use Getopt::Long;
Getopt::Long::Configure("bundling", "no_ignore_case", "pass_through");

my $base_repo="openshift-release";
my $base;
my $dot_url;
my $cincy_url;

my @channels;
my @release_channels;
my @release_labels;
my @release_urls;
my @release_payloads;
my %upgrades_from;
my %upgrades_to;
my %release_idx;

my $opt_list_channels;
my $opt_list_releases;
my $opt_list_upgrades;
my $opt_payload;
my $opt_url;
my $opt_channel;
my $opt_all_upgrades;
my $opt_os;
my $help;

sub read_releases() {
    open(DOT, "-|", "curl --silent $dot_url") || die "Can't read $dot_url: $!\n";
    my ($current_channel);
    while (<DOT>) {
	chomp;
	$_ =~ s/^[\s]*//;
	if (/^label="Stream +(.*)";$/) {
	    $current_channel=$1;
	    push @channels, $current_channel;
	} elsif (/^([0-9]+)->([0-9]+) *\[ *(.*) *];$/) {
	    my ($from) = $2;
	    my ($to) = $1;
	    my ($attrs) = $3;
	    if (! defined $upgrades_from{$from}) {
		$upgrades_from{$from} = {};
	    }
	    $upgrades_from{$from}{$to} = $attrs;
	    if (! defined $upgrades_to{$to}) {
		$upgrades_to{$to} = {};
	    }
	    $upgrades_to{$to}{$from} = $attrs;
	} elsif (/^([0-9]+) *\[ *(.*) *];$/) {
	    my ($idx) = $1;
	    my (%attrs) = parse_options($2);
	    if ($release_labels[$idx]) {
		warn "Attempt to redefine release $idx ($release_labels[$idx]) => $attrs{'label'}\n";
	    }
	    $release_labels[$idx] = $attrs{'label'};
	    $release_channels[$idx] = $current_channel;
	    $release_urls[$idx] = $attrs{'href'};
	    $release_idx{$attrs{'label'}} = $idx;
	}
    }
    close(DOT);
}

sub read_graph() {
    open(GRAPH, "-|", "curl --silent $cincy_url") || die "Can't read $cincy_url: $!\n";
    my ($jsontxt);
    while (<GRAPH>) {
	$jsontxt .= $_;
    }
    close GRAPH;
    my $json = decode_json($jsontxt);
    my $nodes = $$json{'nodes'};
    if ($nodes) {
	foreach my $node (@$nodes) {
	    my $version = $$node{'version'};
	    my $payload = $$node{'payload'};
	    if (! $version) {
		warn "Can't find version!\n";
	    } elsif ($release_idx{$version}) {
		$release_payloads[$release_idx{$version}] = $payload;
	    }
	}
    }
}

sub get_release_info($) {
    my ($release) = @_;
    my $response;
    open(INFO, "-|", "oc adm release info --image-for=machine-os-content $release") || die "Can't run oc adm release info: $!\n";
    while (<INFO>) {
	chomp;
	$response .= $_;
    }
    close INFO;
    return $response;
}

sub get_os_build($) {
    my ($release) = @_;
    my ($relinfo) = get_release_info($release);
    if (not $relinfo) {
	die "Can't read release info for $release\n";
    }
    open(RELINFO, "-|", "oc image info -o json $relinfo") || die "Can't run oc image info $relinfo: $!\n";
    my ($jsontxt);
    while (<RELINFO>) {
	$jsontxt .= $_;
    }
    close RELINFO;
    my $json = decode_json($jsontxt);
    my ($config) = $$json{'config'};
    if (! $config) {
	warn "Unable to extract configuration\n";
	return '';
    }
    my ($subconfig) = $$config{'config'};
    if (! $subconfig) {
	warn "Unable to extract sub-configuration\n";
	return '';
    }
    my ($labels) = $$subconfig{'Labels'};
    if (! $subconfig) {
	warn "Unable to extract sub-labels\n";
	return '';
    }
    return $$labels{'version'};
}

sub print_channels() {
    read_releases();
    print join("\n", @channels), "\n";
}

sub print_releases($) {
    my ($channel) = @_;
    read_releases();
    read_graph();
    foreach my $idx (0..$#release_labels) {
	if ($channel eq '' || $release_channels[$idx] eq $channel) {
	    print "$release_labels[$idx]\n";
	}
    }
}

sub parse_options($) {
    my ($string) = @_;
    $string =~ s/\s*$//;
    my (@attrs) = split(/, */, $string);
    my (%attrs);
    map { $_ =~ /^(.*)=(.*)$/;
	  my $key = $1;
	  my $val = $2;
	  $val =~ s/^"(.*)"$/$1/;
	  $attrs{$key} = $val;
    } @attrs;
    return %attrs;
}

sub print_upgrades($) {
    my ($release) = @_;
    if ($release eq "") {
	print STDERR "Release must be specified.\n";
	print_help_and_exit();
    }
    read_releases();
    read_graph();
    if (defined $release_idx{$release}) {
	my ($idx) = $release_idx{$release};
	if (defined $upgrades_from{$idx}) {
	    foreach my $upgrade (sort keys %{$upgrades_to{$idx}}) {
		my (%attrs) = parse_options($upgrades_to{$idx}{$upgrade});
		if ($attrs{'style'} ne 'invis' &&
		    ($opt_all_upgrades || $attrs{'color'} ne 'red')) {
		    print "$release_labels[$upgrade]\n";
		}
	    }
	}
    }
}

sub get_releases($$) {
    my ($release, $channel) = @_;
    my (@releases) = ($release);
    read_releases();
    read_graph();
    if (! @releases || $releases[0] eq "all" || $releases[0] eq '') {
	@releases = ();
	foreach my $release (sort keys %release_idx) {
	    if ($channel eq '' || $release_channels[$release_idx{$release}] eq $channel) {
		push @releases, $release;
	    }
	}
    }
    return @releases;
}

sub print_payload($$) {
    my ($release, $channel) = @_;
    my (@releases) = get_releases($release, $channel);
    foreach $release (@releases) {
	if (defined $release_idx{$release}) {
	    if ($#releases > 0) {
		print "$release ";
	    }
	    print "$release_payloads[$release_idx{$release}]\n";
	}
    }
}

sub print_os($$) {
    my ($release, $channel) = @_;
    my (@releases) = get_releases($release, $channel);
    foreach $release (@releases) {
	if (defined $release_idx{$release}) {
	    if ($#releases > 0) {
		print "$release ";
	    }
	    print get_os_build($release_payloads[$release_idx{$release}]), "\n";
	}
    }
}

sub print_url($$) {
    my ($release, $channel) = @_;
    my (@releases) = get_releases($release, $channel);
    foreach $release (@releases) {
	if (defined $release_idx{$release}) {
	    if ($#releases > 0) {
		print "$release ";
	    }
	    print "$base$release_urls[$release_idx{$release}]\n";
	}
    }
}

GetOptions("l"   => \$opt_list_channels,
	   "r"   => \$opt_list_releases,
	   "u=s" => \$opt_list_upgrades,
	   "p=s" => \$opt_payload,
	   "U=s" => \$opt_url,
	   "c=s" => \$opt_channel,
	   "o=s" => \$opt_os,
	   "R=s" => \$base_repo,
	   "a"   => \$opt_all_upgrades,
	   "h"   => \$help);

$base="https://$base_repo.svc.ci.openshift.org";
$dot_url="${base}/graph?format=dot";
$cincy_url="$base/graph";

sub print_help_and_exit() {
    print STDERR <<EOF;
Usage: release_status [-b base] [-l | -r [-c channel] | -u release [-a] | -p release | -U release]
    -R  Use specified base repo (openshift-release or origin-release)
    -l  List available channels
    -r  List releases available (optionally with specified channnel).
    -u  List available upgrades for specified release.
    -o  List OS for specified release
    -p  Print payload for specified release.
    -U  Print URL for specified release.
EOF
    exit 1;
}

if ($help) {
    print_help_and_exit();
} elsif (($opt_list_channels && ($opt_list_releases || $opt_list_upgrades || 
				 $opt_payload || $opt_url || $opt_os)) ||
	 ($opt_list_releases && ($opt_list_upgrades || 
				 $opt_payload || $opt_url || $opt_os)) ||
	 ($opt_list_upgrades && ($opt_payload || $opt_url || $opt_os)) ||
	 ($opt_payload && ($opt_url || $opt_os)) ||
	 ($opt_url && $opt_os)) {
    print STDERR "Only one of -r, -l, -u, -p, -o, or -U may be specified\n";
    print_help_and_exit();
} elsif ($opt_list_releases) {
    print_releases($opt_channel);
} elsif ($opt_list_channels) {
    print_channels();
} else {
    if ($opt_list_upgrades) {
	print_upgrades($opt_list_upgrades);
    } elsif ($opt_payload) {
	print_payload($opt_payload, $opt_channel);
    } elsif ($opt_url) {
	print_url($opt_url, $opt_channel);
    } elsif ($opt_os) {
	print_os($opt_url, $opt_channel);
    } else {
	print STDERR "Unknown command!\n";
	print_help_and_exit();
    }
}
