#!/bin/bash

# Copyright 2019 Robert Krawitz/Red Hat
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

function fatal() {
    echo "FATAL: $*" 1>&2
    exit 1
}

set -u

# Find our helpers
function finddir() {
    local path_to_file
    path_to_file=$(readlink -f "$0")
    if [[ -z $path_to_file ]] ; then
	return 1
    elif [[ -d $path_to_file ]] ; then
	echo "$path_to_file/"
    elif [[ -e $path_to_file ]] ; then
	echo "${path_to_file%/*}/"
    else
	return 1
    fi
    return 0
}

declare ___realsc=
declare ___topsc
if [[ -z ${___topsc:-} ]] ; then
    export ___topsc="${0##*/}"
    # shellcheck disable=SC2155
    export ___topdir="$(finddir "$0")"
    [[ -z $___topdir ]] && fatal "Can't find directory for $0"
fi

function clean_startup() {
    [[ -f $___realsc ]] && rm -f "$___realsc"
}

# This allows us to edit the script while another instance is running
# since this script sticks around until the user exits the spawned shell.
# It's fine for the running script to be removed, since the shell still
# has its open file descriptor.
if [[ $# = 0 || $1 != "--DoIt=$0" ]] ; then
    tmpsc=$(mktemp)
    [[ -z $tmpsc || ! -f $tmpsc || -L $tmpsc ]] && fatal "Can't create temporary script file"
    trap clean_startup EXIT SIGHUP SIGINT SIGQUIT SIGTERM
    PATH+=${PATH:+:}$___topdir
    cat "$0" > "$tmpsc"
    chmod +x "$tmpsc"
    exec "$tmpsc" "--DoIt=$tmpsc" "$@"
else
    ___realsc=${1#--DoIt=}
    clean_startup
    shift
fi

# Globals
declare -A release_base_map=()
release_base_map[origin-release]='4.2.0-0.okd'
release_base_map[openshift-release]='4-stable'

declare -A subdir_map=()
subdir_map[origin-release]='origin'
subdir_map[openshift-release]='ocp'

declare -r kubechart=${KUBECHART:-$GOPATH/src/github.com/sjenning/kubechart/kubechart}
declare -r oschart=${OSCHART:-$GOPATH/src/github.com/sjenning/oschart/oschart}
declare -r default_repo_base=openshift-release

declare -A global_platforms=()

declare -A global_diagnostics=()

declare install_type=
declare install_domain=${OPENSHIFT_INSTALL_DOMAIN:-}
declare install_dir=${OPENSHIFT_INSTALL_DIR:-$install_domain}
declare install_version=latest_default
declare pull_secret=${OPENSHIFT_INSTALL_PULL_SECRET_PATH:-$HOME/Downloads/pull-secret}
declare pubkey_file=${OPENSHIFT_INSTALL_SSH_PUB_KEY_PATH:-$HOME/.ssh/id_rsa.pub}
declare srcdir=${GOPATH:-$HOME/go}/src/github.com/openshift/installer
declare install=$srcdir/bin/openshift-install
declare release_channel=
declare repo=$default_repo_base
declare _____current_platform

# shellcheck disable=SC2155
declare -r OC=$(type -p oc)
[[ -z $OC ]] && fatal "Can't find oc command"
# shellcheck disable=SC2155
declare -r JQ=$(type -p jq)
[[ -z $JQ ]] && fatal "Can't find jq command"
# shellcheck disable=SC2155
declare -r owd=$(pwd)
declare -i clean_install_cache=0
declare -i clean_shutdown=0
declare -i cleanup_run=0
declare -i created_kubechart=0
declare -i created_oschart=0
declare -i do_cleanup=1
declare -i do_login=1
declare -i do_override=0
declare -i force_local_tools=0
declare -i force_postinstall=0
declare -i install_stage=0
declare -i login_succeeded=0
declare -i master_count=0
declare -i noconfirm=0
declare -i overwrite=0
declare -i query=0
declare -i rebuild=0
declare -i run_kubechart=0
declare -i run_oschart=0
declare -i wait_for_complete=1
declare -i worker_count=0
declare -i host_prefix_bits=23
declare api_version=v1
declare cleanup_only_dir=
declare config_file=
declare console_route=
declare ext_installer=
declare -r -i default_kubechart_port=3000
declare kubechart_port=
declare loglevel=
declare oschart_port=
declare release_source=
declare run_command=
declare masterconffile=
declare masterconfdata=
declare workerconffile=
declare workerconfdata=
declare platformconffile=
declare platformconfdata=
declare -a options_to_process=()
declare -A option_registrations=()

function print_help() {
    cat <<EOF
Usage: $___topsc [options] [install_type]
    install_type: one of
$(do_platforms help install_types | indent 7)
    Options (all are processed in order):
       -p profile           Read the specified profile file.  Profile
                            may be a JSON file or shell code.
       -X option=value      Set the specified extended option.
       -H                   Print list of additional extended command
                            line options.

    Options listed as -a/-A are inverted by the second listed option.
       -b/-B                Launch kubechart and oschart (if available).
                            See https://github.com/sjenning/kubechart
                            KEY: run_kubechart (default=0)
       -c/-C                Clean install cache, in case it is corrupted.
                            KEY: clean_install_cache (default=0)
       -d install_dir       Use the specified dir as working directory and
                            cluster name.  Default is ${LOGNAME:-}-<platform>.
       -l/-L                Don't clean up on exit.  You can exit with status
                            77 for no cleanup or 88 to force cleanup.
                            KEY: do_cleanup (default=1)
       -n release_channel   Use the specified release channel.
       -O/-o                Allow overwrite an existing install directory.
                            KEY: overwrite (default=0)
       -u/-U                Query for release (and optionally channel) to use.
                            KEY: query (default=0)
       -V install_version   Install the specified image version (default
                            latest).  Use '$___topsc -H' for more details.
       -v/-q                Print debug information.
                            KEY/VALUE: loglevel='--log-level=debug'
       -x cleanup_only_dir  Only clean up (requires cluster already exists).
       -y/-Y                Do not prompt prior to starting install
                            KEY: noconfirm (default=0)
EOF
}

function help() {
    [[ -n ${1:-} ]] && echo "$___topsc: Unknown option $1"
    print_help
    exit 1
}

function help_extended() {
    print_help
    cat <<EOF

    Other options with no short command line option (with -X):
      Generic cluster configuration:
        host_prefix_bits    Use the specified host prefix size (default $host_prefix_bits,
                            must be between 8 and 24)
        master_count        Use the specified number of master nodes.
                            Default by platform.
        masterconfdata      Specify the data for master configuration.
        masterconffile      Take master platform config from specified file.
        platformconfdata    Specify the data for platform configuration.
        platformconffile    Take platform configuration from specified file.
        worker_count        Use the specified number of worker nodes.
                            Default by platform.
        workerconfdata      Specify the data for worker configuration.
        workerconffile      Take master platform config from specified file.
$(do_platforms help options |indent -6)

      Installation options:
        config_file         Use the specified file as the install config file.
        do_login            Login to the console (default=1)
        ext_installer       Use the specified command to install OpenShift.
        force_postinstall   Always run the postinstall even if setup fails.
        install_domain      Use the specified domain name.
$(do_platforms help default_domain | indent -28)
        install_version     Install the specified image version.  Default
                            is to use the latest version.
                            Use empty value to install from local workspace
                            (\$GOPATH/src/github.com/openshift/installer)
        install_type        Specify the install type, as described above.
        kubechart_port      Use the specified port for kubechart.  oschart
                            runs at port+1.  Implies -b.  Default is ${default_kubechart_port}.
        pubkey_file         Specify the path to the desired public key
                            Default $pubkey_file
        pull_secret         Specify the path to the pull secret.
                            Default $pull_secret
        rebuild             Always rebuild the installer, when using local
                            installer.
        repo                Use the specified repo (default $default_repo_base).
        run_command         Run the specified command rather than an
                            interactive shell on completion of installation.
        wait_for_complete   Wait for console to come online (default=1)

    The following extended options are normally not recommended:
       api_version          Use the specified API version (default $api_version).
       do_override          Override install image.
       force_local_tools    Use the local toolchain to install with.
EOF
    exit 1
}

################################################################
### Utilities						     ###
################################################################

function clear_env() {
    local var
    for var in "${!_OPENSHIFT_INSTALL@}" "${!OPENSHIFT_INSTALL@}" KUBECONFIG ; do unset "$var"; done
}

function printerval() {
    local milestone=$1
    local interval=$2
    echo -n "$milestone took "
    local h=$((interval / 3600))
    (( h > 0 )) && echo -n "$h:"
    printf "%02d:%02d\n" $(((interval % 3600) / 60)) $((interval % 60))
}

function set_diagnostic() {
    local diagnostic_id="$1"
    local print_diagnostic_message_func="$2"
    global_diagnostics["$diagnostic_id"]="$print_diagnostic_message_func"
}

function _timestamp() {
    while read -r REPLY ; do
	do_platforms diagnose "$REPLY"
	# Make the message look vaguely Go-like.
	printf 'T0000 %(%H:%M:%S)T.000000   %s\n' -1 "$REPLY"
    done
}

function timestamp() {
    if [[ -n "$*" ]] ; then
	_timestamp <<< "$*"
    else
	_timestamp
     fi
}

function tsec() {
    printf "%(%s)T" -1
}

function indent() {
    local -i depth=${1:-2}
    local -i always_indent=0
    if (( depth < 0 )) ; then
	depth=$((-depth))
	always_indent=1
    fi
    # shellcheck disable=SC2155
    local sol=$(printf "%${depth}s" '')
    while IFS='' read -r line ; do
	[[ always_indent -eq 0 && -z $line ]] || echo "$sol$line"
    done
}

function cmdline_replicas() {
    local node_type=$1
    local default=$2
    local actual=0
    case "$node_type" in
	master) actual=$master_count ;;
	worker) actual=$worker_count ;;
	*)                           ;;
    esac
    (( actual == 0 )) && actual=$default
    echo "$actual"
}

function dispatch_unknown() {
    local platform=$1
    shift
    die "Unexpected command ($platform): $*"
}

# The exact operation of the ssh-bastion varies between platforms, and
# isn't supported by everything (e. g. libvirt).
function do_create_bastion() {
    echo "Creating bastion host"
    curl -s -S https://raw.githubusercontent.com/eparis/ssh-bastion/master/deploy/deploy.sh | bash
    # shellcheck disable=SC2181
    if (( $? )) ; then
	echo "Create bastion host failed"
    else
	echo "Alternatively, you may prefer to use ${___topdir:-}bastion-ssh"
	# shellcheck disable=SC2155
	export OPENSHIFT_BASTION_ADDRESS="$(oc get service -n openshift-ssh-bastion ssh-bastion -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')"
	[[ -z $OPENSHIFT_BASTION_ADDRESS ]] && echo "Unable to find bastion address!"
    fi
}

function add_platform() {
    if [[ -z ${_____current_platform:-} ]] ; then
	fatal "Attempt to add a platform outside of its definition"
    fi
    local -r dispatch=$1
    local plat
    for plat in "${!global_platforms[@]}" ; do
	if [[ $_____current_platform = "$plat" ]] ; then return; fi
    done
    global_platforms[$_____current_platform]=$dispatch
}

function __list_instance_types() {
    local -i list_all=0
    local cmd=$1
    local list_option_name=$2
    local split_instance_func=$3
    shift 3
    while read -r REPLY ; do
	echo "$REPLY"
    done
    if [[ $cmd = list_all ]] ; then
	list_all=1
    else
	echo "Use '$___topsc -X $list_option_name=list-all' to list all instance types."
    fi
    echo
    local last_class=
    local -i tot_cols=0
    local -i groups_printed=0
    # shellcheck disable=SC2155
    local -i term_width=$(tput cols 2>/dev/null)
    local i
    local -i c=0
    local -i s=0
    # Find the widest class name and instance name
    for i in "$@" ; do
	case "$i" in
	    X.*)
		(( list_all == 0 && groups_printed++ )) && break
		;;
	    Y*|Z*)
		;;
	    *)
		read -r class subinstance <<< "$("$split_instance_func" "$i")"
		if (( ${#class} > c )) ; then
		    c=${#class}
		fi
		if (( ${#subinstance} > s )) ; then
		    s=${#subinstance}
		fi
		;;
	esac
    done
    c=$((c+1))
    local -i s1=$((s+1))
    groups_printed=0
    for i in "$@" ; do
	case "$i" in
	    X.*)
		(( list_all == 0 && groups_printed++ )) && break
		echo -en "${last_class:+\n\n}${i#X.}:"
		;;
	    Y.*)
		echo -ne "\n ${i#*.}"
		;;
	    Z.*)
		echo -ne " ${i#*.}"
		;;
	    *)
		local class=
		local subinstance=
		read -r class subinstance <<< "$("$split_instance_func" "$i")"
		if [[ $class = "$last_class" ]] ; then
		    tot_cols+=$s1
		    if (( term_width > $((c+s+6)) && tot_cols > (term_width - s) )) ; then
			printf "\n %${c}s  %-${s}s" '' "$subinstance"
			tot_cols=$((c+2))
		    else
			printf " %-${s}s" "$subinstance"
		    fi
		else
		    tot_cols=$((c+2))
		    printf "\n  %-${c}s %-${s}s" "$class:" "$subinstance"
		    last_class=$class
		fi
		;;
	esac
    done
    echo
}

function _list_instance_types() {
    while IFS= read -r line ; do
	line=${line## }
	echo "$line"
    done <<< "$(__list_instance_types "$@")"
}

function _check_instance_type() {
    local instance_type=$1
    local platform=$2
    local list_option_name=$3
    local split_instance_func=$4
    shift 4
    [[ -z ${instance_type:-} ]] && return 0
    local i
    for i in "$@" ; do
	[[ $i = "$instance_type" ]] && return 0
    done
    echo "*** WARNING: '$instance_type' is not a currently known $platform instance type!"
    local class=
    local subinstance=
    read -r class subinstance <<< "$("$split_instance_func" "$instance_type")"
    # shellcheck disable=SC2155
    local -i term_width=$(tput cols 2>/dev/null)
    local -i tot_cols=0
    local j=0
    for i in "$@" ; do
	local iclass=
	local isubinstance=
	# shellcheck disable=SC2034
	read -r iclass isubinstance <<< "$("$split_instance_func" "$i")"
	if [[ $class = "$iclass" ]] ; then
	   (( j++ )) || echo "Possible candidates:"
	   if (( term_width > 20 && tot_cols > (term_width - 5) )) ; then
	       echo
	       tot_cols=0
	   fi
	   echo -n " $i"
	   tot_cols=$((tot_cols + ${#i} + 1))
	fi
    done
    echo -e '\n'
    if (( j )) ; then
	return 1
    else
	return 2
    fi
}

function validate_instance_type() {
    local worker_type=$1
    local master_type=$2
    local platform=$3
    local list_option_name=$4
    local split_instance_func=$5
    shift 5
    if [[ $master_type = list-all || $worker_type = list-all ||
	      $master_type = list_all || $worker_type = list_all ]] ; then
	_list_instance_types list_all "$list_option_name" "$split_instance_func" "$@"
	exit
    fi
    if [[ $master_type = list || $worker_type = list ]] ; then
	_list_instance_types list "$list_option_name" "$split_instance_func" "$@"
	exit
    fi
    local need_to_list_instance_types=0
    _check_instance_type "$master_type" "$platform" "$list_option_name" "$split_instance_func" "$@"
    (( $? == 2 )) && need_to_list_instance_types=1
    _check_instance_type "$worker_type" "$platform" "$list_option_name" "$split_instance_func" "$@"
    (( $? == 2 )) && need_to_list_instance_types=1
    (( need_to_list_instance_types )) && _list_instance_types list "$list_option_name" "$split_instance_func" "$@"
    return 0
}

function platform_dispatch() {
    if [[ $1 = -p ]] ; then
	shift
	local platform=$1
	shift
	if [[ -z ${global_platforms[$platform]:-} ]] ; then
	    fatal "Platform $platform not found"
	fi
	"${global_platforms[$platform]}" "$@"
    elif [[ -n ${OPENSHIFT_INSTALL_PLATFORM:-} ]] ; then
	"${global_platforms[$OPENSHIFT_INSTALL_PLATFORM]}" "$@"
    else
	local -i status=0
	local platform
	for platform in "${!global_platforms[@]}" ; do
	     "${global_platforms[$platform]}" "$@" || status=1
	done
	return $status
    fi
}

function do_platforms() {
    OPENSHIFT_INSTALL_PLATFORM='' platform_dispatch "$@"
}

function find_first_platform() {
    local platform
    for platform in "${!global_platforms[@]}" ; do
	if platform_dispatch -p "$platform" "$@" ; then
	    echo "$platform"
	    return 0
	fi
    done
    return 1
}

function cleanup() {
    (( cleanup_run )) && exit
    (( !clean_shutdown  && install_stage >= 2 )) && echo -en '\n*** '
    case "$install_stage" in
	0) ;;
	1)
	    [[ -n $srcdir && -n $install_dir && -d "$srcdir/$install_dir" ]] && rm -rf "${srcdir:?}/${install_dir:?}"
	    ;;
	*)
	    echo "Cleaning up, please do not interrupt"
	    if (( do_cleanup )) ; then
		# Shut up some very uninteresting noise
		exec 3>&2 2>/dev/null
		if (( created_kubechart )) ; then
		    kill -9 %run_kubechart
		    wait %run_kubechart
		fi
		if (( created_oschart )) ; then
		    kill -9 %run_oschart
		    wait %run_oschart
		fi
		exec 2>&3 3>&-
		# shellcheck disable=SC2086
		"${install}" $loglevel "--dir=$srcdir/$install_dir" destroy cluster 2>&1 |timestamp
		if (( PIPESTATUS[0] == 0 || clean_install_cache)) ; then
		    [[ -n $srcdir && -n $install_dir && -d "$srcdir/$install_dir" ]] && rm -rf "${srcdir:?}/${install_dir:?}"
		else
		    echo "$install --dir=$srcdir/$install_dir destroy cluster failed, not removing install dir!"
		fi
		platform_dispatch cleanup
	    else
		cat 1>&2 <<EOF
*** Not cleaning up!
*** When you are finished, run:

"${install}" $loglevel "--dir=$srcdir/$install_dir" destroy cluster
EOF
	    fi
	    ;;
    esac
    cleanup_run=1
    exit
}

function platform_data() {
    local what=${1:-}
    local data=${2:-}
    local file=${3:-}
    local -i indent=${4:-0}
    local platform_code
    if [[ -n $data ]] ; then
	platform_code="$data"
    elif [[ -n $file && -r $file ]] ; then
	platform_code="$(< "$file")"
    else
	platform_code=${what:+$(platform_dispatch "$what")}
    fi
    if [[ -z $platform_code ]] ; then
	echo '{}'
    else
	echo
	indent "$indent" <<< "$platform_code"
    fi
}

# This has the problem that the install config format can change and
# we're left chasing it.  But much of the idea of this script is that
# people not have to run the installer interactively.
function template() {
    sed -e 's/[ \t]*$//' -e '/^$/d' <<EOF
apiVersion: $api_version
baseDomain: $(platform_dispatch base_domain)
compute:
- hyperthreading: Enabled
  name: worker
  platform: $(platform_data worker "${workerconfdata:-}" "${workerconfdata:-}" 4)
  replicas: $(platform_dispatch replicas worker)
controlPlane:
  hyperthreading: Enabled
  name: master
  platform: $(platform_data master "${masterconfdata:-}" "${masterconfdata:-}" 4)
  replicas: $(platform_dispatch replicas master)
metadata:
  creationTimestamp: null
  name: $OPENSHIFT_INSTALL_CLUSTER_NAME
networking:
  clusterNetwork:
  - cidr: 10.128.0.0/14
    hostPrefix: $host_prefix_bits
  machineCIDR: $(platform_dispatch machine_cidr)
  networkType: OpenShiftSDN
  serviceNetwork:
  - 172.30.0.0/16
platform: $(platform_data platform "${platformconfdata:-}" "${platformconfdata:-}" 4)
pullSecret: '$(jq -scM '.[0]' < "$pull_secret")'
sshKey: |
  $(< "$pubkey_file")
EOF
}

# Use this to determine whether we need some particular workaround.
# Most of the time it will be more problematic than it's worth to
# do something like this, but occasionally we may need to
# temporarily.
function git_newer_than() {
    local -l rev="$1"
    git rev-parse -q --verify "$rev" -- >/dev/null 2>&1 || return 1
    [[ -n $(git rev-list "@..$(git rev-parse "$rev")") ]]
}

function wait_and_run() {
    until [[ -f $KUBECONFIG ]] ; do sleep 1; done
    cmd=${1##*/}
    echo "Starting $cmd..." | timestamp
    if [[ $loglevel = '--log-level=debug' ]] ; then
	exec "$@"
    else
	exec "$@" >/dev/null 2>&1
    fi
}

# We need actual commands/functions named run_kubechart and run_oschart with
# known names, so that they can be waited for.
function run_kubechart() {
    wait_and_run "$kubechart" ${kubechart_port:+--http-port "$kubechart_port"}
}

function run_oschart() {
    wait_and_run "$oschart" ${oschart_port:+--http-port "$oschart_port"}
}

function run_shell() {
    cd "$owd" || fatal "Cannot cd to $owd"
    if [[ -n $run_command ]] ; then
	exec "$SHELL" -c "$run_command"
    else
	if (( do_cleanup )) ; then
	    timestamp "Spawning interactive shell.  Exit with status 77 to suppress cleanup."
	else
	    timestamp "Spawning interactive shell.  Exit with status 88 to clean up."
	fi
	exec "$SHELL" -i
    fi
}

function warn_authentication_failure() {
cat <<\EOF
* You need to download your pull secrets.

  Visit https://try.openshift.com and log in.  Click on Create
  Cluster/Self-Installed Cluster
  (https://cloud.redhat.com/openshift/install) and select your
  appropriate cloud platform.  From there, select User-Provisioned
  Infrastructure.  Download your pull secret and place it in ~/Downloads.

* You need an appropriate quay.io credential.

  Get the required key from
  https://access.redhat.com/solutions/3533201.  Add the auth for
  quay.io to your ~/.docker/config.json and ~/Downloads/pull-secret.

* You need to oc login (or periodically refresh your login).  All
  three steps must be performed.  Not doing this can lead to very
  strange errors; see https://bugzilla.redhat.com/show_bug.cgi?id=1647479.

  + Go to https://api.ci.openshift.org/ and in the upper right corner
    you will see the '?'.  Dropdown to Command Line Tools that will
    give you an 'oc login' command to run from a command line.

  + Run 'oc registry login'.

  + This will generate or update additional secrets in
    ~/.docker/config.json; these need to be copied into
    ~/Downloads/pull-secret.  In particular, the secret for
    registry.svc.ci.openshift.org will change.

* Ensure that you have correct credentials for your cloud platform,
  as appropriate.
EOF
}

function warn_installer_fail() {
    cat <<\EOF
Could not extract installer from image.  Common reasons:

* You've specified an installer version that does not exist (even if
  you've used the query option).  This will fail quickly with a
  clear error message.

EOF
    warn_authentication_failure
}

function fail_installer_extract() {
    local image=$1
    warn_installer_fail
    fatal "Cannot extract openshift-install from image $image"
}

function fail_find_image() {
    local install_version=$1
    warn_installer_fail
    fatal "Can't find image for version $install_version"
}

# This should run in a subshell to not change the current directory
function do_installer_setup() {
    local install_dir=$1
    local image=$2
    local install_version=$3
    cd "$install_dir" || exit 1
    for f in "openshift-"*".tar.gz" ; do
	rm -f "$f"
    done
    "${OC}" adm release extract --tools "${image}" || fail_installer_extract "$image"
    for f in "openshift-"*".tar.gz" ; do
	echo "Extracting $f"
	tar xf "$f" || fail_installer_extract "$image"
    done
    [[ -f openshift-install ]] || fail_installer_extract "$image"
    chmod +x openshift-install
    echo "${install_version}" > version.txt
}

function installer_setup() {
    local not_latest=1
    local release_data
    local image
    local release_source=${OPENSHIFT_RELEASE_SOURCE:-https://${repo}.svc.ci.openshift.org/api/v1/releasestream}
    local installer_registry=${OPENSHIFT_INSTALL_REGISTRY:-registry.svc.ci.openshift.org/${subdir_map[$repo]:-}/release}
    #release_channel=${release_channel:-${release_base_map[$repo]:-}}
    if (( query )) ; then
	if [[ -z ${release_channel:-} ]] ; then
	    local -a channels=()
	    readarray -t channels <<< "$(openshift-release-info -B "$repo" channels < /dev/null | sort -r)"
	    OPS3=${PS3:-}
	    PS3="Select channel: "
	    select release_channel in "${channels[@]}" ; do break; done
	    PS3=$OPS3
	fi
	local -a versions=()
	readarray -t versions <<< "$(openshift-release-info -B "$repo" ${release_channel:+-c "$release_channel"} releases < /dev/null | sort -r)"
	OPS3=${PS3:-}
	PS3="Select release: "
	select install_version in "${versions[@]}" ; do break; done
	PS3=$OPS3
    elif [[ $install_version = latest ]] ; then
	not_latest=
	release_channel=${release_channel:-${release_base_map[$repo]:-}}
	echo "Retrieving release data from $release_source/$release_channel/latest"
	release_data="$(curl --silent "$release_source/$release_channel/latest")"
	[[ -n $release_data ]] || fatal "Can't extract release data!"
	install_version="$("$JQ" -r '.name' <<< "$release_data")"
	[[ -n $install_version ]] || fatal "Can't extract install version!"
    fi
    echo "Using version $install_version${not_latest:- (latest)}" 1>&2
    local -r pullspec="$installer_registry:$install_version"
    image=$(${OC} adm release info --pullspecs "$pullspec" | awk '{if ($1 == "Pull") {print $3}}')
    [[ -z $image ]] && fail_find_image "$install_version"
    if (( ! force_local_tools )) ; then
	echo "Using installer from image ${image} ($ext_installer)" 1>&2
	(do_installer_setup "$install_dir" "$image" "$install_version") || exit 1
	ext_installer="${install_dir}/openshift-install"
	install="$ext_installer"
	echo -e "installer version:\n$("$ext_installer" version |sed 's/^/    /')\n" 1>&2
    fi
    srcdir=.
    if [[ $do_override = 1 && -n $not_latest ]] ; then
	export OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE=$pullspec
	export _OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE=$pullspec
    fi
}

# Try to catch obvious failures
function validate_environment() {
    [[ -n $masterconffile && ! -r $masterconffile ]] &&
	fatal "Master platform config $masterconffile not readable"
    [[ -n $workerconffile && ! -r $workerconffile ]] &&
	fatal "Worker platform config $workerconffile not readable"
    [[ -n $platformconffile && ! -r $platformconffile ]] &&
	fatal "Platform config $platformconffile not readable"
    (( host_prefix_bits < 8 || host_prefix_bits > 23 )) &&
	fatal "Host prefix size must be between 8 and 23"
    local f
    for f in quay.io registry.redhat.io registry.svc.ci.openshift.org ; do
	local g=${f//./\\.}
	grep -q "$g" "$pull_secret" || warn "No secret for '$f' in pull secret $pull_secret; expect installation to fail"
    done
    platform_dispatch validate
}

function confirm_install() {
    cat <<EOF
About to run installer:

Installer:         $install
Sourcedir:         $srcdir$([[ $srcdir != /* ]] && echo " ($(cd "$srcdir" && pwd))")
Install dir:       $srcdir/$install_dir
Current dir:       $(pwd)
Install version:   $install_version
Override:          ${OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE:-}
Install command:   ${install} $loglevel --dir="$srcdir/$install_dir" create cluster
Configuration:

$OPENSHIFT_INSTALL_CONFIG
EOF
    (( noconfirm )) && return 0
    local proceed
    echo
    while : ; do
	read -p "Proceed? [YnevV!?] " -r proceed
	case "$proceed" in
	    y|Y|yes|YES|Yes|'')
		break
		;;
	    n|N|no|NO|No)
		echo "Not confirmed"
		return 1
		;;
	    '!')
		echo "Spawning shell..."
		"$SHELL" -i
		;;
	    e|E|edit|EDIT|Edit)
		echo "Editing config..."
		${EDITOR:-vi} "$srcdir/$install_dir/install-config.yaml"
		;;
	    V)
		env
		;;
	    v)
		set
		;;
	    '?')
		echo 'y   Proceed with installation'
		echo 'n   Do not proceed with installation'
		echo '!   Spawn shell'
		echo 'V   Print environment'
		echo 'v   Print all variable settings'
		echo 'e   Edit install-config.yaml'
		echo '?   Print this help'
		echo 'Abort installation with any other input'
		;;
	    *)
		;;
	esac
    done
    return 0
}

function start_kubechart_if_requested() {
    [[ -n $kubechart_port ]] && run_kubechart=1
    local run_oschart="$run_kubechart"
    if [[ -n $run_kubechart ]] ; then
	kubechart_port=${kubechart_port:-${default_kubechart_port}}
	oschart_port=$((kubechart_port+1))
    fi
    if [[ -x $kubechart && $run_kubechart -gt 0 ]] ; then
	created_kubechart=1
	run_kubechart&
	export OPENSHIFT_INSTALL_KUBECHART_URL=http://localhost:$kubechart_port/
    fi
    if [[ -x $oschart && $run_oschart -gt 0 ]] ; then
	created_oschart=1
	run_oschart&
	export OPENSHIFT_INSTALL_OSCHART_URL=http://localhost:$oschart_port/
    fi
}

function clean_secret() {
    local min_indent_prefix=
    while IFS= read -r line ; do
	if [[ -n $min_indent_prefix ]] ; then
	    if [[ $line = "${min_indent_prefix}"* ]] ; then
		continue
	    else
		min_indent_prefix=
	    fi
	fi
	if [[ $line =~ (( *)(sshKey: |pullSecret: ))([|]|.*) ]] ; then
	    [[ ${BASH_REMATCH[4]} = '|' ]] && min_indent_prefix="${BASH_REMATCH[2]} "
	    echo "${BASH_REMATCH[1]}..."
	else
	    echo "$line"
	fi
    done
    return 0
}

function oc_login() {
    local retry_limit=20
    local try=0
    while (( try++ < retry_limit )) ; do
	echo -n "Login (try $try/$retry_limit)..."
	if ${OC} login -u kubeadmin -p "${OPENSHIFT_INSTALL_PASSWORD:-}" ; then
	    echo "success!"
	    return 0
	fi
	echo "failed."
	(( try < retry_limit )) && sleep 30
    done
    echo "Login failed."
    return 1
}

function waitfor_console() {
    local retry_limit=20
    local try=0
    while (( try++ <= retry_limit )) ; do
	echo -n "Get console route (try $try/$retry_limit)..."
	if ${OC} get route -n openshift-console -o name |grep -q '/console$' ; then
	    echo "success!"
	    return 0
	fi
	echo "failed."
	(( try < retry_limit )) && sleep 30
    done
    echo "Unable to get console route."
    return 1
}

function report_install_failure() {
    local diagnostic_id
    for diagnostic_id in "${!global_diagnostics[@]}" ; do
	"${global_diagnostics[$diagnostic_id]}" "$diagnostic_id"
    done
    warn_authentication_failure
}

function run_postinstall() {
    if [[ -f "${srcdir}/${install_dir}/auth/kubeadmin-password" ]] ; then
	# shellcheck disable=SC2155
	export OPENSHIFT_INSTALL_PASSWORD=$(< "${srcdir}/${install_dir}/auth/kubeadmin-password")
	if (( ! do_login )) ; then
	    echo "oc login skipped"
	elif oc_login ; then
	    login_succeeded=1
	    console_route=
	else
	    echo "oc login failed!"
	fi
    fi

    platform_dispatch postinstall

    if (( wait_for_complete && login_succeeded )) ; then
	echo -n "Waiting for console to come on line..."
	if "${___topdir:-}waitfor-pod" -r 10 console && waitfor_console ; then
	    console_route="$(${OC} get route -n openshift-console -o "custom-columns=HOST:.status.ingress[0].host" --no-headers=true |grep ^console)"
	    if [[ -n $console_route && $console_route != '<none>' ]] ; then
		export OPENSHIFT_INSTALL_CONSOLE_ROUTE="https://$console_route"
		echo "Console route: $OPENSHIFT_INSTALL_CONSOLE_ROUTE"
		(xdg-open "$OPENSHIFT_INSTALL_CONSOLE_ROUTE" </dev/null >/dev/null 2>&1 &)
	    fi
	fi
	echo "login: kubeadmin / $OPENSHIFT_INSTALL_PASSWORD"
    fi
    # shellcheck disable=SC2155
    export OPENSHIFT_INSTALL_NODE_IPS=$("${___topdir:-}"get-nodes)
    # shellcheck disable=SC2155
    export OPENSHIFT_INSTALL_WORKER_NODES=$(oc get nodes -l node-role.kubernetes.io/worker --no-headers=true -o name|sed -e 's,node/,,')
    # shellcheck disable=SC2155
    export OPENSHIFT_INSTALL_MASTER_NODES=$(oc get nodes -l node-role.kubernetes.io/master --no-headers=true -o name|sed -e 's,node/,,')
}

function run_install() {
    validate_environment
    if [[ -z $cleanup_only_dir ]] ; then
	[[ -n $install_version ]] && srcdir=.
	mkdir -p "$srcdir/$install_dir"
	[[ -n $install_version ]] && installer_setup
	if [[ -n $config_file ]] ; then
	    [[ ! -r $config_file ]] && fatal "Cannot read config file $config_file"
	    cp "$config_file" "$srcdir/$install_dir/install-config.yaml"
	else
	    template > "$srcdir/$install_dir/install-config.yaml"
	fi
    fi
    # shellcheck disable=SC2155
    export KUBECONFIG="$(cd $srcdir && echo "$(pwd)/$install_dir/auth/kubeconfig")"

    # We will need the installer even in cleanup-only mode,
    # in order to clean up the cluster.
    local -i rebuild_installer=0
    if [[ -z $ext_installer ]] ; then
	cd $srcdir || fatal "Can't cd to $srcdir"
	local -r cur_rev=$(git rev-parse @)
	[[ ! -x $install || $rebuild -gt 0 || $(${install} version) =~ $cur_rev ]] && rebuild_installer=1
    else
	srcdir=.
    fi

    # shellcheck disable=SC2155
    local start=$(tsec)
    trap cleanup EXIT SIGHUP SIGINT SIGQUIT SIGTERM

    install_stage=1
    OPENSHIFT_INSTALL_CONFIG="$(clean_secret < "$srcdir/$install_dir/install-config.yaml")"
    export OPENSHIFT_INSTALL_CONFIG
    confirm_install || exit 1

    # Not platform-independent
    if (( rebuild_installer )) ; then
	echo "Rebuilding installer"
	TAGS=libvirt hack/build.sh || fatal "Can't rebuild installer"
    fi

    install_stage=2
    # Start kubechart/oschart (if needed) prior to running the installer
    start_kubechart_if_requested

    echo
    # shellcheck disable=SC2086
    "${install}" $loglevel "--dir=$srcdir/$install_dir" create cluster </dev/null 2>&1 | timestamp

    local install_status=${PIPESTATUS[0]}
    # shellcheck disable=SC2155
    local -i end1=$(tsec)
    local -i end2=0

    if (( install_status )) ; then
	report_install_failure
	clean_shutdown=0
    fi
    if (( force_postinstall || !install_status )) ; then
	run_postinstall
	end2=$(tsec)
    fi
    printerval "Installation" $((end1 - start))
    (( end2 )) && printerval "Total setup to console online" $((end2 - start))
    export OPENSHIFT_INSTALL_INTERLOCK=1
    export OPENSHIFT_INSTALL_VERSION=$install_version
    for f in "${!OPENSHIFT@}" "${!_OPENSHIFT@}" KUBECONFIG ; do eval "echo export $f=\${$f@Q}"; done > "${srcdir}/${install_dir}/environment"
    # Run a shell even if setup failed, so it's possible to poke around
    (run_shell)
    case $? in
	77) do_cleanup=0 ;;
	88) do_cleanup=1 ;;
	*)               ;;
    esac
    clean_shutdown=1
}

function read_profile() {
    local profile="$1"
    if [[ ! -r $profile ]] ; then
	fatal "Can't read profile $profile"
    fi
    local value
    if [[ $profile = *.json ]] ; then
	while read -r key <<<"$(jq -r 'keys[]' "$profile")" ; do
	    value="$(jq -r ".\"$key\"" "$profile")" || fatal "Cannot process $key"
	    eval "key=\"$value\"" || fatal "Cannot process $key=$value"
	done
    else
	# shellcheck source=/dev/null
	. "$profile" || fatal "Cannot process profile $profile"
    fi
}

function process_option() {
    options_to_process+=("$1")
}

function register_options() {
    if [[ -z ${_____current_platform:-} ]] ; then
	fatal "Attempt to register options outside of platform definition"
    fi
    local opt
    for opt in "$@" ; do
	option_registrations[$opt]=$_____current_platform
    done
}

function process_options() {
    while getopts ":BbCcd:HhLln:Oop:qUuV:vX:xYy" opt ; do
	case "$opt" in
	    B) run_kubechart=0		    ;;
	    b) run_kubechart=1		    ;;
	    C) clean_install_cache=0	    ;;
	    c) clean_install_cache=1	    ;;
	    d) install_dir="$OPTARG"        ;;
	    L) do_cleanup=1		    ;;
	    l) do_cleanup=0		    ;;
	    n) release_channel="$OPTARG"    ;;
	    O) overwrite=1                  ;;
	    o) overwrite=0                  ;;
	    p) read_profile "$OPTARG"       ;;
	    q) loglevel=		    ;;
	    U) query=0                      ;;
	    u) query=1                      ;;
	    V) install_version="$OPTARG"    ;;
	    v) loglevel='--log-level=debug' ;;
	    X) process_option "$OPTARG"     ;;
	    x) cleanup_only_dir="$OPTARG"   ;;
	    Y) noconfirm=0		    ;;
	    y) noconfirm=1		    ;;
	    H) help_extended		    ;;
	    h) help			    ;;
	    *) help "$OPTARG"               ;;
	esac
    done

    shift $((OPTIND - 1))

    if [[ -n ${1:-} ]] ; then
	install_type="$1"
	shift
    fi

    [[ -z "$*" ]] || echo "Warning: extraneous arguments $# after $install_type will be ignored!" 1>&2
}

function process_extended_options() {
    local option
    local optname
    local optvalue
    for option in "${options_to_process[@]}" ; do
	optname=${option%%=*}
	optvalue=${option#*=}
	if [[ -n "${option_registrations[$optname]:-}" ]] ; then
	    if [[ ${option_registrations[$optname]} = "$OPENSHIFT_INSTALL_PLATFORM" ]] ; then
		platform_dispatch set_option "$optname" "$optvalue"
	    else
		echo "Option $optname does not exist for platform $OPENSHIFT_INSTALL_PLATFORM"
	    fi
	else
	    eval "$option"
	fi
    done
}

function find_platforms() {
    local -a _____platform_path
    local -a _____new_vars
    local -A _____var_map
    local _____a
    local _____f
    local _____dir
    if [[ -n ${OPENSHIFT_OINST_LIBDIR:-} ]] ; then
	readarray -t _____platform_path <<< "${OPENSHIFT_OINST_LIBDIR//:/$'\n'}"
    fi
    _____platform_path+=("$___topdir")
    for _____dir in "${_____platform_path[@]}" ; do
	_____dir=${_____dir:-.}
	if [[ -d "$_____dir/share/OpenShift/installer/platforms" ]] ; then
	    for _____f in "$_____dir/share/OpenShift/installer/platforms"/* ; do
		local -i _____warned_platvar=0
		_____current_platform=${_____f##*/}
		if [[ -z ${global_platforms[$_____current_platform]:-} && $_____current_platform != "."* && $_____current_platform != *"~" && $_____current_platform != '#'* && -f $_____f ]] ; then
		    _____new_vars=()
		    _____var_map=()
		    while read -r _____a ; do
			_____var_map[$_____a]=1
		    done <<< "$(compgen -v; compgen -c)"
		    unset _____a
		    # shellcheck disable=SC1090
		    . "$_____f"
		    readarray -t _____new_vars <<< "$(compgen -v; compgen -c)"
		    for _____a in "${_____new_vars[@]}" ; do
			if [[ -z ${_____var_map[$_____a]:-} &&
				  $_____a != "_____$_____current_platform"* ]] ; then
			    if ! ((_____warned_platvar)) ; then
				echo "Unexpected variable/function names from $_____current_platform platform defined in"
				echo "${_____f//\/\//\/}"
				echo "Names should be prefixed with _____$_____current_platform"
				_____warned_platvar=1
			    fi
			    echo "    $_____a"
			fi
		    done
		fi
		unset _____current_platform
	    done
	fi
    done
}

# Running nested installs is liable to be problematic
if [[ -n ${OPENSHIFT_INSTALL_INTERLOCK:-} ]] ; then
    if [[ ${1:-} = -h* ]] ; then
	echo "Already in ${___topsc:-oinst} environment!"
	help
    fi
    fatal "Already in ${___topsc:-oinst} environment"
fi

find_platforms
process_options "$@"
clear_env
if [[ -z ${install_type:-} ]] ; then
    for platform in "${!global_platforms[@]}" ; do
	install_type="$(platform_dispatch -p "$platform" default_install_type)"
	[[ -z $install_type ]] || break
    done
fi

OPENSHIFT_INSTALL_PLATFORM="$(find_first_platform is_install_type "$install_type")"

process_extended_options "${options_to_process[@]}"

[[ -n $OPENSHIFT_INSTALL_PLATFORM ]] || help

export OPENSHIFT_INSTALL_PLATFORM
platform_dispatch setup "$install_type"

OPENSHIFT_INSTALL_BASE_DOMAIN=$(platform_dispatch base_domain)
export OPENSHIFT_INSTALL_BASE_DOMAIN

[[ -n $ext_installer ]] && install="$ext_installer"
[[ $install_version = latest_default ]] && install_version=latest
export OPENSHIFT_INSTALL_CLUSTER_NAME=${install_dir:-${LOGNAME:-NOUSER}-${OPENSHIFT_INSTALL_PLATFORM}}

install_dir="${install_dir:-$OPENSHIFT_INSTALL_CLUSTER_NAME}"

if [[ -n $cleanup_only_dir ]] ; then
    if [[ ! -d $install_dir ]] ; then
	echo "No install directory $install_dir to clean up"
	exit 0
    fi
elif [[ -d $install_dir && $install_dir != . && $install_dir != .. &&
	    -n $(ls "$install_dir") && $overwrite -eq 0 ]] ; then
    fatal "Install directory $install_dir already present; will not overwrite without -O"
fi

run_install
