#!/bin/bash

# Copyright 2019 Robert Krawitz/Red Hat
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

function fatal() {
    echo "FATAL: $*" 1>&2
    exit 1
}

set -u

# Find our helpers
function finddir() {
    local path_to_file
    path_to_file=$(readlink -f "$0")
    if [[ -z $path_to_file ]] ; then
	return 1
    elif [[ -d $path_to_file ]] ; then
	echo "$path_to_file/"
    elif [[ -e $path_to_file ]] ; then
	echo "${path_to_file%/*}/"
    else
	return 1
    fi
    return 0
}

declare realsc=
if [[ -z ${___topsc:-} ]] ; then
    export ___topsc="${0##*/}"
    # shellcheck disable=SC2155
    export ___topdir="$(finddir "$0")"
    [[ -z $___topdir ]] && fatal "Can't find directory for $0"
fi

function print_help() {
    cat <<EOF
Usage: $___topsc [options] [install_type]
    install_type: one of
       libvirt (default)
       aws     (aws us-east-1)
       aws2    (aws us-east-2)
       aws3    (aws us-west-1)
       aws4    (aws us-west-2)
       aws-*   (specified AWS region)
    Options:
       -p profile           Read the specified profile file.  Profile
                            may be a JSON file or shell code.
                            Option names are given below.
			    Note that command line options specified
			    after the -p override the profile.
       -X option=value      Evaluate the specified extended option.
       -H                   Print list of additional extended command
                            line options.

       -b                   Launch kubechart and oschart (if available).
                            KEY: run_kubechart (default=0)
       -C cleanup_only_dir  Only clean up (requires cluster already exists).
       -c                   Clean install cache, in case it is corrupted.
                            KEY: clean_install_cache (default=1)
       -d install_dir       Use the specified dir as working directory and
                            cluster name.  Default is ${LOGNAME:-}-<platform>.
       -N                   Don't clean up on exit.  If this is not used,
                            exit with status 77 from the shell will have
                            the same effect.  If this option is used,
                            exit with status 88 will clean up.
                            KEY: do_cleanup (default=1)
       -n release_channel   Use the specified release channel.
                            Default ${release_channel:-current Origin default}.
                            Use 'openshift-release-info channels' to
                            list channels.
       -O                   Allow overwrite an existing install directory.
                            KEY: overwrite (default=0)
       -Q                   Query for release to use.
                            KEY: query (default=0)
       -R repo              Use the specified repo (default $default_repo_base).
       -V install_version   Install the specified image version (default 
                            latest).  Use '$___topsc -H' for more details
                            or to use local installer.
       -v                   Print debug information.
                            KEY/VALUE: loglevel='--log-level=debug'
       -w worker_count      Number of worker nodes (default by platform).
       -x                   Clean up local install cache (in case of corrupt
                            image cache).
                            KEY: clean_install_cache (default=0)
       -y                   Do not prompt prior to starting install
                            KEY: noconfirm (default=0)
EOF
}

function help() {
    [[ -n ${1:-} ]] && echo "$___topsc: Unknown option $1"
    print_help
    exit 1
}

function help_extended() {
    print_help
    cat <<EOF

    Other options with no short command line option (with -X):
      Cluster configuration:
        aws_master_type     Type of master instance (AWS only)
        aws_compute_type    Type of compute instance (AWS only)
        host_prefix_bits    Use the specified host prefix size (default $host_prefix_bits,
                            must be between 8 and 24)
        master_count        Use the specified number of master nodes.
                            Default by platform.
        masterconfdata      Specify the data for master configuration.
        masterconffile      Take master platform config from specified file.
        platformconfdata    Specify the data for platform configuration.
        platformconffile    Take platform configuration from specified file.
        worker_count        Use the specified number of worker nodes.
                            Default by platform.
        workerconfdata      Specify the data for worker configuration.
        workerconffile      Take master platform config from specified file.

      Installation options:
        config_file         Use the specified file as the install config file.
        create_bastion      Create ssh bastion host (default=1)
        do_login            Login to the console (default=1)
        ext_installer       Use the specified command to install OpenShift.
        force_postinstall   Always run the postinstall even if setup fails.
        install_domain      Use the specified domain name.
                            For libvirt: default is taken from a unique entry
                                in /etc/NetworkManager/dnsmasq.d, if available;
                                if not (or there are multiple masqueraded
                                domains), there is no default.
                            For AWS: default is $aws_default_domain.
        install_version     Install the specified image version.  Default
                            is to use the latest version.
                            If this is used, the matching toolchain is
                            also used unless -X is specified.
                            Use 'openshift-release-info releases' or
                            'openshift-release-info -c <channel> releases'
                            to list available versions.
                            Use empty value to install from local workspace
                            (currently hardcoded
                            to \$GOPATH/src/github.com/openshift/installer)
        install_type        Specify the install type, as described above.
        kubechart_port      Use the specified port for kubechart.  oschart
                            runs at port+1.  Implies -b.  Default is 3000.
        pubkey_file         Specify the path to the desired public key
                            Default $pubkey_file
        pull_secret         Specify the path to the pull secret.
                            Default $pull_secret
        rebuild             Always rebuild the installer, when using local
                            installer.
        run_command         Run the specified command rather than an
                            interactive shell on completion of installation.
        wait_for_complete   Wait for console to come online (default=1)

    The following extended options are normally not recommended:
       api_version          Use the specified API version (default $api_version).
       do_override          Override install image.
       force_local_tools    Use the local toolchain to install with.
EOF
    exit 1
}

function list_aws_instance_types_1() {
    cat <<\EOF
Currently known AWS instance types.  Note that not all types are
available in all regions, and AWS may add additional types at
any time.  See https://aws.amazon.com/ec2/instance-types/
for more information.

EOF
    local last_class=
    local i
    for i in "${known_aws_instance_types[@]}" ; do
	case "$i" in
	    X.*)
		echo -en "$  {last_class:+\n\n}${i#X.}:"
		;;
	    Y.*)
		echo -ne "\n    ${i#*.}"
		;;
	    Z.*)
		echo -ne " ${i#*.}"
		;;
	    ${last_class}.*)
		echo -n " ${i#*.}"
		;;
	    *)
		echo -ne "\n    ${i%%.*}: ${i#*.}"
		last_class=${i%%.*}
		;;
	esac
    done
    echo
    exit 1
}

function list_aws_instance_types() {
    list_aws_instance_types_1
    exit 1
}

function check_aws_instance_type() {
    local aws_type="${1:-}"
    [[ -z $aws_type ]] && return 0
    local i
    for i in "${known_aws_instance_types[@]}" ; do
	[[ $i == "$aws_type" ]] && return 0
    done
    echo "*** WARNING: '$aws_type' is not a currently known AWS instance type!"
    local aws_prefix=${aws_type%%.*}
    local j=0
    for i in "${known_aws_instance_types[@]}" ; do
	if [[ $aws_prefix = "${i%%.*}" ]] ; then
	   (( j++ )) || echo "Possible candidates:"
	   echo -n " $i"
	fi
    done
    if (( j )) ; then
	echo
    else
	list_aws_instance_types
    fi
    return 1
}

function clean_startup() {
    [[ -f ${realsc:-} ]] && rm -f "$realsc"
}

# This allows us to edit the script while another instance is running
# since this script sticks around until the user exits the spawned shell.
# It's fine for the running script to be removed, since the shell still
# has its open file descriptor.
if [[ $# == 0 || $1 != "--DoIt=$0" ]] ; then
    tmpsc=$(mktemp)
    [[ -z $tmpsc || ! -f $tmpsc || -L $tmpsc ]] && fatal "Can't create temporary script file"
    trap clean_startup EXIT SIGHUP SIGINT SIGQUIT SIGTERM
    PATH+=${PATH:+:}$___topdir
    cat "$0" > "$tmpsc"
    chmod +x "$tmpsc"
    exec "$tmpsc" "--DoIt=$tmpsc" "$@"
else
    realsc=${1#--DoIt=}
    clean_startup
    shift
fi

# Globals
declare -A release_base_map
release_base_map[origin-release]='4.2.0-0.okd'
release_base_map[openshift-release]='4-stable'

declare -A subdir_map
subdir_map[origin-release]='origin'
subdir_map[openshift-release]='ocp'

declare -r aws_default_domain=devcluster.openshift.com
declare -r kubechart=${KUBECHART:-$GOPATH/src/github.com/sjenning/kubechart/kubechart}
declare -r oschart=${OSCHART:-$GOPATH/src/github.com/sjenning/oschart/oschart}
declare -r default_repo_base=openshift-release

declare install_type=${OPENSHIFT_INSTALL_TYPE:-libvirt}
declare install_domain=${OPENSHIFT_INSTALL_DOMAIN:-}
declare install_dir=${OPENSHIFT_INSTALL_DIR:-$install_domain}
declare install_version=latest_default
declare pull_secret=${OPENSHIFT_INSTALL_PULL_SECRET_PATH:-$HOME/Downloads/pull-secret}
declare pubkey_file=${OPENSHIFT_INSTALL_SSH_PUB_KEY_PATH:-$HOME/.ssh/id_rsa.pub}
declare installer_registry=
declare srcdir=${GOPATH:-$HOME/go}/src/github.com/openshift/installer
declare install=$srcdir/bin/openshift-install
declare release_channel
declare repo=$default_repo_base

# shellcheck disable=SC2155
declare -r OC=$(type -p oc)
[[ -z $OC ]] && fatal "Can't find oc command"
# shellcheck disable=SC2155
declare -r JQ=$(type -p jq)
[[ -z $JQ ]] && fatal "Can't find jq command"
# shellcheck disable=SC2155
declare -r owd=$(pwd)
declare -i clean_install_cache=0
declare -i clean_shutdown=0
declare -i cleanup_run=0
declare -i create_bastion=1
declare -i created_kubechart=0
declare -i created_oschart=0
declare -i created_proxy=0
declare -i do_cleanup=1
declare -i do_login=1
declare -i do_override=0
declare -i force_local_tools=0
declare -i force_postinstall=0
declare -i install_stage=0
declare -i login_succeeded=0
declare -i master_count=0
declare -i noconfirm=0
declare -i overwrite=0
declare -i query=0
declare -i rebuild=0
declare -i run_kubechart=0
declare -i run_oschart=0
declare -i wait_for_complete=1
declare -i worker_count=0
declare -i host_prefix_bits=23
declare api_version=v1
declare aws_compute_type=
declare aws_master_type=
declare cleanup_only_dir=
declare config_file=
declare console_route=
declare ext_installer=
declare kubechart_port=
declare loglevel=
declare oschart_port=
declare release_source=
declare run_command=
declare masterconffile=
declare masterconfdata=
declare workerconffile=
declare workerconfdata=
declare platformconffile=
declare platformconfdata=
declare -ar known_aws_instance_types=("X.General Purpose"
				     m5{,d}.{{,{,2,4,8,12,16}x}large,metal}
				     m4.{,{,2,4,10,16}x}large
				     m5a.{,{2,4,8,12,16,24}x}large
				     t{2,3,3a}.{nano,micro,small,medium,{,x,2x}large}
				     "X.Compute Optimized"
				     c4.{,{,2,4,8}x}large
				     c5.{,{,{,2,4,9,12,18,24}x}large,metal}
				     c5{d,n}.{{,{,2,4,9,18}x}large,metal}
				     r5ad.{,{,2,4,12,24}x}large
				     "X.Memory Optimized"
				     r4.{,{,2,4,8,16}x}large
				     r5a.{,{2,4,8,12,16,24}x}large
				     r5{,d}.{{,{,2,4,8,12,16}x}large,metal}
				     x1e.{,{,2,4,8,16,32}x}large
				     x1.{16,32}xlarge
				     Y.u-6.tb1.metal Z.u-t{9,12}tb1.metal
				     z1d.{{,{,2,3,6,12}x}large,metal}
				     "X.GPU"
				     p3.{2,8,16,24}xlarge
				     p2.{,8,16}xlarge
				     g3s.xlarge g3.{4,8,16}xlarge
				     f1.{2,4,16}xlarge
				     "X.Storage Optimized"
				     i3.{{,{2,4,8,16}x}large,metal}
				     i3n.{{,{2,3,6,12,24}x}large,metal}
				     d2.{,2,4,8}xlarge
				     h1.{2,4,8,16}xlarge)

# Running nested installs is liable to be problematic
if [[ -n ${OPENSHIFT_INSTALL_INTERLOCK:-} ]] ; then
    if [[ ${1:-} == -h* ]] ; then
	echo "Already in ${___topsc:-} environment!"
	help
    fi
    fatal "Already in ${___topsc:-} environment"
fi

# Detect classes of errors and suggest remediation
declare -i api_plugin_incompatibility_detected=0

[[ -z $OC ]] && fatal "Can't find oc command"

function clear_env() {
    local var
    for var in "${!OPENSHIFT_INSTALL@}" ; do unset "$var"; done
    for var in "${!_OPENSHIFT_INSTALL@}" ; do unset "$var"; done
    unset KUBECONFIG
}

function cleanup() {
    (( cleanup_run )) && exit
    (( !clean_shutdown  && install_stage >= 2 )) && echo -en '\n*** '
    case "$install_stage" in
	0) ;;
	1)
	    [[ -n $srcdir && -n $install_dir && -d "$srcdir/$install_dir" ]] && rm -rf "${srcdir:?}/${install_dir:?}"
	    ;;
	*)
	    echo "Cleaning up, please do not interrupt"
	    if (( do_cleanup )) ; then
		# Shut up some very uninteresting noise
		exec 3>&2 2>/dev/null
		if (( created_proxy )) ; then
		    kill -9 %run_proxy
		    wait %run_proxy
		fi
		if (( created_kubechart )) ; then
		    kill -9 %run_kubechart
		    wait %run_kubechart
		fi
		if (( created_oschart )) ; then
		    kill -9 %run_oschart
		    wait %run_oschart
		fi
		exec 2>&3 3>&-
		# shellcheck disable=SC2086
		"${install}" $loglevel "--dir=$srcdir/$install_dir" destroy cluster 2>&1 |timestamp
		if (( PIPESTATUS[0] == 0 || clean_install_cache)) ; then
		    [[ -n $srcdir && -n $install_dir && -d "$srcdir/$install_dir" ]] && rm -rf "${srcdir:?}/${install_dir:?}"
		else
		    echo "$install --dir=$srcdir/$install_dir destroy cluster failed, not removing install dir!"
		fi
	    else
		cat 1>&2 <<EOF
*** Not cleaning up!
*** When you are finished, run:

"${install}" $loglevel "--dir=$srcdir/$install_dir" destroy cluster
EOF
	    fi
	    ;;
    esac
    cleanup_run=1
    exit
}

function printerval() {
    local milestone=$1
    local interval=$2
    echo -n "$milestone took "
    local h=$((interval / 3600))
    (( h > 0 )) && echo -n "$h:"
    printf "%02d:%02d\n" $(((interval % 3600) / 60)) $((interval % 60))
}

function oc_login() {
    local retry_limit=20
    local try=0
    while (( try++ < retry_limit )) ; do
	echo -n "Login (try $try/$retry_limit)..."
	if ${OC} login -u kubeadmin -p "${OPENSHIFT_INSTALL_PASSWORD:-}" ; then
	    echo "success!"
	    return 0
	fi
	echo "failed."
	(( try < retry_limit )) && sleep 30
    done
    echo "Login failed."
    return 1
}

function waitfor_console() {
    local retry_limit=20
    local try=0
    while (( try++ <= retry_limit )) ; do
	echo -n "Get console route (try $try/$retry_limit)..."
	if ${OC} get route -n openshift-console -o name |grep -q '/console$' ; then
	    echo "success!"
	    return 0
	fi
	echo "failed."
	(( try < retry_limit )) && sleep 30
    done
    echo "Unable to get console route."
    return 1
}

function find_libvirt_default_domain() {
    # shellcheck disable=SC2155
    local files=$(find /etc/NetworkManager/dnsmasq.d/ -type f -name '*.conf' -print)
    [[ -z $files ]] && fatal "No dnsmasq files in /etc/NetworkManager/dnsmasq.d"
    local dnsmasq_domain=
    for f in $files ; do
	# shellcheck disable=SC2155
	local data=$(< "$f")
	data=${data#*/}
	data=${data%/*}
	[[ -n $dnsmasq_domain && $data != "$dnsmasq_domain" ]] &&
	    fatal "Multiple domains found in /etc/NetworkManager/dnsmasq.d; pick one"
	[[ -n $data ]] && dnsmasq_domain=$data
    done
    [[ -z $dnsmasq_domain ]] && fatal "No dnsmasq files in /etc/NetworkManager/dnsmasq.d"
    echo "$dnsmasq_domain"
}

function openshift_libvirt() {
    export OPENSHIFT_INSTALL_PLATFORM=libvirt
    export OPENSHIFT_INSTALL_LIBVIRT_URI="qemu+tcp://192.168.122.1/system"
    export OPENSHIFT_INSTALL_BASE_DOMAIN=${install_domain:-$(find_libvirt_default_domain)}
    machineCIDR='192.168.126.0/24'
    if [[ $install_version == latest_default ]] ; then
	install_version=
	force_local_tools=1
	ext_installer=
	echo "*** Using local installer with libvirt"
    fi
    if (( clean_install_cache )) ; then
	echo "Cleaning install cache in ~/.cache/openshift-install/libvirt"
	[[ -d $HOME/.cache/openshift-install/libvirt ]] && rm -rf "$HOME/.cache/openshift-install/libvirt"
    fi
}

function cmdline_replicas() {
    local node_type=$1
    local default=$2
    local actual=0
    case "$node_type" in
	master) actual=$master_count ;;
	worker) actual=$worker_count ;;
	*)                           ;;
    esac
    (( actual == 0 )) && actual=$default
    echo "$actual"
}

function libvirt_replicas() {
    local node_type=$1		# Not used
    cmdline_replicas "$node_type" 1
}

function aws_replicas() {
    local node_type=$1		# Not used
    cmdline_replicas "$node_type" 3
}

function libvirt_platform() {
    # maipo is channel, not base.
    #local baseURL='https://releases-rhcos.svc.ci.openshift.org/storage/releases/maipo'
    #local install_version=${install_version:-"$(curl --silent "$baseURL/builds.json" | "$JQ" -r '.builds[0]')"}
    cat <<EOF
  libvirt:
    URI: $OPENSHIFT_INSTALL_LIBVIRT_URI
    network:
      if: tt0
EOF
}

function libvirt_master() {
    echo '{}'
}

function libvirt_worker() {
    echo '{}'
}

function libvirt_volume_present() {
    local vol="$1"
    local v
    for v in $(virsh --quiet vol-list --pool default |awk '{print $1}') ; do
	[[ $v == "$vol" ]] && return 0
    done
    return 1
}

function libvirt_delete_volume() {
    local vol
    for vol in "$@" ; do
	if libvirt_volume_present "$vol" ; then
	    echo "Deleting volume $vol"
	    virsh vol-delete --pool default "$vol"
	fi
    done
}

function libvirt_destroy_net() {
    local net
    for net in "$@" ; do
	if virsh --quiet net-list --all |awk '{print $1}' |grep -q "$net" ; then
	    echo "Destroying net $net"
	    virsh net-destroy "$net"
	    virsh net-undefine "$net"
	fi
    done
}

function libvirt_destroy_node() {
    local node
    for node in "$@" ; do
	if virsh --quiet list --all |awk '{print $2}' |grep -q "$node" ; then
	    echo "Destroying $node"
	    virsh destroy "$node"
	    virsh undefine "$node"
	    libvirt_delete_volume "$node"
	fi
    done
}

function libvirt_cleanup() {
    # shellcheck disable=SC2155
    local cluster_name=$(virsh --quiet net-list | awk '{print $1}' | grep "^$1")
    [[ -z $cluster_name ]] && return
    local tmp
    echo -n "Destroying workers..."
    while read -r tmp ; do
	libvirt_destroy_node "$tmp"
    done <<< "$(virsh list --name |grep -E "^(${cluster_name}-)?worker-")"
    libvirt_destroy_net "$cluster_name"
    while read -r tmp ; do
	libvirt_destroy_net "$tmp"
    done <<< "$(virsh --quiet net-list | awk '{print $1}' | grep "^${cluster_name}")"
    libvirt_destroy_node "${cluster_name}-bootstrap"
    libvirt_destroy_node "${cluster_name}-master-0"
    for f in base master-0 master.ign worker.ign bootstrap bootstrap.ign ; do
	libvirt_delete_volume "${cluster_name}-$f"
    done
    while read -r tmp ; do
	libvirt_delete_volume "$tmp"
    done <<< "$(virsh --quiet vol-list --pool default | awk '{print $1}' | grep "^${cluster_name}")"
}

function indent() {
    local -i depth=${1:-2}
    # shellcheck disable=SC2155
    local sol=$(printf "%${depth}s" '')
    while IFS='' read -r line ; do
	[[ -z $line ]] || echo "$sol$line"
    done
}

function aws_master() {
    if [[ -n $aws_master_type ]] ; then
	cat <<EOF

    aws:
      type: "$aws_master_type"
EOF
    else
	echo '{}'
    fi
}

function aws_worker() {
    if [[ -n $aws_compute_type ]] ; then
	cat <<EOF

    aws:
      type: "$aws_compute_type"
EOF
    else
	echo '{}'
    fi
}

function aws_platform() {
    cat <<EOF
  aws:
    region: $OPENSHIFT_INSTALL_AWS_REGION
EOF
}

function platform() {
    if [[ -n $platformconfdata ]] ; then
	indent 2 <<< "$platformconfdata"
    elif [[ -n $platformconffile && -r $platformconffile ]] ; then
	indent 2 < "$platformconffile"
    else
	"${platform}_platform"
    fi
}

function master_platform() {
    if [[ -n $masterconfdata ]] ; then
	echo
	indent 2 <<< "$masterconfdata"
    elif [[ -n $masterconffile && -r $masterconffile ]] ; then
	indent 4 < "$masterconffile"
    else
	"${platform}_master"
    fi
}

function worker_platform() {
    if [[ -n $workerconfdata ]] ; then
	echo
	indent 2 <<< "$workerconfdata"
    elif [[ -n $workerconffile && -r $workerconffile ]] ; then
	echo
	indent 4 < "$workerconffile"
    else
	"${platform}_worker"
    fi
}

function aws_cleanup() {
    :
}

# This has the problem that the install config format can change and
# we're left chasing it.  But much of the idea of this script is that
# people not have to run the installer interactively.
function template() {
    platform=$1
    sed -e 's/[ \t]*$//' -e '/^$/d' <<EOF
apiVersion: $api_version
baseDomain: $OPENSHIFT_INSTALL_BASE_DOMAIN
compute:
- hyperthreading: Enabled
  name: worker
  platform: $(worker_platform)
  replicas: $("${platform}_replicas" worker)
controlPlane:
  hyperthreading: Enabled
  name: master
  platform: $(master_platform)
  replicas: $("${platform}_replicas" master)
metadata:
  creationTimestamp: null
  name: $OPENSHIFT_INSTALL_CLUSTER_NAME
networking:
  clusterNetwork:
  - cidr: 10.128.0.0/14
    hostPrefix: $host_prefix_bits
  machineCIDR: ${machineCIDR}
  networkType: OpenShiftSDN
  serviceNetwork:
  - 172.30.0.0/16
platform:
$(platform)
pullSecret: '$(jq -scM '.[0]' < "$pull_secret")'
sshKey: |
  $(< "$pubkey_file")
EOF
}

function openshift_aws() {
    export OPENSHIFT_INSTALL_BASE_DOMAIN="${install_domain:-$aws_default_domain}"
    export OPENSHIFT_INSTALL_PLATFORM=aws
    machineCIDR='10.0.0.0/16'
    region=${1#aws}
    region=${region#[-._]}
    case "$region" in
	1|'') export OPENSHIFT_INSTALL_AWS_REGION=us-east-1 ;;
	2)    export OPENSHIFT_INSTALL_AWS_REGION=us-east-2 ;;
	3)    export OPENSHIFT_INSTALL_AWS_REGION=us-west-1 ;;
	4)    export OPENSHIFT_INSTALL_AWS_REGION=us-west-2 ;;
	?*)   export OPENSHIFT_INSTALL_AWS_REGION=$region   ;;
    esac
}

# Use this to determine whether we need some particular workaround.
# Most of the time it will be more problematic than it's worth to
# do something like this, but occasionally we may need to
# temporarily.
function git_newer_than() {
    local -l rev="$1"
    git rev-parse -q --verify "$rev" -- >/dev/null 2>&1 || return 1
    [[ -n $(git rev-list "@..$(git rev-parse "$rev")") ]]
}

function wait_and_run() {
    until [[ -f $KUBECONFIG ]] ; do sleep 1; done
    cmd=${1##*/}
    echo "Starting $cmd..."
    if [[ $loglevel == '--log-level=debug' ]] ; then
	exec "$@"
    else
	exec "$@" >/dev/null 2>&1
    fi
}

# We need actual commands/functions named run_kubechart and run_oschart with
# known names, so that they can be waited for.
function run_kubechart() {
    wait_and_run "$kubechart" ${kubechart_port:+--http-port "$kubechart_port"}
}

function run_oschart() {
    wait_and_run "$oschart" ${oschart_port:+--http-port "$oschart_port"}
}

# See https://github.com/openshift/installer/issues/411#issuecomment-446084083
function run_proxy() {
    # The proxy has a bad habit of dying every now and then.
    while : ; do
	# It's simply too noisy.
	${OC} -n openshift-ingress port-forward svc/router-internal-default 443 >/dev/null 2>&1
	# If we die by signal, stop.
	(( $? >= 128 )) && break
    done
}

function timestamp() {
    while read -r ; do
	# Try to diagnose errors to some extent
	case "$REPLY" in
	    'Incompatible API version with plugin')
		api_plugin_incompatibility_detected=1
		;;
	    *)  ;;
	esac
	# Make the message look vaguely Go-like.
	printf 'T0000 %(%H:%M:%S)T.000000   %s\n' -1 "$REPLY"
    done
}

function tsec() {
    printf "%(%s)T" -1
}

function aws_postinstall() {
    :
}

function libvirt_postinstall() {
    (( ! wait_for_complete )) && return
    echo -n "Waiting for DNS to come on line..."
    "${___topdir:-}waitfor-pod" -r 10 dns-default
    echo -n "Waiting for router to come on line..."
    "${___topdir:-}waitfor-pod" -r 10 router-default
    # See https://github.com/openshift/installer/issues/411#issuecomment-445202069
    echo "Creating route proxy"
    if getcap -vr "${OC}" | grep -q "cap_net_bind_service+eip" ; then
	echo "Enabling bind to privileged port for ${OC}, may need sudo password"
	sudo setcap CAP_NET_BIND_SERVICE=+eip "${OC}"
    fi
    run_proxy 2>&1 |grep -v 'Setting up router connection for 443' &
    created_proxy=1
}

function run_shell() {
    cd "$owd" || fatal "Cannot cd to $owd"
    if [[ -n $run_command ]] ; then
	exec "$SHELL" -c "$run_command"
    else
	if (( do_cleanup )) ; then
	    echo "Spawning interactive shell.  Exit with status 77 to suppress cleanup."
	else
	    echo "Spawning interactive shell.  Exit with status 88 to clean up."
	fi
	exec "$SHELL" -i
    fi
}

function warn_authentication_failure() {
cat <<\EOF
* You need to download your pull secrets.

  Visit https://try.openshift.com and log in.  Click on Create
  Cluster/Self-Installed Cluster
  (https://cloud.redhat.com/openshift/install) and select AWS (or as
  appropriate).  From there, select User-Provisioned Infrastructure.
  Download your pull secret and place it in ~/Downloads.

* You need an appropriate quay.io credential.  This may be done in
  one of two ways:

  a) The Easy Way: Get the required key from
     https://access.redhat.com/solutions/3533201).
     Add the auth for quay.io to your ~/.docker/config.json
     and ~/Downloads/pull-secret.

  b) The Hard Way (but will allow you to push your own images): from
     the OpenShift Wiki (https://mojo.redhat.com/docs/DOC-1074351)
     navigate to Set Up Accounts
     (https://mojo.redhat.com/docs/DOC-1081313) and Quay.io Access
     (https://mojo.redhat.com/docs/DOC-1167707#jive_content_id_How_to_play_around_with_Quay_RH_Internal)
     and follow the instructions to get an account.  This will take
     long enough that you should use the "easy way" also.

     You need to log in to quay.io.  After logging in, click on the
     settings (gear) icon in the left bar and click on "CLI Password"
     under Docker CLI Password at the top.  You will be prompted for
     your quay.io password.  Click on "Docker Configuration" and
     either download or view the result.  Copy the result into
     ~/.docker/config.json.

* You need to oc login.

  Go to https://api.ci.openshift.org/ and in
  the upper right corner you will see the '?'.  Dropdown to Command
  Line Tools that will give you an 'oc login' command to run from a
  command line.

  Not doing this can lead to very strange errors; see
  https://bugzilla.redhat.com/show_bug.cgi?id=1647479

* Following oc login, run 'oc registry login'.  This will generate
  additional secrets in ~/.docker/config.json; these need to be
  copied into ~/Downloads/pull-secret (in particular,
  the secret for registry.svc.ci.openshift.org).

* Ensure that you have correct credentials for your cloud provider,
  as appropriate.
EOF
}

function warn_installer_fail() {
    cat <<\EOF
Could not extract installer from image.  Common reasons:

* You've specified an installer version that does not exist (even if
  you've used the query option).  This will fail quickly with a
  clear error message.

EOF
    warn_authentication_failure
}

function fail_installer_extract() {
    local image=$1
    warn_installer_fail
    fatal "Cannot extract openshift-install from image $image"
}

function fail_find_image() {
    local install_version=$1
    warn_installer_fail
    fatal "Can't find image for version $install_version"
}

# This should run in a subshell to not change the current directory
function do_installer_setup() {
    local install_dir=$1
    local image=$2
    local install_version=$3
    cd "$install_dir" || exit 1
    for f in "openshift-"*".tar.gz" ; do
	rm -f "$f"
    done
    "${OC}" adm release extract --tools "${image}" || fail_installer_extract "$image"
    for f in "openshift-"*".tar.gz" ; do
	echo "Extracting $f"
	tar xf "$f" || fail_installer_extract "$image"
    done
    [[ -f openshift-install ]] || fail_installer_extract "$image"
    chmod +x openshift-install
    echo "${install_version}" > version.txt
}

function installer_setup() {
    local not_latest=1
    local release_data
    local image
    if (( query )) ; then
	if [[ -z ${release_channel:-} ]] ; then
	    local -a channels=()
	    readarray -t channels <<< "$(openshift-release-info -B "$repo" channels < /dev/null | sort -r)"
	    OPS3=${PS3:-}
	    PS3="Select channel: "
	    select release_channel in "${channels[@]}" ; do break; done
	    PS3=$OPS3
	fi
	local -a versions
	readarray -t versions <<< "$(openshift-release-info -B "$repo" ${release_channel:+-c "$release_channel"} releases < /dev/null | sort -r)"
	OPS3=${PS3:-}
	PS3="Select release: "
	select install_version in "${versions[@]}" ; do break; done
	PS3=$OPS3
    elif [[ $install_version == latest ]] ; then
	not_latest=
	release_channel=${release_channel:-${release_base_map[$repo]:-}}
	echo "Retrieving release data from $release_source/$release_channel/latest"
	release_data="$(curl --silent "$release_source/$release_channel/latest")"
	[[ -n $release_data ]] || fatal "Can't extract release data!"
	install_version="$("$JQ" -r '.name' <<< "$release_data")"
	[[ -n $install_version ]] || fatal "Can't extract install version!"
    fi
    echo "Using version $install_version${not_latest:- (latest)}" 1>&2
    local -r pullspec="$installer_registry:$install_version"
    image=$(${OC} adm release info --pullspecs "$pullspec" | awk '{if ($1 == "Pull") {print $3}}')
    [[ -z $image ]] && fail_find_image "$install_version"
    if (( ! force_local_tools )) ; then
	echo "Using installer from image ${image} ($ext_installer)" 1>&2
	(do_installer_setup "$install_dir" "$image" "$install_version") || exit 1
	ext_installer="${install_dir}/openshift-install"
	install="$ext_installer"
	echo -e "installer version:\n$("$ext_installer" version |sed 's/^/    /')\n" 1>&2
    fi
    srcdir=.
    if [[ $do_override == 1 && -n $not_latest ]] ; then
	export OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE=$pullspec
	export _OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE=$pullspec
    fi
}

# Try to catch obvious failures
function validate_environment() {
    local f
    for f in quay.io registry.redhat.io registry.svc.ci.openshift.org ; do
	local g=${f//./\\.}
	grep -q "$g" "$pull_secret" || warn "No secret for '$f' in pull secret $pull_secret; expect installation to fail"
    done
}

function confirm_install() {
    (( noconfirm )) && return 0
    local proceed
    echo
    while : ; do
	read -p "Proceed? [YnevV!?] " -r proceed
	case "$proceed" in
	    y|Y|yes|YES|Yes|'')
		break
		;;
	    n|N|no|NO|No)
		echo "Not confirmed"
		return 1
		;;
	    '!')
		echo "Spawning shell..."
		"$SHELL" -i
		;;
	    e|E|edit|EDIT|Edit)
		echo "Running editor on config..."
		${EDITOR:-vi} "$srcdir/$install_dir/install-config.yaml"
		;;
	    V)
		env
		;;
	    v)
		set
		;;
	    '?')
		echo 'y   Proceed with installation'
		echo 'n   Do not proceed with installation'
		echo '!   Spawn shell'
		echo 'V   Print environment'
		echo 'v   Print all variable settings'
		echo 'e   Edit install-config.yaml'
		echo '?   Print this help'
		echo 'Abort installation with any other input'
		;;
	    *)
		;;
	esac
    done
    return 0
}

function start_kubechart_if_requested() {
    [[ -n $kubechart_port ]] && run_kubechart=1
    local run_oschart="$run_kubechart"
    if [[ -n $run_kubechart ]] ; then
	kubechart_port=${kubechart_port:-3000}
	oschart_port=$((kubechart_port+1))
    fi
    if [[ -x $kubechart && $run_kubechart -gt 0 ]] ; then
	created_kubechart=1
	run_kubechart&
    fi
    if [[ -x $oschart && $run_oschart -gt 0 ]] ; then
	created_oschart=1
	run_oschart&
    fi
}

function clean_secret() {
    local min_indent_prefix=
    while IFS= read -r line ; do
	if [[ -n $min_indent_prefix ]] ; then
	    if [[ $line == "${min_indent_prefix}"* ]] ; then
		continue
	    else
		min_indent_prefix=
	    fi
	fi
	if [[ $line =~ (( *)(sshKey: |pullSecret: ))([|]|.*) ]] ; then
	    [[ ${BASH_REMATCH[4]} == '|' ]] && min_indent_prefix="${BASH_REMATCH[2]} "
	    echo "${BASH_REMATCH[1]}..."
	else
	    echo "$line"
	fi
    done
    return 0
}

function run_install() {
    validate_environment
    if [[ -z $cleanup_only_dir ]] ; then
	[[ -n $install_version ]] && srcdir=.
	mkdir -p "$srcdir/$install_dir"
	[[ -n $install_version ]] && installer_setup
	if [[ -n $config_file ]] ; then
	    [[ ! -r $config_file ]] && fatal "Cannot read config file $config_file"
	    cp "$config_file" "$srcdir/$install_dir/install-config.yaml"
	else
	    template "$OPENSHIFT_INSTALL_PLATFORM" > "$srcdir/$install_dir/install-config.yaml"
	fi
    fi
    # shellcheck disable=SC2155
    export KUBECONFIG="$(cd $srcdir && echo "$(pwd)/$install_dir/auth/kubeconfig")"

    # We will need the installer even in cleanup-only mode,
    # in order to clean up the cluster.
    local -i rebuild_installer=0
    if [[ -z $ext_installer ]] ; then
	cd $srcdir || fatal "Can't cd to $srcdir"
	local -r cur_rev=$(git rev-parse @)
	[[ ! -x $install || $rebuild -gt 0 || $(${install} version) =~ $cur_rev ]] && rebuild_installer=1
    else
	srcdir=.
    fi

    # shellcheck disable=SC2155
    local start=$(tsec)
    trap cleanup EXIT SIGHUP SIGINT SIGQUIT SIGTERM

    install_stage=1
    OPENSHIFT_INSTALL_CONFIG="$(clean_secret < "$srcdir/$install_dir/install-config.yaml")"
    export OPENSHIFT_INSTALL_CONFIG
    cat <<EOF
About to run installer:

Installer:         $install
Sourcedir:         $srcdir$([[ $srcdir != /* ]] && echo " ($(cd "$srcdir" && pwd))")
Install dir:       $srcdir/$install_dir
Current dir:       $(pwd)
Install version:   $install_version
Override:          ${OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE:-}
Install command:   ${install} $loglevel --dir="$srcdir/$install_dir" create cluster
Configuration:

$OPENSHIFT_INSTALL_CONFIG
EOF
    confirm_install || exit 1

    if (( rebuild_installer )) ; then
	echo "Rebuilding installer"
	TAGS=libvirt hack/build.sh || fatal "Can't rebuild installer"
    fi

    install_stage=2
    # Start kubechart/oschart (if needed) prior to running the installer
    start_kubechart_if_requested

    echo
    # shellcheck disable=SC2086
    "${install}" $loglevel "--dir=$srcdir/$install_dir" create cluster </dev/null 2>&1 | timestamp

    local install_status=${PIPESTATUS[0]}
    # shellcheck disable=SC2155
    local -i end1=$(tsec)
    local -i end2=0
    local -i end3=0

    if (( install_status )) ; then
	echo "Cluster creation failed"
	if (( api_plugin_incompatibility_detected )) ; then
	    cat <<'EOF'
Error message suggests a stray 'terraform-provider-libvirt' binary.
Please remove all files of that name from your home directory and try
again.

EOF
	fi
	cat <<'EOF'
There are a number of problems that may cause failure to install, most
commonly authentication problems:

EOF
	warn_authentication_failure
	clean_shutdown=0
    fi
    if (( force_postinstall || !install_status )) ; then
	if [[ -f "${srcdir}/${install_dir}/auth/kubeadmin-password" ]] ; then
	    # shellcheck disable=SC2155
	    export OPENSHIFT_INSTALL_PASSWORD=$(< "${srcdir}/${install_dir}/auth/kubeadmin-password")
	    if (( ! do_login )) ; then
		echo "oc login skipped"
	    elif oc_login ; then
		login_succeeded=1
		console_route=
	    else
		echo "oc login failed!"
	    fi
	fi
	end2=$(tsec)

	"${OPENSHIFT_INSTALL_PLATFORM}_postinstall"

	if (( wait_for_complete && login_succeeded )) ; then
	    echo -n "Waiting for console to come on line..."
	    if "${___topdir:-}waitfor-pod" -r 10 console && waitfor_console ; then
		console_route="$(${OC} get route -n openshift-console -o "custom-columns=HOST:.status.ingress[0].host" --no-headers=true |grep ^console)"
		if [[ -n $console_route && $console_route != '<none>' ]] ; then
		    export OPENSHIFT_INSTALL_CONSOLE_ROUTE="https://$console_route"
		    echo "Console route: $OPENSHIFT_INSTALL_CONSOLE_ROUTE"
		    (xdg-open "$OPENSHIFT_INSTALL_CONSOLE_ROUTE" </dev/null >/dev/null 2>&1 &)
		fi
	    fi
	    echo "login: kubeadmin / $OPENSHIFT_INSTALL_PASSWORD"
	    if (( create_bastion )) ; then
		echo "Creating bastion host"
		curl -s -S https://raw.githubusercontent.com/eparis/ssh-bastion/master/deploy/deploy.sh | bash
		# shellcheck disable=SC2181
		if (( $? )) ; then
		    echo "Create bastion host failed"
		else
		    echo "Alternatively, you may prefer to use ${___topdir:-}bastion-ssh"
		    # shellcheck disable=SC2155
		    export OPENSHIFT_BASTION_ADDRESS="$(oc get service -n openshift-ssh-bastion ssh-bastion -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')"
		    [[ -z $OPENSHIFT_BASTION_ADDRESS ]] && echo "Unable to find bastion address!"
		fi
	    fi
	fi
	end3=$(tsec)
	# shellcheck disable=SC2155
	export OPENSHIFT_INSTALL_NODE_IPS=$("${___topdir:-}"get-nodes)
	# shellcheck disable=SC2155
	export OPENSHIFT_INSTALL_WORKER_NODES=$(oc get nodes -l node-role.kubernetes.io/worker --no-headers=true -o name|sed -e 's,node/,,')
	# shellcheck disable=SC2155
	export OPENSHIFT_INSTALL_MASTER_NODES=$(oc get nodes -l node-role.kubernetes.io/master --no-headers=true -o name|sed -e 's,node/,,')
    fi
    printerval "Installation" $((end1 - start))
    (( end2 )) && printerval "Total setup to login" $((end2 - start))
    (( end3 )) && printerval "Total setup to console online" $((end3 - start))
    export OPENSHIFT_INSTALL_INTERLOCK=1
    export OPENSHIFT_INSTALL_VERSION=$install_version
    for f in "${!OPENSHIFT@}" "${!_OPENSHIFT@}" KUBECONFIG ; do eval "echo export $f=\${$f@Q}"; done > "${srcdir}/${install_dir}/environment"
    # Run a shell even if setup failed, so it's possible to poke around
    (run_shell)
    case $? in
	77) do_cleanup=0 ;;
	88) do_cleanup=1 ;;
	*)               ;;
    esac
    clean_shutdown=1
}

function read_profile() {
    local profile="$1"
    if [[ ! -r $profile ]] ; then
	fatal "Can't read profile $profile"
    fi
    local value
    if [[ $profile = *.json ]] ; then
	while read -r key <<<"$(jq -r 'keys[]' "$profile")" ; do
	    value="$(jq -r ".\"$key\"" "$profile")" || fatal "Cannot process $key"
	    eval "key=\"$value\"" || fatal "Cannot process $key=$value"
	done
    else
	# shellcheck source=/dev/null
	. "$profile" || fatal "Cannot process profile $profile"
    fi
}

function process_option() {
    local option="$1"
    eval "$1" || fatal "Cannot process option $option"
}

while getopts ":bC:cd:H:hNn:Op:QR:V:vX:y" opt ; do
    case "$opt" in
	b) run_kubechart=1		;;
	C) cleanup_only_dir="$OPTARG"	;;
	c) clean_install_cache=1	;;
	d) install_dir="$OPTARG"        ;;
	N) do_cleanup=0			;;
	n) release_channel="$OPTARG"    ;;
	O) overwrite=1                  ;;
	p) read_profile "$OPTARG"       ;;
	Q) query=1                      ;;
	R) repo="$OPTARG" 		;;
	V) install_version="$OPTARG"    ;;
	v) loglevel='--log-level=debug' ;;
	X) process_option "$OPTARG"     ;;
	y) noconfirm=1			;;
	H) help_extended		;;
	h) help				;;
	*) help "$OPTARG"               ;;
    esac
done

[[ -n $ext_installer ]] && install="$ext_installer"

[[ -n $masterconffile && ! -r $masterconffile ]] &&
    fatal "Master platform config $masterconffile not readable"
[[ -n $workerconffile && ! -r $workerconffile ]] &&
    fatal "Worker platform config $workerconffile not readable"
[[ -n $platformconffile && ! -r $platformconffile ]] &&
    fatal "Platform config $platformconffile not readable"

(( host_prefix_bits < 8 || host_prefix_bits > 23 )) &&
    fatal "Host prefix size must be between 8 and 23"

check_aws_instance_type "$aws_master_type"
check_aws_instance_type "$aws_compute_type"

release_source=${OPENSHIFT_RELEASE_SOURCE:-https://${repo}.svc.ci.openshift.org/api/v1/releasestream}
installer_registry=${OPENSHIFT_INSTALL_REGISTRY:-registry.svc.ci.openshift.org/${subdir_map[$repo]:-}/release}
#release_channel=${release_channel:-${release_base_map[$repo]:-}}

shift $((OPTIND - 1))

if [[ -n ${1:-} ]] ; then
    install_type="$1"
    shift
fi

[[ -z "$*" ]] || echo "Warning: extraneous arguments $# after $install_type will be ignored!" 1>&2

clear_env
case "$install_type" in
    libvirt) openshift_libvirt                     ;;
    aws*)    openshift_aws "$install_type"         ;;
    *)       help   				   ;;
esac
[[ $install_version == latest_default ]] && install_version=latest
export OPENSHIFT_INSTALL_CLUSTER_NAME=${install_dir:-${LOGNAME}-${OPENSHIFT_INSTALL_PLATFORM}}

install_dir="${install_dir:-$OPENSHIFT_INSTALL_CLUSTER_NAME}"

if [[ -n $cleanup_only_dir ]] ; then
    if [[ ! -d $install_dir ]] ; then
	echo "No install directory $install_dir to clean up"
	exit 0
    fi
elif [[ -d $install_dir && $install_dir != . && $install_dir != .. &&
	    -n $(ls "$install_dir") && $overwrite -eq 0 ]] ; then
    fatal "Install directory $install_dir already present; will not overwrite without -O"
fi

run_install
