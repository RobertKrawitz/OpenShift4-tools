#!/bin/bash

# Copyright 2019-2020 Robert Krawitz/Red Hat
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

function fatal() {
    echo "FATAL: $*" 1>&2
    exit 1
}

set -u

# Find our helpers
function finddir() {
    local path_to_file
    path_to_file=$(readlink -f "$0")
    if [[ -z $path_to_file ]] ; then
	return 1
    elif [[ -d $path_to_file ]] ; then
	echo "$path_to_file/"
    elif [[ -e $path_to_file ]] ; then
	echo "${path_to_file%/*}/"
    else
	return 1
    fi
    return 0
}

declare ___realsc=
declare ___topsc
if [[ -z ${___topsc:-} ]] ; then
    export ___topsc="${0##*/}"
    # shellcheck disable=SC2155
    export ___topdir="$(finddir "$0")"
    [[ -z $___topdir ]] && fatal "Can't find directory for $0"
fi

function clean_startup() {
    [[ -f $___realsc ]] && rm -f "$___realsc"
}

# This allows us to edit the script while another instance is running
# since this script sticks around until the user exits the spawned shell.
# It's fine for the running script to be removed, since the shell still
# has its open file descriptor.
if [[ $# = 0 || $1 != "--DoIt=$0" ]] ; then
    tmpsc=$(mktemp)
    [[ -z $tmpsc || ! -f $tmpsc || -L $tmpsc ]] && fatal "Can't create temporary script file"
    trap clean_startup EXIT SIGHUP SIGINT SIGQUIT SIGTERM
    PATH+=${PATH:+:}$___topdir
    cat "$0" > "$tmpsc"
    chmod +x "$tmpsc"
    exec "$tmpsc" "--DoIt=$tmpsc" "$@"
else
    ___realsc=${1#--DoIt=}
    clean_startup
    shift
fi

# Globals
declare -A release_base_map=()
release_base_map[origin-release]='4.2.0-0.okd'
release_base_map[openshift-release]='4-stable'

declare -A subdir_map=()
subdir_map[origin-release]='origin'
subdir_map[openshift-release]='ocp'

declare -r kubechart=${KUBECHART:-$GOPATH/src/github.com/sjenning/kubechart/kubechart}
declare -r oschart=${OSCHART:-$GOPATH/src/github.com/sjenning/oschart/oschart}
declare -r default_repo_base=openshift-release

declare -A global_platforms=()
declare -a global_platform_list=()

declare -A global_diagnostics=()
declare -a platform_path=()

declare install_type=
declare install_domain=${OPENSHIFT_INSTALL_DOMAIN:-}
declare install_dir=${OPENSHIFT_INSTALL_DIR:-$install_domain}
declare install_version=latest_default
declare pull_secret=${OPENSHIFT_INSTALL_PULL_SECRET_PATH:-$HOME/Downloads/pull-secret}
declare pubkey_file=${OPENSHIFT_INSTALL_SSH_PUB_KEY_PATH:-$HOME/.ssh/id_rsa.pub}
declare installer_src=${GOPATH:-$HOME/go}/src/github.com/openshift/installer
declare install=$installer_src/bin/openshift-install
declare release_channel=
declare repo=$default_repo_base
declare ____current_platform

# shellcheck disable=SC2155
declare -r OC=$(type -p oc)
[[ -z $OC ]] && fatal "Can't find oc command"
# shellcheck disable=SC2155
declare -r JQ=$(type -p jq)
[[ -z $JQ ]] && fatal "Can't find jq command"
# shellcheck disable=SC2155
declare -r owd=$(pwd)
declare -i clean_install_cache=0
declare -i clean_shutdown=0
declare -i cleanup_run=0
declare -i create_bastion=1
declare -i created_kubechart=0
declare -i created_oschart=0
declare -i do_cleanup=1
declare -i do_login=1
declare -i do_override=0
declare -i download_oc=0
declare -i force_local_tools=0
declare -i force_postinstall=0
declare -i generate_cluster_key=1
declare -i generate_manifest=0
declare -i install_stage=0
declare -i login_succeeded=0
declare -i master_count=0
declare -i noconfirm=0
declare -i overwrite=0
declare -i query=0
declare -i rebuild=0
declare -i run_kubechart=0
declare -i run_oschart=0
declare -i save_artifacts=0
declare -i wait_for_complete=1
declare -i worker_count=0
declare -i cvo=1
declare -i host_prefix_bits=23
declare api_version=v1
declare cleanup_only_dir=
declare config_file=
declare console_route=
declare edit_manifest=
declare ext_installer=
declare -r -i default_kubechart_port=3000
declare kubechart_port=
declare loglevel=
declare network_type=OpenShiftSDN
declare oschart_port=
declare release_source=
declare run_command=
declare platform_type=
declare master_type=
declare worker_type=
declare masterconffile=
declare masterconfdata=
declare workerconffile=
declare workerconfdata=
declare platformconffile=
declare platformconfdata=
declare -a options_to_process=()
declare -A option_registrations=()

function print_help() {
    cat <<EOF
Usage: $___topsc [options] [install_type]
    install_type: one of
$(do_platforms platform_help install_types | indent 7)
    Options (all are processed in order):
       -p profile           Read the specified profile file.  Profile
                            may be a JSON file or shell code.
       --option[=value]
       -X option[=value]    Set the specified extended option.
                            Short options listed with a KEY can be
                            invoked as --KEY[=value].
       -H                   Print list of additional extended command
                            line options.

    Options listed as -a/-A are inverted by the second listed option.
       -b/-B                Launch kubechart and oschart (if available).
                            See https://github.com/sjenning/kubechart
                            KEY: run_kubechart (default=0)
       -c/-C                Clean install cache, in case it is corrupted.
                            KEY: clean_install_cache (default=0)
       -d install_dir       Use the specified dir as working directory and
                            cluster name.  Default is ${LOGNAME:-}-<platform>.
       -k/-K                Generate ssh key for the cluster.  If not set,
                            use user's standard ssh key.
			    KEY: generate_cluster_key (default=1)
       -l/-L                Don't clean up on exit.  You can exit with status
                            77 for no cleanup or 88 to force cleanup.
                            KEY: do_cleanup (default=1)
       -n release_channel   Use the specified release channel.
       -O/-o                Allow overwrite an existing install directory.
                            KEY: overwrite (default=0)
       -u/-U                Query for release (and optionally channel) to use.
                            KEY: query (default=0)
       -V install_version   Install the specified image version (default
                            latest).  Use '$___topsc -H' for more details.
       -v/-q                Print debug information.
                            KEY/VALUE: loglevel='--log-level=debug'
       -x cleanup_only_dir  Only clean up (requires cluster already exists).
       -y/-Y                Do not prompt prior to starting install
                            KEY: noconfirm (default=0)
EOF
}

function help() {
    [[ -n ${1:-} ]] && echo "$___topsc: Unknown option $1"
    print_help
    exit 1
}

function help_extended() {
    print_help
    cat <<EOF

    Other options with no short command line option (with -X):
      Generic cluster configuration:
        host_prefix_bits    Use the specified host prefix size (default $host_prefix_bits,
                            must be between 8 and 24)
        network_type	    Use the specified network type.  Default is
			    $network_type; alternative is OVNKubernetes.
        masterconfdata      Specify the data for master configuration.
        masterconffile      Take master platform config from specified file.
        platformconfdata    Specify the data for platform configuration.
        platformconffile    Take platform configuration from specified file.
        workerconfdata      Specify the data for worker configuration.
        workerconffile      Take master platform config from specified file.
      Node type/count, all default by platform:
        master_count        Use the specified number of master nodes.
        master_type         Instance type to use for master.
        worker_count        Use the specified number of worker nodes.
        worker_type         Instance type to use for workers.
        platform_type       Instance type to use for both workers and masters.
$(do_platforms platform_help options |indent -6)

      Installation options:
        config_file         Use the specified file as the install config file.
        create_bastion      Create a bastion ssh host if supported
                            by platform (default 1).
        disable_cvo         Turn off the cluster version operator so that
                            the resulting cluster is not overwritten.
                            Option variable is 'cvo' (default 1, not disabled).
        do_login            Login to the console (default=1)
        download_oc         Download the matching oc binary (default=0)
        edit_manifest=func  Edit manifest files using supplied function.
                            Only relevant if --generate-manifest is in use.
                            If this is supplied but empty, spawn an
                            interactive shell.
        ext_installer       Use the specified command to install OpenShift.
        force_postinstall   Always run the postinstall even if setup fails.
        generate_manifest   Generate the manifest files explicitly (default 0,
                            unless overridden by platform)
        install_domain      Use the specified domain name.
$(do_platforms platform_help default_domain | indent -28)
        install_version     Install the specified image version.  Default
                            is to use the latest version.
                            Use empty value to install from local workspace
                            (installer_src, default ${installer_src}).
        install_type        Specify the install type, as described above.
        installer_src       Specify the source directory for the installer.
                            Default is ${installer_src}.
        kubechart_port      Use the specified port for kubechart.  oschart
                            runs at port+1.  Implies -b.  Default is ${default_kubechart_port}.
        pubkey_file         Specify the path to the desired public key
                            Default $pubkey_file
        pull_secret         Specify the path to the pull secret.
                            Default $pull_secret
        rebuild             Always rebuild the installer, when using local
                            installer.
        repo                Use the specified repo (default $default_repo_base).
        run_command         Run the specified command rather than an
                            interactive shell on completion of installation.
        save_artifacts      Preserve install config, manifests, etc.
        wait_for_complete   Wait for console to come online (default=1)

    The following extended options are normally not recommended:
        api_version         Use the specified API version (default $api_version).
        do_override         Override install image.
        force_local_tools   Use the local toolchain to install with.
                            Turns on do_override if a version is specified.
EOF
    exit 1
}

################################################################
### Utilities						     ###
################################################################

function clear_env() {
    local var
    for var in "${!_OPENSHIFT_INSTALL@}" "${!OPENSHIFT_INSTALL@}" KUBECONFIG ; do unset "$var"; done
}

function printerval() {
    local milestone=$1
    local interval=$2
    echo -n "$milestone took "
    local h=$((interval / 3600))
    (( h > 0 )) && echo -n "$h:"
    printf "%02d:%02d\n" $(((interval % 3600) / 60)) $((interval % 60))
}

function set_diagnostic() {
    local diagnostic_id="$1"
    local print_diagnostic_message_func="$2"
    global_diagnostics["$diagnostic_id"]="$print_diagnostic_message_func"
}

function _timestamp() {
    while read -r REPLY ; do
	platform_dispatch diagnose "$REPLY"
	# Make the message look vaguely Go-like.
	printf "T0000 %s   %s\n" "$(TZ=GMT-0 date '+%Y-%m-%dT%T.%N' | cut -c1-26)" "$REPLY"
    done
}

function timestamp() {
    if [[ -n "$*" ]] ; then
	_timestamp <<< "$*"
    else
	_timestamp
     fi
}

function tsec() {
    printf "%(%s)T" -1
}

function indent() {
    local -i depth=${1:-2}
    local -i always_indent=0
    if (( depth < 0 )) ; then
	depth=$((-depth))
	always_indent=1
    fi
    # shellcheck disable=SC2155
    local sol=$(printf "%${depth}s" '')
    while IFS='' read -r line ; do
	[[ always_indent -eq 0 && -z $line ]] || echo "$sol$line"
    done
}

function cmdline_replicas() {
    local node_type=$1
    local default=$2
    local actual=0
    case "$node_type" in
	master) actual=$master_count ;;
	worker) actual=$worker_count ;;
	*)                           ;;
    esac
    (( actual == 0 )) && actual=$default
    echo "$actual"
}

function run_installer() {
    "${install}" $loglevel "--dir=$install_dir" "$@"
}

function dispatch_unknown() {
    # Don't force platforms to implement every new item
    :
#    local platform=$1
#    shift
#    fatal "Unexpected command ($platform): $*"
}

# Not all platforms support the standard bastion host.
function do_create_bastion_if_needed() {
    (( create_bastion )) || return
    platform_dispatch supports_bastion || return
    echo "Creating bastion host"
    curl -s -S https://raw.githubusercontent.com/eparis/ssh-bastion/master/deploy/deploy.sh | bash
    # shellcheck disable=SC2181
    if (( $? )) ; then
	echo "Create bastion host failed"
    else
	echo "Alternatively, you may prefer to use ${___topdir:-}bastion-ssh"
	# shellcheck disable=SC2155
	export OPENSHIFT_BASTION_ADDRESS="$(oc get service -n openshift-ssh-bastion ssh-bastion -o json | jq -r 'if .status.loadBalancer.ingress[0].hostname == null then .status.loadBalancer.ingress[0].ip else .status.loadBalancer.ingress[0].hostname end')"
	[[ -z $OPENSHIFT_BASTION_ADDRESS ]] && echo "Unable to find bastion address!"
    fi
}

function add_platform() {
    if [[ -z ${____current_platform:-} ]] ; then
	fatal "Attempt to add a platform outside of its definition"
    fi
    local -r dispatch=$1
    local plat
    for plat in "${global_platform_list[@]}" ; do
	if [[ $____current_platform = "$plat" ]] ; then return; fi
    done
    global_platform_list+=("$____current_platform")
    global_platforms[$____current_platform]=$dispatch
}

function _default_split_instance_func() {
    echo ' '
    echo "$1"
}

function _list_instance_types() {
    local -i list_all=0
    local cmd=$1
    local list_option_name=$2
    local split_instance_func=${3:-_default_split_instance_func}
    shift 3
    while read -r REPLY ; do echo "$REPLY" ; done
    if [[ $cmd = list_all ]] ; then
	list_all=1
    else
	echo "Use '$___topsc -X $list_option_name=list-all' to list all instance types."
    fi
    echo
    local last_class=
    local -i tot_cols=0
    local -i groups_printed=0
    # shellcheck disable=SC2155
    local -i term_width=$(tput cols 2>/dev/null)
    (( term_width > 0 )) || term_width=80
    local instance
    local -i c=0
    local -i s=0
    local -a cla
    # Find the widest class name and instance name
    for instance in "$@" ; do
	case "$instance" in
	    " X."*)
		(( list_all == 0 && groups_printed++ )) && break
		;;
	    " Y"*)
		;;
	    *)
		readarray -t cla <<< "$("$split_instance_func" "$instance")"
		(( ${#cla[0]} < c )) || c=$((${#cla[0]}+1))
		(( ${#cla[1]} <= s )) || s=${#cla[1]}
		;;
	esac
    done
    groups_printed=0
    for instance in "$@" ; do
	case "$instance" in
	    " X."*)
		(( list_all == 0 && groups_printed++ )) && break
		echo -ne "${last_class:+\n\n}${instance# X.}:"
		last_class=
		;;
	    " Y."*)
		echo -ne "\n  ${instance#*.}"
		;;
	    *)
		readarray -t cla <<< "$("$split_instance_func" "$instance")"
		if [[ ${cla[0]} = "$last_class" ]] ; then
		    tot_cols+=$((s+1))
		    if (( tot_cols > (term_width - s) )) ; then
			printf "\n %${c}s " ''
			tot_cols=$((c+2))
		    fi
		    printf " %-${s}s" "${cla[1]}"
		else
		    tot_cols=$((c+2))
		    local sep=:
		    if [[ ${cla[0]} = ' ' ]] ; then
			sep=
		    fi
		    printf "\n  %-${c}s %-${s}s" "${cla[0]}$sep" "${cla[1]}"
		    last_class=${cla[0]}
		fi
		;;
	esac
    done
    echo
}

function list_instance_types() {
    while IFS= read -r line ; do
	line=${line## }
	echo "$line"
    done <<< "$(_list_instance_types "$@")"
}

function _check_instance_type() {
    local instance_type=$1
    local platform=$2
    local list_option_name=$3
    local split_instance_func=$4
    shift 4
    [[ -z ${instance_type:-} ]] && return 0
    local instance
    for instance in "$@" ; do
	[[ $instance = "$instance_type" ]] && return 0
    done
    echo "*** WARNING: '$instance_type' is not a currently known $platform instance type!"
    local -a cla
    local -a icla
    readarray -t cla <<< "$("$split_instance_func" "$instance_type")"
    # shellcheck disable=SC2155
    local -i term_width=$(tput cols 2>/dev/null)
    (( term_width > 0 )) || term_width=80
    local -i tot_cols=0
    local j=0
    for instance in "$@" ; do
	readarray -t icla <<< "$("$split_instance_func" "$instance")"
	if [[ ${cla[0]} = "${icla[0]}" ]] ; then
	   (( j++ )) || echo "Possible candidates:"
	   if (( tot_cols > (term_width - 5) )) ; then
	       echo
	       tot_cols=0
	   fi
	   echo -n " $instance"
	   tot_cols=$((tot_cols + ${#instance} + 1))
	fi
    done
    echo -e '\n'
    (( j )) || return 2
    return 1
}

function validate_instance_type() {
    local worker_type=$1
    local master_type=$2
    local platform=$3
    local list_option_name=$4
    local split_instance_func=$5
    shift 5
    if [[ $master_type = list-all || $worker_type = list-all ||
	      $master_type = list_all || $worker_type = list_all ]] ; then
	list_instance_types list_all "$list_option_name" "$split_instance_func" "$@"
	exit
    fi
    if [[ $master_type = list || $worker_type = list ]] ; then
	list_instance_types list "$list_option_name" "$split_instance_func" "$@"
	exit
    fi
    local need_to_list_instance_types=0
    _check_instance_type "$master_type" "$platform" "$list_option_name" "$split_instance_func" "$@"
    (( $? == 2 )) && need_to_list_instance_types=1
    _check_instance_type "$worker_type" "$platform" "$list_option_name" "$split_instance_func" "$@"
    (( $? == 2 )) && need_to_list_instance_types=1
    (( need_to_list_instance_types )) && list_instance_types list "$list_option_name" "$split_instance_func" "$@"
    return 0
}

function platform_dispatch() {
    if [[ $1 = -p ]] ; then
	shift
	local platform=$1
	shift
	if [[ -z ${global_platforms[$platform]:-} ]] ; then
	    fatal "Platform $platform not found"
	fi
	"${global_platforms[$platform]}" "$@"
    elif [[ -n ${OPENSHIFT_INSTALL_PLATFORM:-} ]] ; then
	"${global_platforms[$OPENSHIFT_INSTALL_PLATFORM]}" "$@"
    else
	local -i status=0
	local platform
	for platform in "${global_platform_list[@]}" ; do
	     "${global_platforms[$platform]}" "$@" || status=1
	done
	return $status
    fi
}

function do_platforms() {
    OPENSHIFT_INSTALL_PLATFORM='' platform_dispatch "$@"
}

function find_first_platform() {
    local platform
    for platform in "${global_platform_list[@]}" ; do
	if platform_dispatch -p "$platform" "$@" ; then
	    echo "$platform"
	    return 0
	fi
    done
    return 1
}

function cleanup() {
    (( cleanup_run )) && exit
    (( !clean_shutdown && install_stage >= 2 )) && echo -en '\n*** '
    case "$install_stage" in
	0) ;;
	1)
	    [[ -n $install_dir && $install_dir != . && $install_dir != .. && -d "$install_dir" ]] && rm -rf "$install_dir"
	    ;;
	*)
	    echo "Cleaning up, please do not interrupt"
	    if (( do_cleanup )) ; then
		# Shut up some very uninteresting noise
		exec 3>&2 2>/dev/null
		if (( created_kubechart )) ; then
		    kill -9 %run_kubechart
		    wait %run_kubechart
		fi
		if (( created_oschart )) ; then
		    kill -9 %run_oschart
		    wait %run_oschart
		fi
		exec 2>&3 3>&-
		run_installer destroy cluster 2>&1 |timestamp
		if (( PIPESTATUS[0] == 0 || clean_install_cache)) ; then
		    [[ -n $install_dir && $install_dir != . && $install_dir != .. && -d "$install_dir" ]] && rm -rf "$install_dir"
		else
		    echo "$install --dir=$install_dir destroy cluster failed, not removing install dir!"
		fi
		platform_dispatch cleanup
	    else
		cat 1>&2 <<EOF
*** Not cleaning up!
*** When you are finished, run:

"${install}" $loglevel "--dir=$install_dir" destroy cluster
EOF
	    fi
	    ;;
    esac
    cleanup_run=1
    exit
}

function platform_data() {
    local what=${1:-}
    local data=${2:-}
    local file=${3:-}
    local -i indent=${4:-0}
    local platform_code
    if [[ -n $data ]] ; then
	platform_code="$data"
    elif [[ -n $file && -r $file ]] ; then
	platform_code="$(< "$file")"
    else
	platform_code=${what:+$(platform_dispatch "$what")}
    fi
    if [[ -z $platform_code ]] ; then
	echo '{}'
    else
	echo
	indent "$indent" <<< "$platform_code"
    fi
}

# This has the problem that the install config format can change and
# we're left chasing it.  But much of the idea of this script is that
# people not have to run the installer interactively.
function template() {
    sed -e 's/[ \t]*$//' -e '/^$/d' <<EOF
apiVersion: $api_version
baseDomain: $(platform_dispatch base_domain)
compute:
- hyperthreading: Enabled
  name: worker
  platform: $(platform_data worker "${workerconfdata:-}" "${workerconfdata:-}" 4)
  replicas: $(platform_dispatch replicas worker)
controlPlane:
  hyperthreading: Enabled
  name: master
  platform: $(platform_data master "${masterconfdata:-}" "${masterconfdata:-}" 4)
  replicas: $(platform_dispatch replicas master)
metadata:
  creationTimestamp: null
  name: $OPENSHIFT_INSTALL_CLUSTER_NAME
networking:
  clusterNetwork:
  - cidr: 10.128.0.0/14
    hostPrefix: $host_prefix_bits
  machineCIDR: $(platform_dispatch machine_cidr)
  networkType: $network_type
  serviceNetwork:
  - 172.30.0.0/16
platform: $(platform_data platform "${platformconfdata:-}" "${platformconfdata:-}" 2)
publish: External
pullSecret: '$(jq -scM '.[0]' < "$pull_secret")'
sshKey: |
  $(< "$pubkey_file")
EOF
}

# Use this to determine whether we need some particular workaround.
# Most of the time it will be more problematic than it's worth to
# do something like this, but occasionally we may need to
# temporarily.
function git_newer_than() {
    local -l rev="$1"
    git rev-parse -q --verify "$rev" -- >/dev/null 2>&1 || return 1
    [[ -n $(git rev-list "@..$(git rev-parse "$rev")") ]]
}

function wait_and_run() {
    until [[ -f $KUBECONFIG ]] ; do sleep 1; done
    cmd=${1##*/}
    echo "Starting $cmd..." | timestamp
    if [[ $loglevel = '--log-level=debug' ]] ; then
	exec "$@"
    else
	exec "$@" >/dev/null 2>&1
    fi
}

# We need actual commands/functions named run_kubechart and run_oschart with
# known names, so that they can be waited for.
function run_kubechart() {
    wait_and_run "$kubechart" ${kubechart_port:+--http-port "$kubechart_port"}
}

function run_oschart() {
    wait_and_run "$oschart" ${oschart_port:+--http-port "$oschart_port"}
}

function run_shell() {
    cd "$owd" || fatal "Cannot cd to $owd"
    if [[ -n $run_command ]] ; then
	exec "$SHELL" -c "$run_command"
    else
	if (( do_cleanup )) ; then
	    timestamp "Spawning interactive shell.  Exit with status 77 to suppress cleanup."
	else
	    timestamp "Spawning interactive shell.  Exit with status 88 to clean up."
	fi
	exec "$SHELL" -i
    fi
}

function warn_authentication_failure() {
cat <<\EOF
* [auth] You need to download your pull secrets.

  Visit https://try.openshift.com and log in.  Click on Create
  Cluster/Self-Installed Cluster
  (https://cloud.redhat.com/openshift/install) and select your
  appropriate cloud platform.  From there, select User-Provisioned
  Infrastructure.  Download your pull secret and place it in ~/Downloads.

* [auth] You need an appropriate quay.io credential.

  Get the required key from
  https://access.redhat.com/solutions/3533201.  Add the auth for
  quay.io to your ~/.docker/config.json and ~/Downloads/pull-secret.

* [auth] You need to oc login (or periodically refresh your login).  All
  three steps must be performed.  Not doing this can lead to very
  strange errors; see https://bugzilla.redhat.com/show_bug.cgi?id=1647479.

  + Go to https://api.ci.openshift.org/ and in the upper right corner
    you will see the '?'.  Dropdown to Command Line Tools that will
    give you an 'oc login' command to run from a command line.

  + Run 'oc registry login'.

  + This will generate or update additional secrets in
    ~/.docker/config.json; these need to be copied into
    ~/Downloads/pull-secret.  In particular, the secret for
    registry.svc.ci.openshift.org will change.

* [auth] Ensure that you have correct credentials for your cloud platform,
  as appropriate.
EOF
}

function warn_installer_fail() {
    cat <<\EOF

Could not extract installer from image.  Common reasons:

* You've specified an installer version that does not exist (even if
  you've used the query option).  This will fail quickly with a
  clear error message.

EOF
    warn_authentication_failure
}

function fail_installer_extract() {
    local image=$1
    warn_installer_fail
    fatal "Cannot extract openshift-install from image $image"
}

function fail_find_image() {
    local install_version=$1
    warn_installer_fail
    fatal "Can't find image for version $install_version"
}

# This should run in a subshell to not change the current directory
function do_installer_setup() {
    local install_dir=$1
    local image=$2
    local install_version=$3
    cd "$install_dir" || exit 1
    for f in "openshift-"*".tar.gz" ; do
	rm -f "$f"
    done
    "${OC}" adm release extract --tools "${image}" || fail_installer_extract "$image"
    for f in "openshift-"*".tar.gz" ; do
	echo "Extracting $f"
	tar xf "$f" || fail_installer_extract "$image"
    done
    [[ -f openshift-install ]] || fail_installer_extract "$image"
    chmod +x openshift-install
    echo "${install_version}" > version.txt
}

function list_release_channels() {
    local -a channels=(" X.Available release channels:")
    readarray -t -O 1 channels <<< "$(openshift-release-info -B "$repo" channels < /dev/null | sort -r)"
    list_instance_types list_all "release_channel" '' "${channels[@]}" < /dev/null
}

function list_install_versions() {
    local channel=$1
    local -a releases=()
    if [[ -n $channel ]] ; then
	channels=("$channel")
    else
	local -a channels=()
	readarray -t channels <<< "$(openshift-release-info -B "$repo" channels < /dev/null | sort -r)"
    fi
    for channel in "${channels[@]}" ; do
	local -a versions=()
	readarray -t versions <<< "$(openshift-release-info -B "$repo" ${channel:+-c "$channel"} releases < /dev/null | sort -r)"
	if [[ -n "${versions[*]}" ]] ; then
	    releases+=(" X.$channel")
	    releases+=("${versions[@]}")
	fi
    done
    list_instance_types list_all "install_version" '' "${releases[@]}" </dev/null
}

function installer_setup() {
    local -i not_latest=1
    local release_data
    local image
    local release_source=${OPENSHIFT_RELEASE_SOURCE:-https://${repo}.svc.ci.openshift.org/api/v1/releasestream}
    local installer_registry=${OPENSHIFT_INSTALL_REGISTRY:-registry.svc.ci.openshift.org/${subdir_map[$repo]:-}/release}
    #release_channel=${release_channel:-${release_base_map[$repo]:-}}
    if (( query )) ; then
	if [[ -z ${release_channel:-} ]] ; then
	    local -a channels=()
	    readarray -t channels <<< "$(echo 'all'; openshift-release-info -B "$repo" channels < /dev/null | sort -r)"
	    OPS3=${PS3:-}
	    PS3="Select channel: "
	    select release_channel in "${channels[@]}" ; do break; done
	    PS3=$OPS3
	fi
	if [[ $release_channel = 'all' ]] ; then
	    release_channel=
	fi
	local -a versions=()
	readarray -t versions <<< "$(openshift-release-info -B "$repo" ${release_channel:+-c "$release_channel"} releases < /dev/null | sort -r)"
	OPS3=${PS3:-}
	PS3="Select release: "
	select install_version in "${versions[@]}" ; do break; done
	PS3=$OPS3
    elif [[ -n ${release_channel:-} ]] ; then
	local -a versions=()
	read -r install_version <<< "$(openshift-release-info -B "$repo" ${release_channel:+-c "$release_channel"} releases < /dev/null | sort -r | head -1)"
    elif [[ $install_version = latest ]] ; then
	not_latest=0
	release_channel=${release_channel:-${release_base_map[$repo]:-}}
	echo "Retrieving release data from $release_source/$release_channel/latest"
	release_data="$(curl --silent "$release_source/$release_channel/latest")"
	[[ -n $release_data ]] || fatal "Can't extract release data!"
	install_version="$("$JQ" -r '.name' <<< "$release_data")"
	[[ -n $install_version ]] || fatal "Can't extract install version!"
    fi
    echo "Using version $install_version${not_latest:- (latest)}" 1>&2
    local -r pullspec="$installer_registry:$install_version"
    image=$("${OC}" adm release info --pullspecs "$pullspec" | awk '{if ($1 == "Pull") {print $3}}')
    [[ -z $image ]] && fail_find_image "$install_version"
    if (( ! force_local_tools )) ; then
	echo "Using installer from image ${image} ($ext_installer)" 1>&2
	installer_src=
	(do_installer_setup "$install_dir" "$image" "$install_version") || exit 1
	ext_installer="${install_dir}/openshift-install"
	install="$ext_installer"
	echo -e "installer version:\n$("$ext_installer" version |sed 's/^/    /')\n" 1>&2
    elif (( not_latest )) ; then
	 do_override=1
    fi
    if (( do_override && not_latest )) ; then
	export OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE=$pullspec
	export _OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE=$pullspec
    fi
}

# Try to catch obvious failures
function validate_environment() {
    [[ -n $masterconffile && ! -r $masterconffile ]] &&
	fatal "Master platform config $masterconffile not readable"
    [[ -n $workerconffile && ! -r $workerconffile ]] &&
	fatal "Worker platform config $workerconffile not readable"
    [[ -n $platformconffile && ! -r $platformconffile ]] &&
	fatal "Platform config $platformconffile not readable"
    (( host_prefix_bits < 8 || host_prefix_bits > 23 )) &&
	fatal "Host prefix size must be between 8 and 23"
    local f
    for f in quay.io registry.redhat.io registry.svc.ci.openshift.org ; do
	local g=${f//./\\.}
	grep -q "$g" "$pull_secret" || warn "No secret for '$f' in pull secret $pull_secret; expect installation to fail"
    done
    platform_dispatch validate
}

function confirm_install() {
    cat <<EOF
About to run installer:

Installer:         $install
EOF
    if [[ -n $installer_src ]] ; then
	cat <<EOF
Sourcedir:         $installer_src$([[ $installer_src != /* ]] && echo " ($(cd "$installer_src" && pwd))")
EOF
    fi
    cat <<EOF
Install dir:       $install_dir
Current dir:       $(pwd)
Install version:   $install_version
Override:          ${OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE:-}
Install command:   ${install} $loglevel --dir="$install_dir" create cluster
Configuration:

$OPENSHIFT_INSTALL_CONFIG
EOF
    (( noconfirm )) && return 0
    local proceed
    echo
    while : ; do
	read -p "Proceed? [YnevV!?] " -r proceed
	case "$proceed" in
	    y|Y|yes|YES|Yes|'')
		break
		;;
	    n|N|no|NO|No)
		echo "Not confirmed"
		return 1
		;;
	    '!')
		echo "Spawning shell..."
		(cd "$install_dir" && "$SHELL" -i)
		;;
	    e|E|edit|EDIT|Edit)
		echo "Editing config..."
		${EDITOR:-vi} "$install_dir/install-config.yaml"
		;;
	    V)
		env
		;;
	    v)
		set
		;;
	    '?')
		echo 'y   Proceed with installation'
		echo 'n   Do not proceed with installation'
		echo '!   Spawn shell'
		echo 'V   Print environment'
		echo 'v   Print all variable settings'
		echo 'e   Edit install-config.yaml'
		echo '?   Print this help'
		echo 'Abort installation with any other input'
		;;
	    *)
		;;
	esac
    done
    return 0
}

function start_kubechart_if_requested() {
    [[ -n $kubechart_port ]] && run_kubechart=1
    local run_oschart="$run_kubechart"
    if [[ -n $run_kubechart ]] ; then
	kubechart_port=${kubechart_port:-${default_kubechart_port}}
	oschart_port=$((kubechart_port+1))
    fi
    if [[ -x $kubechart && $run_kubechart -gt 0 ]] ; then
	created_kubechart=1
	run_kubechart&
	export OPENSHIFT_INSTALL_KUBECHART_URL=http://localhost:$kubechart_port/
    fi
    if [[ -x $oschart && $run_oschart -gt 0 ]] ; then
	created_oschart=1
	run_oschart&
	export OPENSHIFT_INSTALL_OSCHART_URL=http://localhost:$oschart_port/
    fi
}

function clean_secret() {
    local min_indent_prefix=
    while IFS= read -r line ; do
	if [[ -n $min_indent_prefix ]] ; then
	    if [[ $line = "${min_indent_prefix}"* ]] ; then
		continue
	    else
		min_indent_prefix=
	    fi
	fi
	if [[ $line =~ (( *)(sshKey: |pullSecret: ))([|]|.*) ]] ; then
	    [[ ${BASH_REMATCH[4]} = '|' ]] && min_indent_prefix="${BASH_REMATCH[2]} "
	    echo "${BASH_REMATCH[1]}..."
	else
	    echo "$line"
	fi
    done
    return 0
}

function _try_oc_login() {
    "${OC}" login -u kubeadmin -p "${OPENSHIFT_INSTALL_PASSWORD:-}"
}

function _try_console() {
    "${OC}" get route -n openshift-console -o name |grep -q '/console$'
}

function waitfor() {
    local tryfunc=$1
    local message=$2
    local fail_msg=${3:-$message failed.}
    local -i retry_limit=${4:-20}
    local -i sleep_interval=${5:-30}
    local try=0
    while (( try++ < retry_limit )) ; do
	echo -n "$message (try $try/$retry_limit)..."
	if $tryfunc ; then
	    echo "success!"
	    return 0
	fi
	echo "failed."
	(( try < retry_limit )) && sleep "$sleep_interval"
    done
    echo "$fail_msg"
    return 1
}

function oc_login() {
    waitfor _try_oc_login "Login"
}

function waitfor_console() {
    waitfor _try_console "Get console route" "Unable to get console route."
}

function report_install_failure() {
    local diagnostic_id
    local -i skip_auth_message=0
    cat <<'EOF'

*** Installation failed ***

EOF
    for diagnostic_id in "${!global_diagnostics[@]}" ; do
	"${global_diagnostics[$diagnostic_id]}" "$diagnostic_id" || skip_auth_message=1
    done
    (( skip_auth_message )) || warn_authentication_failure
}

function run_postinstall() {
    if [[ -f "{install_dir}/auth/kubeadmin-password" ]] ; then
	# shellcheck disable=SC2155
	export OPENSHIFT_INSTALL_PASSWORD=$(< "${install_dir}/auth/kubeadmin-password")
	if (( ! do_login )) ; then
	    echo "oc login skipped"
	elif oc_login ; then
	    login_succeeded=1
	    console_route=
	else
	    echo "oc login failed!"
	fi
    fi

    platform_dispatch postinstall
    do_create_bastion_if_needed

    if (( wait_for_complete && login_succeeded )) ; then
	echo -n "Waiting for console to come on line..."
	if "${___topdir:-}waitfor-pod" -r 10 console && waitfor_console ; then
	    console_route="$("${OC}" get route -n openshift-console -o "custom-columns=HOST:.status.ingress[0].host" --no-headers=true |grep ^console)"
	    if [[ -n $console_route && $console_route != '<none>' ]] ; then
		export OPENSHIFT_INSTALL_CONSOLE_ROUTE="https://$console_route"
		echo "Console route: $OPENSHIFT_INSTALL_CONSOLE_ROUTE"
		(xdg-open "$OPENSHIFT_INSTALL_CONSOLE_ROUTE" </dev/null >/dev/null 2>&1 &)
	    fi
	fi
	echo "login: kubeadmin / $OPENSHIFT_INSTALL_PASSWORD"
    fi
    if (( download_oc )) ; then
	local download_route
	download_route="$("${OC}" get route -n openshift-console -o "custom-columns=HOST:.status.ingress[0].host" --no-headers=true |grep ^downloads)"
	if [[ -n "$download_route" ]] ; then
	    if [[ ! -d "$install_dir/bin" ]] ; then
		mkdir "$install_dir/bin" || fatal "Can't create $install_dir/bin"
	    fi
	    echo "Downloading oc binary..."
	    if curl --silent --compressed -k "https://${download_route}/amd64/linux/oc" -o "$install_dir/bin/oc" ; then
		chmod +x "$install_dir/bin/oc"
		PATH="$install_dir/bin:$PATH"
	    else
		echo "Download failed!"
	    fi
	fi
    fi
    if (( ! cvo )) ; then
	echo "Disabling CVO..."
	"${OC}" patch deployment/cluster-version-operator -n openshift-cluster-version -p='{"spec":{"replicas":0}}'
    fi
    # shellcheck disable=SC2155
    export OPENSHIFT_INSTALL_NODE_IPS=$("${___topdir:-}"get-nodes)
    # shellcheck disable=SC2155
    export OPENSHIFT_INSTALL_WORKER_NODES=$(oc get nodes -l node-role.kubernetes.io/worker --no-headers=true -o name|sed -e 's,node/,,')
    # shellcheck disable=SC2155
    export OPENSHIFT_INSTALL_MASTER_NODES=$(oc get nodes -l node-role.kubernetes.io/master --no-headers=true -o name|sed -e 's,node/,,')
}

function run_install() {
    validate_environment
    if [[ -z $cleanup_only_dir ]] ; then
	[[ -n $install_version && ${force_local_tools:-0} -eq 0 ]] && installer_src=
	mkdir -p "$install_dir"
	[[ -n $install_version || -n $release_channel || $query -ne 0 ]] && installer_setup
	if [[ -n $config_file ]] ; then
	    [[ ! -r $config_file ]] && fatal "Cannot read config file $config_file"
	    cp "$config_file" "$install_dir/install-config.yaml"
	else
	    template > "$install_dir/install-config.yaml"
	fi
    else
	do_cleanup=1
	clean_shutdown=1
	install_stage=1
	install_dir=$cleanup_only_dir
    fi

    if (( clean_install_cache )) ; then
	echo "Cleaning installer cache"
	[[ -d $HOME/.cache/openshift-installer ]] && rm -rf "$HOME/.cache/openshift-installer"
	# Old-style name
	[[ -d $HOME/.cache/openshift-install ]] && rm -rf "$HOME/.cache/openshift-install"
    fi

    # We will need the installer even in cleanup-only mode,
    # in order to clean up the cluster.
    if [[ -z $ext_installer ]] ; then
	local -r cur_rev=$(cd "$installer_src" && git rev-parse @)
	if [[ ! -x $install || $rebuild -gt 0 ||
		  $("${install}" version| grep 'built from commit' |awk '{print $NF}') != "$cur_rev" ]] ; then
	    echo "Rebuilding installer"
	    # Not platform-independent
	    TAGS=libvirt "$installer_src/hack/build.sh" || fatal "Can't rebuild installer"
	fi
    else
	installer_src=
    fi

    trap cleanup EXIT SIGHUP SIGINT SIGQUIT SIGTERM
    [[ -z $cleanup_only_dir ]] || return

    # shellcheck disable=SC2155
    export KUBECONFIG="$(cd $install_dir && pwd)/auth/kubeconfig"

    # shellcheck disable=SC2155
    local start=$(tsec)

    install_stage=1
    OPENSHIFT_INSTALL_CONFIG="$(clean_secret < "$install_dir/install-config.yaml")"
    export OPENSHIFT_INSTALL_CONFIG
    confirm_install || exit 1
    if (( save_artifacts )) ; then
	(cd "$install_dir" || exit; tar cf - --exclude=saved-artifacts --exclude='openshift-*' --exclude=oc --exclude=kubectl -- * |(umask 77; mkdir -p saved_artifacts; cd saved_artifacts || exit; tar xf -))
    fi
    # Running create manifests blows away the install config.
    if (( edit_manifest || generate_manifest )) ; then
	run_installer create manifests </dev/null 2>&1 | timestamp
	if [[ $edit_manifest = "1" || $edit_manifest = 'true' ]] ; then
	    echo
	    echo "*** Spawning shell to edit manifests"
	    (cd "$install_dir" && "$SHELL" -i) || fatal "Edit manifest not confirmed"
	elif [[ -n "$edit_manifest" && $edit_manifest != '0' && $edit_manifest != 'false' ]] ; then
	    (cd "$install_dir" && $edit_manifest) || fatal "Edit manifest not confirmed"
	fi
    fi
    platform_dispatch preinstall
    if (( save_artifacts )) ; then
	(cd "$install_dir" || exit; tar cf - --exclude=saved_artifacts --exclude='openshift-*' --exclude=oc --exclude=kubectl -- * |(umask 77; cd saved_artifacts || exit; tar xf -))
    fi

    install_stage=2
    # Start kubechart/oschart (if needed) prior to running the installer
    start_kubechart_if_requested

    echo
    # shellcheck disable=SC2155
    local restorepipe="$(shopt -p lastpipe)"
    # Diagnostic processing must occur within the top level shell
    # so we can record any diagnostics that fire
    shopt -s lastpipe
    run_installer create cluster </dev/null 2>&1 | timestamp

    local install_status=${PIPESTATUS[0]}
    eval "$restorepipe"
    # shellcheck disable=SC2155
    local -i end1=$(tsec)
    local -i end2=0

    if (( install_status )) ; then
	report_install_failure
	clean_shutdown=0
    fi
    if (( force_postinstall || !install_status )) ; then
	run_postinstall
	end2=$(tsec)
    fi
    printerval "Installation" $((end1 - start))
    (( end2 )) && printerval "Total setup to console online" $((end2 - start))
    export OPENSHIFT_INSTALL_INTERLOCK=1
    export OPENSHIFT_INSTALL_VERSION=$install_version
    for f in "${!OPENSHIFT@}" "${!_OPENSHIFT@}" KUBECONFIG ; do eval "echo export $f=\${$f@Q}"; done > "${install_dir}/environment"
    # Run a shell even if setup failed, so it's possible to poke around
    (run_shell)
    case $? in
	77) do_cleanup=0 ;;
	88) do_cleanup=1 ;;
	*)               ;;
    esac
    clean_shutdown=1
}

function read_profile() {
    local profile="$1"
    if [[ ! -r $profile ]] ; then
	fatal "Can't read profile $profile"
    fi
    local value
    if [[ $profile = *.json ]] ; then
	while read -r key <<<"$(jq -r 'keys[]' "$profile")" ; do
	    value="$(jq -r ".\"$key\"" "$profile")" || fatal "Cannot process $key"
	    eval "key=\"$value\"" || fatal "Cannot process $key=$value"
	done
    else
	# shellcheck source=/dev/null
	. "$profile" || fatal "Cannot process profile $profile"
    fi
}

function process_option() {
    case "$1" in
	help-all*) help_extended	        ;;
	help*)     help			        ;;
	verbose)   loglevel='--log-level=debug' ;;
	quiet)     loglevel=			;;
	*)         options_to_process+=("$1")   ;;
    esac
}

function register_options() {
    if [[ -z ${____current_platform:-} ]] ; then
	fatal "Attempt to register options outside of platform definition"
    fi
    local opt
    for opt in "$@" ; do
	option_registrations[$opt]=$____current_platform
    done
}

function process_options() {
    while getopts ":BbCcd:HhKkLln:Oop:qUuV:vX:x:Yy-:" opt ; do
	case "$opt" in
	    B) run_kubechart=0		    ;;
	    b) run_kubechart=1		    ;;
	    C) clean_install_cache=0	    ;;
	    c) clean_install_cache=1	    ;;
	    d) install_dir="$OPTARG"        ;;
	    K) generate_cluster_key=0	    ;;
	    k) generate_cluster_key=1	    ;;
	    L) do_cleanup=1		    ;;
	    l) do_cleanup=0		    ;;
	    n) release_channel="$OPTARG"    ;;
	    O) overwrite=1                  ;;
	    o) overwrite=0                  ;;
	    p) read_profile "$OPTARG"       ;;
	    q) loglevel=		    ;;
	    U) query=0                      ;;
	    u) query=1                      ;;
	    V) install_version="$OPTARG"    ;;
	    v) loglevel='--log-level=debug' ;;
	    X|-) process_option "$OPTARG"   ;;
	    x) cleanup_only_dir="$OPTARG"   ;;
	    Y) noconfirm=0		    ;;
	    y) noconfirm=1		    ;;
	    H) help_extended		    ;;
	    h) help			    ;;
	    *) help "$OPTARG"               ;;
	esac
    done

    shift $((OPTIND - 1))

    if [[ -n ${1:-} ]] ; then
	install_type="$1"
	shift
    fi

    if [[ $install_version = list || $release_channel = list ]] ; then
	if [[ $release_channel = list ]] ; then 
	    list_release_channels
	else
	    list_install_versions "$release_channel"
	fi
	exit 0
    fi

    [[ -z "$*" ]] || echo "Warning: extraneous arguments $# after $install_type will be ignored!" 1>&2
}

function process_extended_options() {
    local option
    local optname
    local noptname
    local optvalue
    for option in "${options_to_process[@]}" ; do
	optname=${option%%=*}
	optvalue=${option#*=}
	noptname=${optname//-/_}
	# Simply testing for empty optvalue is wrong; that would not
	# allow for an empty value
	if [[ $option != *'='* ]] ; then
	    case "$noptname" in
		"no_"*|"dont_"*|"disable_"*|"without_"*)
		    noptname=${noptname#dont_}
		    noptname=${noptname#no_}
		    noptname=${noptname#disable_}
		    noptname=${noptname#without_}
		    optvalue=0
		    ;;
		"enable_"*|"with_"*)
		    noptname=${noptname#enable_}
		    noptname=${noptname#with_}
		    optvalue=1
		    ;;
		*)
		    optvalue=1
		    ;;
	    esac
	    option="${noptname}=${optvalue}"
	fi
	# Rule: all options must use _ rather than -
	if [[ -n "${option_registrations[$optname]:-}" ]] ; then
	    if [[ ${option_registrations[$optname]} = "$OPENSHIFT_INSTALL_PLATFORM" ]] ; then
		platform_dispatch set_option "$optname" "$optvalue"
	    else
		echo "Option $optname does not exist for platform $OPENSHIFT_INSTALL_PLATFORM"
	    fi
	else
	    eval "${option/$optname/$noptname}"
	fi
    done
}

function get_platform_path() {
    if [[ -z "${platform_path[*]}" ]] ; then
	platform_path=()
	if [[ -n ${OPENSHIFT_OINST_LIBDIR:-} ]] ; then
	    readarray -t platform_path <<< "${OPENSHIFT_OINST_LIBDIR//:/$'\n'}"
	fi
	platform_path+=("$___topdir")
    fi
}

function find_platforms() {
    declare -a ____new_vars
    declare -A ____var_map
    declare ____a
    declare ____f
    declare ____dir
    for ____dir in "${platform_path[@]}" ; do
	____dir=${____dir:-.}
	if [[ -d "$____dir/share/OpenShift/installer/platforms" ]] ; then
	    for ____f in "$____dir/share/OpenShift/installer/platforms"/* ; do
		declare -i ____warned_platvar=0
		____current_platform=${____f##*/}
		if [[ -z ${global_platforms[$____current_platform]:-} && $____current_platform != "."* && $____current_platform != *"~" && $____current_platform != '#'* && -f $____f ]] ; then
		    ____new_vars=()
		    ____var_map=()
		    while read -r ____a ; do
			____var_map[$____a]=1
		    done <<< "$(compgen -v; compgen -c)"
		    unset ____a
		    # shellcheck disable=SC1090
		    . "$____f"
		    readarray -t ____new_vars <<< "$(compgen -v; compgen -c)"
		    for ____a in "${____new_vars[@]}" ; do
			if [[ -z ${____var_map[$____a]:-} &&
				  $____a != "_____$____current_platform"* &&
				  $____a != "______$____current_platform"* ]] ; then
			    if ! ((____warned_platvar)) ; then
				echo "Unexpected variable/function names from $____current_platform platform defined in"
				echo "${____f//\/\//\/}"
				echo "Names should be prefixed with _____$____current_platform"
				____warned_platvar=1
			    fi
			    echo "    $____a"
			fi
		    done
		fi
		unset ____current_platform
	    done
	fi
    done
}

################################################################
### Execution starts here                                    ###
################################################################

get_platform_path
# Do this first so that if we request help we'll get a useful list of platforms
find_platforms
# Running nested installs is liable to be problematic
if [[ -n ${OPENSHIFT_INSTALL_INTERLOCK:-} ]] ; then
    if [[ ${1:-} = -h* || ${1:-} = -H* || ${1:-} = --help* ]] ; then
	echo "Already in ${___topsc:-oinst} environment!"
	help
    fi
    fatal "Already in ${___topsc:-oinst} environment"
fi

process_options "$@"
clear_env
if [[ -z ${install_type:-} ]] ; then
    for ____dir in "${platform_path[@]}" ; do
	____dir=${____dir:-.}
	if [[ -f "$____dir/share/OpenShift/installer/default-platform" ]] ; then
	    read -r install_type < "$____dir/share/OpenShift/installer/default-platform"
	    [[ -z $install_type ]] || break
	fi
    done
fi

if [[ -z ${install_type:-} ]] ; then
    for platform in "${global_platform_list[@]}" ; do
	install_type="$(platform_dispatch -p "$platform" default_install_type)"
	[[ -z $install_type ]] || break
    done
fi

OPENSHIFT_INSTALL_PLATFORM="$(find_first_platform is_install_type "$install_type")"

process_extended_options "${options_to_process[@]}"
master_type=${master_type:-$platform_type}
worker_type=${worker_type:-$platform_type}

[[ -n $OPENSHIFT_INSTALL_PLATFORM ]] || help

export OPENSHIFT_INSTALL_PLATFORM
platform_dispatch setup "$install_type"

OPENSHIFT_INSTALL_BASE_DOMAIN=$(platform_dispatch base_domain)
export OPENSHIFT_INSTALL_BASE_DOMAIN

[[ -n $ext_installer ]] && install="$ext_installer"
[[ $install_version = latest_default ]] && install_version=latest
export OPENSHIFT_INSTALL_CLUSTER_NAME=${install_dir:-${LOGNAME:-NOUSER}-${OPENSHIFT_INSTALL_PLATFORM}}

install_dir="${install_dir:-$OPENSHIFT_INSTALL_CLUSTER_NAME}"

if [[ -n $cleanup_only_dir ]] ; then
    if [[ ! -d $cleanup_only_dir ]] ; then
	echo "No install directory $cleanup_only_dir to clean up"
	exit 0
    fi
elif [[ -d $install_dir && $install_dir != . && $install_dir != .. &&
	    -n $(ls "$install_dir") ]] ; then
    if (( overwrite )) ; then
	echo "Removing $install_dir" 1>&2
	sleep 2
	rm -rf "$install_dir"
    else
	fatal "Install directory $install_dir already present; will not overwrite without -O"
    fi
fi

mkdir -p "$install_dir" || fatal "Can't create installation directory $install_dir"

if (( generate_cluster_key )) ; then
    OPENSHIFT_INSTALL_SSH_KEY=$(realpath "$install_dir/cluster")
    echo "Generating cluster key..."
    ssh-keygen -f "$OPENSHIFT_INSTALL_SSH_KEY" -N '' || {
	echo "Can't create cluster key"
	rm -rf "$install_dir"
	exit 1
    }
    pubkey_file="${OPENSHIFT_INSTALL_SSH_KEY}.pub"
    export OPENSHIFT_INSTALL_SSH_KEY
fi

run_install
