#!/bin/bash

# Copyright 2019 Robert Krawitz/Red Hat
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

function fatal() {
    echo "FATAL: $*" 1>&2
    exit 1
}

set -u

# Find our helpers
function finddir() {
    local path_to_file
    path_to_file=$(readlink -f "$0")
    if [[ -z $path_to_file ]] ; then
	return 1
    elif [[ -d $path_to_file ]] ; then
	echo "$path_to_file/"
    elif [[ -e $path_to_file ]] ; then
	echo "${path_to_file%/*}/"
    else
	return 1
    fi
    return 0
}

declare ___realsc=
declare ___topsc
if [[ -z ${___topsc:-} ]] ; then
    export ___topsc="${0##*/}"
    # shellcheck disable=SC2155
    export ___topdir="$(finddir "$0")"
    [[ -z $___topdir ]] && fatal "Can't find directory for $0"
fi

function print_help() {
    cat <<EOF
Usage: $___topsc [options] [install_type]
    install_type: one of
$(do_platforms help install_types | indent 7)
    Options (all are processed in order):
       -p profile           Read the specified profile file.  Profile
                            may be a JSON file or shell code.
       -X option=value      Set the specified extended option.
       -H                   Print list of additional extended command
                            line options.

    Options listed as -a/-A are inverted by the second listed option.
       -b/-B                Launch kubechart and oschart (if available).
                            See https://github.com/sjenning/kubechart
                            KEY: run_kubechart (default=0)
       -c/-C                Clean install cache, in case it is corrupted.
                            KEY: clean_install_cache (default=0)
       -d install_dir       Use the specified dir as working directory and
                            cluster name.  Default is ${LOGNAME:-}-<platform>.
       -l/-L                Don't clean up on exit.  You can exit with status
                            77 for no cleanup or 88 to force cleanup.
                            KEY: do_cleanup (default=1)
       -n release_channel   Use the specified release channel.
       -O/-o                Allow overwrite an existing install directory.
                            KEY: overwrite (default=0)
       -u/-U                Query for release (and optionally channel) to use.
                            KEY: query (default=0)
       -V install_version   Install the specified image version (default
                            latest).  Use '$___topsc -H' for more details.
       -v/-q                Print debug information.
                            KEY/VALUE: loglevel='--log-level=debug'
       -x cleanup_only_dir  Only clean up (requires cluster already exists).
       -y/-Y                Do not prompt prior to starting install
                            KEY: noconfirm (default=0)
EOF
}

function help() {
    [[ -n ${1:-} ]] && echo "$___topsc: Unknown option $1"
    print_help
    exit 1
}

function help_extended() {
    print_help
    cat <<EOF

    Other options with no short command line option (with -X):
      Generic cluster configuration:
        host_prefix_bits    Use the specified host prefix size (default $host_prefix_bits,
                            must be between 8 and 24)
        master_count        Use the specified number of master nodes.
                            Default by platform.
        masterconfdata      Specify the data for master configuration.
        masterconffile      Take master platform config from specified file.
        platformconfdata    Specify the data for platform configuration.
        platformconffile    Take platform configuration from specified file.
        worker_count        Use the specified number of worker nodes.
                            Default by platform.
        workerconfdata      Specify the data for worker configuration.
        workerconffile      Take master platform config from specified file.
$(do_platforms help options |indent -6)

      Installation options:
        config_file         Use the specified file as the install config file.
        do_login            Login to the console (default=1)
        ext_installer       Use the specified command to install OpenShift.
        force_postinstall   Always run the postinstall even if setup fails.
        install_domain      Use the specified domain name.
$(do_platforms help default_domain | indent -28)
        install_version     Install the specified image version.  Default
                            is to use the latest version.
                            Use empty value to install from local workspace
                            (\$GOPATH/src/github.com/openshift/installer)
        install_type        Specify the install type, as described above.
        kubechart_port      Use the specified port for kubechart.  oschart
                            runs at port+1.  Implies -b.  Default is ${default_kubechart_port}.
        pubkey_file         Specify the path to the desired public key
                            Default $pubkey_file
        pull_secret         Specify the path to the pull secret.
                            Default $pull_secret
        rebuild             Always rebuild the installer, when using local
                            installer.
        repo                Use the specified repo (default $default_repo_base).
        run_command         Run the specified command rather than an
                            interactive shell on completion of installation.
        wait_for_complete   Wait for console to come online (default=1)

    The following extended options are normally not recommended:
       api_version          Use the specified API version (default $api_version).
       do_override          Override install image.
       force_local_tools    Use the local toolchain to install with.
EOF
    exit 1
}

function clean_startup() {
    [[ -f $___realsc ]] && rm -f "$___realsc"
}

# This allows us to edit the script while another instance is running
# since this script sticks around until the user exits the spawned shell.
# It's fine for the running script to be removed, since the shell still
# has its open file descriptor.
if [[ $# = 0 || $1 != "--DoIt=$0" ]] ; then
    tmpsc=$(mktemp)
    [[ -z $tmpsc || ! -f $tmpsc || -L $tmpsc ]] && fatal "Can't create temporary script file"
    trap clean_startup EXIT SIGHUP SIGINT SIGQUIT SIGTERM
    PATH+=${PATH:+:}$___topdir
    cat "$0" > "$tmpsc"
    chmod +x "$tmpsc"
    exec "$tmpsc" "--DoIt=$tmpsc" "$@"
else
    ___realsc=${1#--DoIt=}
    clean_startup
    shift
fi

# Globals
declare -A release_base_map=()
release_base_map[origin-release]='4.2.0-0.okd'
release_base_map[openshift-release]='4-stable'

declare -A subdir_map=()
subdir_map[origin-release]='origin'
subdir_map[openshift-release]='ocp'

declare -r kubechart=${KUBECHART:-$GOPATH/src/github.com/sjenning/kubechart/kubechart}
declare -r oschart=${OSCHART:-$GOPATH/src/github.com/sjenning/oschart/oschart}
declare -r default_repo_base=openshift-release

declare -a global_platforms=()

declare -A global_diagnostics=()

declare install_type=
declare install_domain=${OPENSHIFT_INSTALL_DOMAIN:-}
declare install_dir=${OPENSHIFT_INSTALL_DIR:-$install_domain}
declare install_version=latest_default
declare pull_secret=${OPENSHIFT_INSTALL_PULL_SECRET_PATH:-$HOME/Downloads/pull-secret}
declare pubkey_file=${OPENSHIFT_INSTALL_SSH_PUB_KEY_PATH:-$HOME/.ssh/id_rsa.pub}
declare srcdir=${GOPATH:-$HOME/go}/src/github.com/openshift/installer
declare install=$srcdir/bin/openshift-install
declare release_channel=
declare repo=$default_repo_base

# shellcheck disable=SC2155
declare -r OC=$(type -p oc)
[[ -z $OC ]] && fatal "Can't find oc command"
# shellcheck disable=SC2155
declare -r JQ=$(type -p jq)
[[ -z $JQ ]] && fatal "Can't find jq command"
# shellcheck disable=SC2155
declare -r owd=$(pwd)
declare -i clean_install_cache=0
declare -i clean_shutdown=0
declare -i cleanup_run=0
declare -i created_kubechart=0
declare -i created_oschart=0
declare -i do_cleanup=1
declare -i do_login=1
declare -i do_override=0
declare -i force_local_tools=0
declare -i force_postinstall=0
declare -i install_stage=0
declare -i login_succeeded=0
declare -i master_count=0
declare -i noconfirm=0
declare -i overwrite=0
declare -i query=0
declare -i rebuild=0
declare -i run_kubechart=0
declare -i run_oschart=0
declare -i wait_for_complete=1
declare -i worker_count=0
declare -i host_prefix_bits=23
declare api_version=v1
declare cleanup_only_dir=
declare config_file=
declare console_route=
declare ext_installer=
declare -r -i default_kubechart_port=3000
declare kubechart_port=
declare loglevel=
declare oschart_port=
declare release_source=
declare run_command=
declare masterconffile=
declare masterconfdata=
declare workerconffile=
declare workerconfdata=
declare platformconffile=
declare platformconfdata=

# Running nested installs is liable to be problematic
if [[ -n ${OPENSHIFT_INSTALL_INTERLOCK:-} ]] ; then
    if [[ ${1:-} = -h* ]] ; then
	echo "Already in ${___topsc:-oinst} environment!"
	help
    fi
    fatal "Already in ${___topsc:-oinst} environment"
fi

[[ -z $OC ]] && fatal "Can't find oc command"

function clear_env() {
    local var
    for var in "${!_OPENSHIFT_INSTALL@}" "${!OPENSHIFT_INSTALL@}" KUBECONFIG ; do unset "$var"; done
}

function printerval() {
    local milestone=$1
    local interval=$2
    echo -n "$milestone took "
    local h=$((interval / 3600))
    (( h > 0 )) && echo -n "$h:"
    printf "%02d:%02d\n" $(((interval % 3600) / 60)) $((interval % 60))
}

function set_diagnostic() {
    local diagnostic_id="$1"
    local print_diagnostic_message_func="$2"
    global_diagnostics["$diagnostic_id"]="$print_diagnostic_message_func"
}

function _timestamp() {
    while read -r REPLY ; do
	do_platforms diagnose "$REPLY"
	# Make the message look vaguely Go-like.
	printf 'T0000 %(%H:%M:%S)T.000000   %s\n' -1 "$REPLY"
    done
}

function timestamp() {
    if [[ -n "$*" ]] ; then
	_timestamp <<< "$*"
    else
	_timestamp
     fi
}

function tsec() {
    printf "%(%s)T" -1
}

function indent() {
    local -i depth=${1:-2}
    local -i always_indent=0
    if (( depth < 0 )) ; then
	depth=$((-depth))
	always_indent=1
    fi
    # shellcheck disable=SC2155
    local sol=$(printf "%${depth}s" '')
    while IFS='' read -r line ; do
	[[ always_indent -eq 0 && -z $line ]] || echo "$sol$line"
    done
}

function cmdline_replicas() {
    local node_type=$1
    local default=$2
    local actual=0
    case "$node_type" in
	master) actual=$master_count ;;
	worker) actual=$worker_count ;;
	*)                           ;;
    esac
    (( actual == 0 )) && actual=$default
    echo "$actual"
}

function dispatch_unknown() {
    local platform=$1
    shift
    die "Unexpected command ($platform): $*"
}

# The exact operation of the ssh-bastion varies between providers, and
# isn't supported by everything (e. g. libvirt).
function do_create_bastion() {
    echo "Creating bastion host"
    curl -s -S https://raw.githubusercontent.com/eparis/ssh-bastion/master/deploy/deploy.sh | bash
    # shellcheck disable=SC2181
    if (( $? )) ; then
	echo "Create bastion host failed"
    else
	echo "Alternatively, you may prefer to use ${___topdir:-}bastion-ssh"
	# shellcheck disable=SC2155
	export OPENSHIFT_BASTION_ADDRESS="$(oc get service -n openshift-ssh-bastion ssh-bastion -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')"
	[[ -z $OPENSHIFT_BASTION_ADDRESS ]] && echo "Unable to find bastion address!"
    fi
}

function add_platform() {
    local -r platform=$1
    local plat
    for plat in "${global_platforms[@]}" ; do
	if [[ $platform = "$plat" ]] ; then
	    return
	fi
    done
    global_platforms+=("platform")
}

################################################################
### libvirt platform code				     ###
################################################################

declare -i _libvirt_created_proxy=0
add_platform libvirt

function _libvirt_find_default_domain() {
    # shellcheck disable=SC2155
    local files=$(find /etc/NetworkManager/dnsmasq.d/ -type f -name '*.conf' -print)
    [[ -z $files ]] && fatal "No dnsmasq files in /etc/NetworkManager/dnsmasq.d"
    local dnsmasq_domain=
    for f in $files ; do
	# shellcheck disable=SC2155
	local data=$(< "$f")
	data=${data#*/}
	data=${data%/*}
	[[ -n $dnsmasq_domain && $data != "$dnsmasq_domain" ]] &&
	    fatal "Multiple domains found in /etc/NetworkManager/dnsmasq.d; pick one"
	[[ -n $data ]] && dnsmasq_domain=$data
    done
    [[ -z $dnsmasq_domain ]] && fatal "No dnsmasq files in /etc/NetworkManager/dnsmasq.d"
    echo "$dnsmasq_domain"
}

function _libvirt_setup() {
    export OPENSHIFT_INSTALL_LIBVIRT_URI="qemu+tcp://192.168.122.1/system"
    if [[ $install_version = latest_default ]] ; then
	install_version=
	force_local_tools=1
	ext_installer=
	echo "*** Using local installer with libvirt"
    fi
    if (( clean_install_cache )) ; then
	echo "Cleaning install cache in ~/.cache/openshift-install/libvirt"
	[[ -d $HOME/.cache/openshift-install/libvirt ]] && rm -rf "$HOME/.cache/openshift-install/libvirt"
    fi
}

function _libvirt_base_domain() {
    echo "${install_domain:-$(find_libvirt_default_domain)}"
}

function _libvirt_replicas() {
    cmdline_replicas "$1" 1
}

function _libvirt_platform() {
    # maipo is channel, not base.
    #local baseURL='https://releases-rhcos.svc.ci.openshift.org/storage/releases/maipo'
    #local install_version=${install_version:-"$(curl --silent "$baseURL/builds.json" | "$JQ" -r '.builds[0]')"}
    cat <<EOF
libvirt:
  URI: $OPENSHIFT_INSTALL_LIBVIRT_URI
  network:
    if: tt0
EOF
}

function _libvirt_volume_present() {
    local vol="$1"
    local v
    for v in $(virsh --quiet vol-list --pool default |awk '{print $1}') ; do
	[[ $v = "$vol" ]] && return 0
    done
    return 1
}

function _libvirt_delete_volume() {
    local vol
    for vol in "$@" ; do
	if _libvirt_volume_present "$vol" ; then
	    echo "Deleting volume $vol"
	    virsh vol-delete --pool default "$vol"
	fi
    done
}

function _libvirt_destroy_net() {
    local net
    for net in "$@" ; do
	if virsh --quiet net-list --all |awk '{print $1}' |grep -q "$net" ; then
	    echo "Destroying net $net"
	    virsh net-destroy "$net"
	    virsh net-undefine "$net"
	fi
    done
}

function _libvirt_destroy_node() {
    local node
    for node in "$@" ; do
	if virsh --quiet list --all |awk '{print $2}' |grep -q "$node" ; then
	    echo "Destroying $node"
	    virsh destroy "$node"
	    virsh undefine "$node"
	    _libvirt_delete_volume "$node"
	fi
    done
}

# See https://github.com/openshift/installer/issues/411#issuecomment-446084083
function _libvirt_run_proxy() {
    # The proxy has a bad habit of dying every now and then.
    while : ; do
	# It's simply too noisy.
	${OC} -n openshift-ingress port-forward svc/router-internal-default 443 >/dev/null 2>&1
	# If we die by signal, stop.
	(( $? >= 128 )) && break
    done
}

function _libvirt_cleanup() {
    exec 3>&2 2>/dev/null
    if (( _libvirt_created_proxy )) ; then
	kill -9 %_libvirt_run_proxy
	wait %_libvirt_run_proxy
    fi
    exec 2>&3 3>&-
    # shellcheck disable=SC2155
    local cluster_name=$(virsh --quiet net-list | awk '{print $1}' | grep "^$OPENSHIFT_INSTALL_CLUSTER_NAME")
    [[ -z $cluster_name ]] && return
    local tmp
    echo -n "Destroying workers..."
    while read -r tmp ; do
	_libvirt_destroy_node "$tmp"
    done <<< "$(virsh list --name |grep -E "^(${cluster_name}-)?worker-")"
    _libvirt_destroy_net "$cluster_name"
    while read -r tmp ; do
	_libvirt_destroy_net "$tmp"
    done <<< "$(virsh --quiet net-list | awk '{print $1}' | grep "^${cluster_name}")"
    _libvirt_destroy_node "${cluster_name}-bootstrap"
    _libvirt_destroy_node "${cluster_name}-master-0"
    for f in base master-0 master.ign worker.ign bootstrap bootstrap.ign ; do
	_libvirt_delete_volume "${cluster_name}-$f"
    done
    while read -r tmp ; do
	_libvirt_delete_volume "$tmp"
    done <<< "$(virsh --quiet vol-list --pool default | awk '{print $1}' | grep "^${cluster_name}")"
}

function _libvirt_postinstall() {
    (( ! wait_for_complete )) && return
    timestamp "Waiting for DNS to come on line..."
    "${___topdir:-}waitfor-pod" -r 10 dns-default
    timestamp "Waiting for router to come on line..."
    "${___topdir:-}waitfor-pod" -r 10 router-default
    # See https://github.com/openshift/installer/issues/411#issuecomment-445202069
    timestamp echo "Creating route proxy"
    if getcap -vr "${OC}" | grep -q "cap_net_bind_service+eip" ; then
	timestamp echo "Enabling bind to privileged port for ${OC}, may need sudo password"
	sudo setcap CAP_NET_BIND_SERVICE=+eip "${OC}"
    fi
    _libvirt_run_proxy 2>&1 |grep -v 'Setting up router connection for 443' &
    _libvirt_created_proxy=1
}

function _libvirt_machine_cidr() {
    echo '192.168.126.0/24'
}

function _libvirt_default_install_type() {
    echo libvirt
}

function _libvirt_help() {
    case "$1" in
	install_types)
	    cat <<\EOF
libvirt
EOF
	    ;;
	default_domain)
	    cat <<\EOF
For libvirt: default is taken from a unique entry
    in /etc/NetworkManager/dnsmasq.d, if available.
EOF
	    ;;
	*)  ;;
    esac
}

function _libvirt_is_install_type() {
    [[ $1 = libvirt ]]
}

function _libvirt_print_diagnostics() {
    case "$1" in
	_libvirt_api_plugin_incompatibility_detected)
	    cat <<'EOF'
* Error message suggests a stray 'terraform-provider-libvirt' binary.
  Please remove all files of that name from your home directory and
  try again.

EOF
	    ;;
    esac
}

function _libvirt_diagnose() {
    case "$*" in
	'Tried to create resource record set')
	    set_diagnostic _libvirt_api_plugin_incompatibility_detected _libvirt_print_diagnostic
	    ;;
    esac
}

function libvirt_dispatch() {
    local op="$1"
    shift
    case "$op" in
	base_domain)          _libvirt_base_domain "$@"          ;;
	cleanup)              _libvirt_cleanup "$@"              ;;
	default_install_type) _libvirt_default_install_type "$@" ;;
	diagnose)	      _libvirt_diagnose "$@"		 ;;
	help)                 _libvirt_help "$@"		 ;;
	is_install_type)      _libvirt_is_install_type "$@"      ;;
	machine_cidr)         _libvirt_machine_cidr "$@"         ;;
	master)               :                                  ;;
	platform)             _libvirt_platform "$@"             ;;
	postinstall)          _libvirt_postinstall "$@"          ;;
	replicas)             _libvirt_replicas "$@"             ;;
	setup)                _libvirt_setup "$@"                ;;
	validate)             :                                  ;;
	worker)               :                                  ;;
	*)                    dispatch_unknown libvirt "$@"      ;;
    esac
}

################################################################
### AWS platform code					     ###
################################################################

add_platform aws

declare aws_worker_type=
declare aws_master_type=
declare -i aws_create_bastion=1
declare -r aws_default_domain=devcluster.openshift.com

declare -ar _aws_known_instance_types=("X.General Purpose"
				       # ARM instances aren't useful
				       # a1.{medium,{,{,2,4}x}large}
				       m5{,d}.{{,{,2,4,8,12,16,24}x}large,metal}
				       m5{a,n,dn}.{,{,2,4,8,12,16,24}x}large
				       m5ad.{,{,2,4,12,24}x}large
				       m4.{,{,2,4,10,16}x}large
				       "X.Burstable"
				       t{3,3a,2}.{nano,micro,small,medium,{,x,2x}large}
				       "X.Compute Optimized"
				       c4.{,{,2,4,8}x}large
				       c5.{{,{,2,4,9,12,18,24}x}large,metal}
				       c5d.{,{,2,4,9,18}x}large
				       c5n.{{,{,2,4,9,18}x}large,metal}
				       "X.Memory Optimized"
				       r4.{,{,2,4,8,16}x}large
				       r5{,d}.{{,{,2,4,8,12,16,24}x}large,metal}
				       r5{a,n,dn}.{,{,2,4,8,12,16,24}x}large
				       r5ad.{,{,2,4,12,24}x}large
				       x1e.{,2,4,8,16,32}xlarge
				       x1.{16,32}xlarge
				       "X.Single Thread Optimized"
				       z1d.{{,{,2,3,6,12}x}large,metal}
				       # High Memory are special dedicated-only hosts
				       # Y.u-t{6,9}tb1.metal
				       # Y.u-t{12,18,24}tb1.metal
				       "X.Storage Optimized"
				       i3.{{,{,2,4,8,16}x}large,metal}
				       i3en.{{,{,2,3,6,12,24}x}large,metal}
				       d2.{,2,4,8}xlarge
				       h1.{2,4,8,16}xlarge
				       "X.GPU"
				       p3.{2,8,16}xlarge
				       p3dn.24xlarge
				       p2.{,8,16}xlarge
				       g4dn.{{,2,4,8,12,16}xlarge,metal}
				       g3s.xlarge g3.{4,8,16}xlarge
				       # FPGA instances are of no use for
				       # running OpenShift
				       # f1.{2,4,16}xlarge
				     )

function _aws_list_instance_types() {
    local -i list_all=0
    cat <<\EOF
Currently known _AWS instance types.  Note that not all types are
available in all regions, and _AWS may add additional types at
any time.  See https://_aws.amazon.com/ec2/instance-types/
for current information about what instance types exist, and
https://_aws.amazon.com/ec2/pricing/on-demand/ for information
about what instance types are available in a particular region.
EOF
    if [[ ${1:-} = list_all ]] ; then
	list_all=1
    else
	echo "Use '$___topsc -X aws_master_type=list-all' to list all instance types."
    fi
    echo
    local last_class=
    local -i tot_cols=0
    local -i groups_printed=0
    # shellcheck disable=SC2155
    local -i term_width=$(tput cols 2>/dev/null)
    local i
    for i in "${_aws_known_instance_types[@]}" ; do
	case "$i" in
	    X.*)
		(( list_all == 0 && groups_printed++ )) && break
		echo -en "${last_class:+\n\n}${i#X.}:"
		;;
	    Y.*)
		echo -ne "\n ${i#*.}"
		;;
	    Z.*)
		echo -ne " ${i#*.}"
		;;
	    ${last_class}.*)
		tot_cols+=9
		if (( term_width > 20 && tot_cols > (term_width - 5) )) ; then
		    printf "\n        %-8s" "${i#*.}"
		    tot_cols=16
		else
		    printf " %-8s" "${i#*.}"
		fi
		;;
	    *)
		printf "\n %-6s %-8s" "${i%%.*}:" "${i#*.}"
		tot_cols=10
		last_class=${i%%.*}
		;;
	esac
    done
    echo
}

function _aws_check_instance_type() {
    local _aws_type="${1:-}"
    [[ -z $_aws_type ]] && return 0
    local i
    for i in "${_aws_known_instance_types[@]}" ; do
	[[ $i = "$_aws_type" ]] && return 0
    done
    echo "*** WARNING: '$_aws_type' is not a currently known AWS instance type!"
    local _aws_prefix=${_aws_type%%.*}
    local j=0
    for i in "${_aws_known_instance_types[@]}" ; do
	if [[ $_aws_prefix = "${i%%.*}" ]] ; then
	   (( j++ )) || echo "Possible candidates:"
	   echo -n " $i"
	fi
    done
    echo -e '\n'
    if (( j )) ; then
	return 1
    else
	return 2
    fi
}

function _aws_validate() {
    if [[ $aws_master_type = list-all || $aws_worker_type = list-all ||
	  $aws_master_type = list_all || $aws_worker_type = list_all ]] ; then
	_aws_list_instance_types list_all
	exit
    fi
    if [[ $aws_master_type = list || $aws_worker_type = list ]] ; then
	aws_list_instance_types
	exit
    fi
    local need_to_list_instance_types=0
    _aws_check_instance_type "$aws_master_type"
    (( $? == 2 )) && need_to_list_instance_types=1
    _aws_check_instance_type "$aws_worker_type"
    (( $? == 2 )) && need_to_list_instance_types=1
    (( need_to_list_instance_types )) && _aws_list_instance_types
    return 0
}

function _aws_setup() {
    local region=${1#aws}
    region=${region#[-._]}
    case "$region" in
	1|'') export OPENSHIFT_INSTALL_AWS_REGION=us-east-1 ;;
	2)    export OPENSHIFT_INSTALL_AWS_REGION=us-east-2 ;;
	3)    export OPENSHIFT_INSTALL_AWS_REGION=us-west-1 ;;
	4)    export OPENSHIFT_INSTALL_AWS_REGION=us-west-2 ;;
	?*)   export OPENSHIFT_INSTALL_AWS_REGION=$region   ;;
    esac
}

function _aws_replicas() {
    cmdline_replicas "$1" 3
}

function _aws_default_install_type() {
    for a in _aws _aws2 _aws3 _aws4; do
	echo $a
    done | shuf --head-count 1
}

function _aws_help() {
    case "$1" in
	install_types)
	    cat <<\EOF
Default is random _aws zone.
aws     (aws us-east-1)
aws2    (aws us-east-2)
aws3    (aws us-west-1)
aws4    (aws us-west-2)
aws-*   (specified AWS region)
EOF
	    ;;
	options)
	    echo
	    cat <<EOF
AWS-specific cluster configuration:
  aws_create_bastion  Create ssh bastion host (default=1)
  aws_master_type     Type of master instance.
  aws_worker_type     Type of worker instance.
    Use "list" with either to get a (known) list of instance types.
EOF
	    ;;
	default_domain)
	    cat <<\EOF
For AWS: default is $aws_default_domain.
EOF
	    ;;
	*)  ;;
    esac
}

function _aws_master() {
    if [[ -n $aws_master_type ]] ; then
	cat <<EOF

aws:
  type: "$aws_master_type"
EOF
    fi
}

function _aws_worker() {
    if [[ -n $aws_worker_type ]] ; then
	cat <<EOF

aws:
  type: "$aws_worker_type"
EOF
    fi
}

function _aws_platform() {
    cat <<EOF
aws:
  region: $OPENSHIFT_INSTALL_AWS_REGION
EOF
}

function _aws_machine_cidr() {
    echo '10.0.0.0/16'
}

function _aws_base_domain() {
    echo "${install_domain:-$aws_default_domain}"
}

function _aws_is_install_type() {
    [[ $1 = aws* ]]
}

function _aws_postinstall() {
    if (( aws_create_bastion )) ; then
	do_create_bastion
    fi
}

function _aws_print_diagnostic() {
    case "$1" in
	'Tried to create resource record set')
	    cat <<'EOF'
* Error message suggests that the installer tried to create a resource
  that already exists.  This resource needs to be tracked down and
  cleaned up.

EOF
	    ;;
    esac
}

function _aws_diagnose() {
    case "$*" in
	'Tried to create resource record set')
	    set_diagnostic _aws_existing_resource_detected _aws_print_diagnostic
	    ;;
    esac
}

function aws_dispatch() {
    local op="$1"
    shift
    case "$op" in
	base_domain)          _aws_base_domain "$@"          ;;
	cleanup)              :                              ;;
	default_install_type) _aws_default_install_type "$@" ;;
	diagnose)	      _aws_diagnose "$@"	     ;;
	help)                 _aws_help "$@"                 ;;
	is_install_type)      _aws_is_install_type "$@"      ;;
	machine_cidr)         _aws_machine_cidr "$@"         ;;
	master)               _aws_master "$@"               ;;
	platform)             _aws_platform "$@"             ;;
	postinstall)          _aws_postinstall "$@"          ;;
	replicas)             _aws_replicas "$@"             ;;
	setup)                _aws_setup "$@"                ;;
	validate)             _aws_validate "$@"             ;;
	worker)               _aws_worker "$@"               ;;
	*)                    dispatch_unknown aws "$@"      ;;
    esac
}

################################################################
### Generic code					     ###
################################################################

function platform_dispatch() {
    if [[ $1 = -p ]] ; then
	shift
	local platform=$1
	shift
	"${platform}_dispatch" "$@"
    elif [[ -n ${OPENSHIFT_INSTALL_PLATFORM} ]] ; then
	"${OPENSHIFT_INSTALL_PLATFORM}_dispatch" "$@"
    else
	local -i status=0
	local platform
	for platform in "${global_platforms[@]}" ; do
	     "${platform}_dispatch" "$@" || status=1
	done
	return $status
    fi
}

function do_platforms() {
    OPENSHIFT_INSTALL_PLATFORM='' platform_dispatch "$@"
}

function find_first_platform() {
    local platform
    for platform in "${global_platforms[@]}" ; do
	if platform_dispatch -p "$platform" "$@" ; then
	    echo "$platform"
	    return 0
	fi
    done
    return 1
}

function cleanup() {
    (( cleanup_run )) && exit
    (( !clean_shutdown  && install_stage >= 2 )) && echo -en '\n*** '
    case "$install_stage" in
	0) ;;
	1)
	    [[ -n $srcdir && -n $install_dir && -d "$srcdir/$install_dir" ]] && rm -rf "${srcdir:?}/${install_dir:?}"
	    ;;
	*)
	    echo "Cleaning up, please do not interrupt"
	    if (( do_cleanup )) ; then
		# Shut up some very uninteresting noise
		exec 3>&2 2>/dev/null
		if (( created_kubechart )) ; then
		    kill -9 %run_kubechart
		    wait %run_kubechart
		fi
		if (( created_oschart )) ; then
		    kill -9 %run_oschart
		    wait %run_oschart
		fi
		exec 2>&3 3>&-
		# shellcheck disable=SC2086
		"${install}" $loglevel "--dir=$srcdir/$install_dir" destroy cluster 2>&1 |timestamp
		if (( PIPESTATUS[0] == 0 || clean_install_cache)) ; then
		    [[ -n $srcdir && -n $install_dir && -d "$srcdir/$install_dir" ]] && rm -rf "${srcdir:?}/${install_dir:?}"
		else
		    echo "$install --dir=$srcdir/$install_dir destroy cluster failed, not removing install dir!"
		fi
		platform_dispatch cleanup
	    else
		cat 1>&2 <<EOF
*** Not cleaning up!
*** When you are finished, run:

"${install}" $loglevel "--dir=$srcdir/$install_dir" destroy cluster
EOF
	    fi
	    ;;
    esac
    cleanup_run=1
    exit
}

function platform_data() {
    local what=${1:-}
    local data=${2:-}
    local file=${3:-}
    local -i indent=${4:-0}
    local platform_code
    if [[ -n $data ]] ; then
	platform_code="$data"
    elif [[ -n $file && -r $file ]] ; then
	platform_code="$(< "$file")"
    else
	platform_code=${what:+$(platform_dispatch "$what")}
    fi
    if [[ -z $platform_code ]] ; then
	echo '{}'
    else
	echo
	indent "$indent" <<< "$platform_code"
    fi
}

# This has the problem that the install config format can change and
# we're left chasing it.  But much of the idea of this script is that
# people not have to run the installer interactively.
function template() {
    sed -e 's/[ \t]*$//' -e '/^$/d' <<EOF
apiVersion: $api_version
baseDomain: $(platform_dispatch base_domain)
compute:
- hyperthreading: Enabled
  name: worker
  platform: $(platform_data worker "${workerconfdata:-}" "${workerconfdata:-}" 4)
  replicas: $(platform_dispatch replicas worker)
controlPlane:
  hyperthreading: Enabled
  name: master
  platform: $(platform_data master "${masterconfdata:-}" "${masterconfdata:-}" 4)
  replicas: $(platform_dispatch replicas master)
metadata:
  creationTimestamp: null
  name: $OPENSHIFT_INSTALL_CLUSTER_NAME
networking:
  clusterNetwork:
  - cidr: 10.128.0.0/14
    hostPrefix: $host_prefix_bits
  machineCIDR: $(platform_dispatch machine_cidr)
  networkType: OpenShiftSDN
  serviceNetwork:
  - 172.30.0.0/16
platform: $(platform_data platform "${platformconfdata:-}" "${platformconfdata:-}" 4)
pullSecret: '$(jq -scM '.[0]' < "$pull_secret")'
sshKey: |
  $(< "$pubkey_file")
EOF
}

# Use this to determine whether we need some particular workaround.
# Most of the time it will be more problematic than it's worth to
# do something like this, but occasionally we may need to
# temporarily.
function git_newer_than() {
    local -l rev="$1"
    git rev-parse -q --verify "$rev" -- >/dev/null 2>&1 || return 1
    [[ -n $(git rev-list "@..$(git rev-parse "$rev")") ]]
}

function wait_and_run() {
    until [[ -f $KUBECONFIG ]] ; do sleep 1; done
    cmd=${1##*/}
    echo "Starting $cmd..." | timestamp
    if [[ $loglevel = '--log-level=debug' ]] ; then
	exec "$@"
    else
	exec "$@" >/dev/null 2>&1
    fi
}

# We need actual commands/functions named run_kubechart and run_oschart with
# known names, so that they can be waited for.
function run_kubechart() {
    wait_and_run "$kubechart" ${kubechart_port:+--http-port "$kubechart_port"}
}

function run_oschart() {
    wait_and_run "$oschart" ${oschart_port:+--http-port "$oschart_port"}
}

function run_shell() {
    cd "$owd" || fatal "Cannot cd to $owd"
    if [[ -n $run_command ]] ; then
	exec "$SHELL" -c "$run_command"
    else
	if (( do_cleanup )) ; then
	    timestamp "Spawning interactive shell.  Exit with status 77 to suppress cleanup."
	else
	    timestamp "Spawning interactive shell.  Exit with status 88 to clean up."
	fi
	exec "$SHELL" -i
    fi
}

function warn_authentication_failure() {
cat <<\EOF
* You need to download your pull secrets.

  Visit https://try.openshift.com and log in.  Click on Create
  Cluster/Self-Installed Cluster
  (https://cloud.redhat.com/openshift/install) and select your
  appropriate cloud provider.  From there, select User-Provisioned
  Infrastructure.  Download your pull secret and place it in ~/Downloads.

* You need an appropriate quay.io credential.

  Get the required key from
  https://access.redhat.com/solutions/3533201.  Add the auth for
  quay.io to your ~/.docker/config.json and ~/Downloads/pull-secret.

* You need to oc login (or periodically refresh your login).  All
  three steps must be performed.  Not doing this can lead to very
  strange errors; see https://bugzilla.redhat.com/show_bug.cgi?id=1647479.

  + Go to https://api.ci.openshift.org/ and in the upper right corner
    you will see the '?'.  Dropdown to Command Line Tools that will
    give you an 'oc login' command to run from a command line.

  + Run 'oc registry login'.

  + This will generate or update additional secrets in
    ~/.docker/config.json; these need to be copied into
    ~/Downloads/pull-secret.  In particular, the secret for
    registry.svc.ci.openshift.org will change.

* Ensure that you have correct credentials for your cloud provider,
  as appropriate.
EOF
}

function warn_installer_fail() {
    cat <<\EOF
Could not extract installer from image.  Common reasons:

* You've specified an installer version that does not exist (even if
  you've used the query option).  This will fail quickly with a
  clear error message.

EOF
    warn_authentication_failure
}

function fail_installer_extract() {
    local image=$1
    warn_installer_fail
    fatal "Cannot extract openshift-install from image $image"
}

function fail_find_image() {
    local install_version=$1
    warn_installer_fail
    fatal "Can't find image for version $install_version"
}

# This should run in a subshell to not change the current directory
function do_installer_setup() {
    local install_dir=$1
    local image=$2
    local install_version=$3
    cd "$install_dir" || exit 1
    for f in "openshift-"*".tar.gz" ; do
	rm -f "$f"
    done
    "${OC}" adm release extract --tools "${image}" || fail_installer_extract "$image"
    for f in "openshift-"*".tar.gz" ; do
	echo "Extracting $f"
	tar xf "$f" || fail_installer_extract "$image"
    done
    [[ -f openshift-install ]] || fail_installer_extract "$image"
    chmod +x openshift-install
    echo "${install_version}" > version.txt
}

function installer_setup() {
    local not_latest=1
    local release_data
    local image
    local release_source=${OPENSHIFT_RELEASE_SOURCE:-https://${repo}.svc.ci.openshift.org/api/v1/releasestream}
    local installer_registry=${OPENSHIFT_INSTALL_REGISTRY:-registry.svc.ci.openshift.org/${subdir_map[$repo]:-}/release}
    #release_channel=${release_channel:-${release_base_map[$repo]:-}}
    if (( query )) ; then
	if [[ -z ${release_channel:-} ]] ; then
	    local -a channels=()
	    readarray -t channels <<< "$(openshift-release-info -B "$repo" channels < /dev/null | sort -r)"
	    OPS3=${PS3:-}
	    PS3="Select channel: "
	    select release_channel in "${channels[@]}" ; do break; done
	    PS3=$OPS3
	fi
	local -a versions=()
	readarray -t versions <<< "$(openshift-release-info -B "$repo" ${release_channel:+-c "$release_channel"} releases < /dev/null | sort -r)"
	OPS3=${PS3:-}
	PS3="Select release: "
	select install_version in "${versions[@]}" ; do break; done
	PS3=$OPS3
    elif [[ $install_version = latest ]] ; then
	not_latest=
	release_channel=${release_channel:-${release_base_map[$repo]:-}}
	echo "Retrieving release data from $release_source/$release_channel/latest"
	release_data="$(curl --silent "$release_source/$release_channel/latest")"
	[[ -n $release_data ]] || fatal "Can't extract release data!"
	install_version="$("$JQ" -r '.name' <<< "$release_data")"
	[[ -n $install_version ]] || fatal "Can't extract install version!"
    fi
    echo "Using version $install_version${not_latest:- (latest)}" 1>&2
    local -r pullspec="$installer_registry:$install_version"
    image=$(${OC} adm release info --pullspecs "$pullspec" | awk '{if ($1 == "Pull") {print $3}}')
    [[ -z $image ]] && fail_find_image "$install_version"
    if (( ! force_local_tools )) ; then
	echo "Using installer from image ${image} ($ext_installer)" 1>&2
	(do_installer_setup "$install_dir" "$image" "$install_version") || exit 1
	ext_installer="${install_dir}/openshift-install"
	install="$ext_installer"
	echo -e "installer version:\n$("$ext_installer" version |sed 's/^/    /')\n" 1>&2
    fi
    srcdir=.
    if [[ $do_override = 1 && -n $not_latest ]] ; then
	export OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE=$pullspec
	export _OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE=$pullspec
    fi
}

# Try to catch obvious failures
function validate_environment() {
    [[ -n $masterconffile && ! -r $masterconffile ]] &&
	fatal "Master platform config $masterconffile not readable"
    [[ -n $workerconffile && ! -r $workerconffile ]] &&
	fatal "Worker platform config $workerconffile not readable"
    [[ -n $platformconffile && ! -r $platformconffile ]] &&
	fatal "Platform config $platformconffile not readable"
    (( host_prefix_bits < 8 || host_prefix_bits > 23 )) &&
	fatal "Host prefix size must be between 8 and 23"
    local f
    for f in quay.io registry.redhat.io registry.svc.ci.openshift.org ; do
	local g=${f//./\\.}
	grep -q "$g" "$pull_secret" || warn "No secret for '$f' in pull secret $pull_secret; expect installation to fail"
    done
    platform_dispatch validate
}

function confirm_install() {
    cat <<EOF
About to run installer:

Installer:         $install
Sourcedir:         $srcdir$([[ $srcdir != /* ]] && echo " ($(cd "$srcdir" && pwd))")
Install dir:       $srcdir/$install_dir
Current dir:       $(pwd)
Install version:   $install_version
Override:          ${OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE:-}
Install command:   ${install} $loglevel --dir="$srcdir/$install_dir" create cluster
Configuration:

$OPENSHIFT_INSTALL_CONFIG
EOF
    (( noconfirm )) && return 0
    local proceed
    echo
    while : ; do
	read -p "Proceed? [YnevV!?] " -r proceed
	case "$proceed" in
	    y|Y|yes|YES|Yes|'')
		break
		;;
	    n|N|no|NO|No)
		echo "Not confirmed"
		return 1
		;;
	    '!')
		echo "Spawning shell..."
		"$SHELL" -i
		;;
	    e|E|edit|EDIT|Edit)
		echo "Editing config..."
		${EDITOR:-vi} "$srcdir/$install_dir/install-config.yaml"
		;;
	    V)
		env
		;;
	    v)
		set
		;;
	    '?')
		echo 'y   Proceed with installation'
		echo 'n   Do not proceed with installation'
		echo '!   Spawn shell'
		echo 'V   Print environment'
		echo 'v   Print all variable settings'
		echo 'e   Edit install-config.yaml'
		echo '?   Print this help'
		echo 'Abort installation with any other input'
		;;
	    *)
		;;
	esac
    done
    return 0
}

function start_kubechart_if_requested() {
    [[ -n $kubechart_port ]] && run_kubechart=1
    local run_oschart="$run_kubechart"
    if [[ -n $run_kubechart ]] ; then
	kubechart_port=${kubechart_port:-${default_kubechart_port}}
	oschart_port=$((kubechart_port+1))
    fi
    if [[ -x $kubechart && $run_kubechart -gt 0 ]] ; then
	created_kubechart=1
	run_kubechart&
	export OPENSHIFT_INSTALL_KUBECHART_URL=http://localhost:$kubechart_port/
    fi
    if [[ -x $oschart && $run_oschart -gt 0 ]] ; then
	created_oschart=1
	run_oschart&
	export OPENSHIFT_INSTALL_OSCHART_URL=http://localhost:$oschart_port/
    fi
}

function clean_secret() {
    local min_indent_prefix=
    while IFS= read -r line ; do
	if [[ -n $min_indent_prefix ]] ; then
	    if [[ $line = "${min_indent_prefix}"* ]] ; then
		continue
	    else
		min_indent_prefix=
	    fi
	fi
	if [[ $line =~ (( *)(sshKey: |pullSecret: ))([|]|.*) ]] ; then
	    [[ ${BASH_REMATCH[4]} = '|' ]] && min_indent_prefix="${BASH_REMATCH[2]} "
	    echo "${BASH_REMATCH[1]}..."
	else
	    echo "$line"
	fi
    done
    return 0
}

function oc_login() {
    local retry_limit=20
    local try=0
    while (( try++ < retry_limit )) ; do
	echo -n "Login (try $try/$retry_limit)..."
	if ${OC} login -u kubeadmin -p "${OPENSHIFT_INSTALL_PASSWORD:-}" ; then
	    echo "success!"
	    return 0
	fi
	echo "failed."
	(( try < retry_limit )) && sleep 30
    done
    echo "Login failed."
    return 1
}

function waitfor_console() {
    local retry_limit=20
    local try=0
    while (( try++ <= retry_limit )) ; do
	echo -n "Get console route (try $try/$retry_limit)..."
	if ${OC} get route -n openshift-console -o name |grep -q '/console$' ; then
	    echo "success!"
	    return 0
	fi
	echo "failed."
	(( try < retry_limit )) && sleep 30
    done
    echo "Unable to get console route."
    return 1
}

function report_install_failure() {
    local diagnostic_id
    for diagnostic_id in "${!global_diagnostics[@]}" ; do
	"${global_diagnostics[$diagnostic_id]}" "$diagnostic_id"
    done
    warn_authentication_failure
}

function run_postinstall() {
    if [[ -f "${srcdir}/${install_dir}/auth/kubeadmin-password" ]] ; then
	# shellcheck disable=SC2155
	export OPENSHIFT_INSTALL_PASSWORD=$(< "${srcdir}/${install_dir}/auth/kubeadmin-password")
	if (( ! do_login )) ; then
	    echo "oc login skipped"
	elif oc_login ; then
	    login_succeeded=1
	    console_route=
	else
	    echo "oc login failed!"
	fi
    fi

    platform_dispatch postinstall

    if (( wait_for_complete && login_succeeded )) ; then
	echo -n "Waiting for console to come on line..."
	if "${___topdir:-}waitfor-pod" -r 10 console && waitfor_console ; then
	    console_route="$(${OC} get route -n openshift-console -o "custom-columns=HOST:.status.ingress[0].host" --no-headers=true |grep ^console)"
	    if [[ -n $console_route && $console_route != '<none>' ]] ; then
		export OPENSHIFT_INSTALL_CONSOLE_ROUTE="https://$console_route"
		echo "Console route: $OPENSHIFT_INSTALL_CONSOLE_ROUTE"
		(xdg-open "$OPENSHIFT_INSTALL_CONSOLE_ROUTE" </dev/null >/dev/null 2>&1 &)
	    fi
	fi
	echo "login: kubeadmin / $OPENSHIFT_INSTALL_PASSWORD"
    fi
    # shellcheck disable=SC2155
    export OPENSHIFT_INSTALL_NODE_IPS=$("${___topdir:-}"get-nodes)
    # shellcheck disable=SC2155
    export OPENSHIFT_INSTALL_WORKER_NODES=$(oc get nodes -l node-role.kubernetes.io/worker --no-headers=true -o name|sed -e 's,node/,,')
    # shellcheck disable=SC2155
    export OPENSHIFT_INSTALL_MASTER_NODES=$(oc get nodes -l node-role.kubernetes.io/master --no-headers=true -o name|sed -e 's,node/,,')
}

function run_install() {
    validate_environment
    if [[ -z $cleanup_only_dir ]] ; then
	[[ -n $install_version ]] && srcdir=.
	mkdir -p "$srcdir/$install_dir"
	[[ -n $install_version ]] && installer_setup
	if [[ -n $config_file ]] ; then
	    [[ ! -r $config_file ]] && fatal "Cannot read config file $config_file"
	    cp "$config_file" "$srcdir/$install_dir/install-config.yaml"
	else
	    template > "$srcdir/$install_dir/install-config.yaml"
	fi
    fi
    # shellcheck disable=SC2155
    export KUBECONFIG="$(cd $srcdir && echo "$(pwd)/$install_dir/auth/kubeconfig")"

    # We will need the installer even in cleanup-only mode,
    # in order to clean up the cluster.
    local -i rebuild_installer=0
    if [[ -z $ext_installer ]] ; then
	cd $srcdir || fatal "Can't cd to $srcdir"
	local -r cur_rev=$(git rev-parse @)
	[[ ! -x $install || $rebuild -gt 0 || $(${install} version) =~ $cur_rev ]] && rebuild_installer=1
    else
	srcdir=.
    fi

    # shellcheck disable=SC2155
    local start=$(tsec)
    trap cleanup EXIT SIGHUP SIGINT SIGQUIT SIGTERM

    install_stage=1
    OPENSHIFT_INSTALL_CONFIG="$(clean_secret < "$srcdir/$install_dir/install-config.yaml")"
    export OPENSHIFT_INSTALL_CONFIG
    confirm_install || exit 1

    # Not platform-independent
    if (( rebuild_installer )) ; then
	echo "Rebuilding installer"
	TAGS=libvirt hack/build.sh || fatal "Can't rebuild installer"
    fi

    install_stage=2
    # Start kubechart/oschart (if needed) prior to running the installer
    start_kubechart_if_requested

    echo
    # shellcheck disable=SC2086
    "${install}" $loglevel "--dir=$srcdir/$install_dir" create cluster </dev/null 2>&1 | timestamp

    local install_status=${PIPESTATUS[0]}
    # shellcheck disable=SC2155
    local -i end1=$(tsec)
    local -i end2=0

    if (( install_status )) ; then
	report_install_failure
	clean_shutdown=0
    fi
    if (( force_postinstall || !install_status )) ; then
	run_postinstall
	end2=$(tsec)
    fi
    printerval "Installation" $((end1 - start))
    (( end2 )) && printerval "Total setup to console online" $((end2 - start))
    export OPENSHIFT_INSTALL_INTERLOCK=1
    export OPENSHIFT_INSTALL_VERSION=$install_version
    for f in "${!OPENSHIFT@}" "${!_OPENSHIFT@}" KUBECONFIG ; do eval "echo export $f=\${$f@Q}"; done > "${srcdir}/${install_dir}/environment"
    # Run a shell even if setup failed, so it's possible to poke around
    (run_shell)
    case $? in
	77) do_cleanup=0 ;;
	88) do_cleanup=1 ;;
	*)               ;;
    esac
    clean_shutdown=1
}

function read_profile() {
    local profile="$1"
    if [[ ! -r $profile ]] ; then
	fatal "Can't read profile $profile"
    fi
    local value
    if [[ $profile = *.json ]] ; then
	while read -r key <<<"$(jq -r 'keys[]' "$profile")" ; do
	    value="$(jq -r ".\"$key\"" "$profile")" || fatal "Cannot process $key"
	    eval "key=\"$value\"" || fatal "Cannot process $key=$value"
	done
    else
	# shellcheck source=/dev/null
	. "$profile" || fatal "Cannot process profile $profile"
    fi
}

function process_option() {
    local option="$1"
    eval "$1" || fatal "Cannot process option $option"
}

function process_options() {
    while getopts ":BbCcd:HhLln:Oop:qUuV:vX:xYy" opt ; do
	case "$opt" in
	    B) run_kubechart=0		    ;;
	    b) run_kubechart=1		    ;;
	    C) clean_install_cache=0	    ;;
	    c) clean_install_cache=1	    ;;
	    d) install_dir="$OPTARG"        ;;
	    L) do_cleanup=1		    ;;
	    l) do_cleanup=0		    ;;
	    n) release_channel="$OPTARG"    ;;
	    O) overwrite=1                  ;;
	    o) overwrite=0                  ;;
	    p) read_profile "$OPTARG"       ;;
	    q) loglevel=		    ;;
	    U) query=0                      ;;
	    u) query=1                      ;;
	    V) install_version="$OPTARG"    ;;
	    v) loglevel='--log-level=debug' ;;
	    X) process_option "$OPTARG"     ;;
	    x) cleanup_only_dir="$OPTARG"   ;;
	    Y) noconfirm=0		    ;;
	    y) noconfirm=1		    ;;
	    H) help_extended		    ;;
	    h) help			    ;;
	    *) help "$OPTARG"               ;;
	esac
    done

    shift $((OPTIND - 1))

    if [[ -n ${1:-} ]] ; then
	install_type="$1"
	shift
    fi

    [[ -z "$*" ]] || echo "Warning: extraneous arguments $# after $install_type will be ignored!" 1>&2
}

process_options "$@"
clear_env
if [[ -z ${install_type:-} ]] ; then
    for platform in "${global_platforms[@]}" ; do
	install_type="$(platform_dispatch -p "$platform" default_install_type)"
	[[ -z $install_type ]] || break
    done
fi

OPENSHIFT_INSTALL_PLATFORM="$(find_first_platform is_install_type "$install_type")"

[[ -n $OPENSHIFT_INSTALL_PLATFORM ]] || help

export OPENSHIFT_INSTALL_PLATFORM
platform_dispatch setup "$install_type"

OPENSHIFT_INSTALL_BASE_DOMAIN=$(platform_dispatch base_domain)
export OPENSHIFT_INSTALL_BASE_DOMAIN

[[ -n $ext_installer ]] && install="$ext_installer"
[[ $install_version = latest_default ]] && install_version=latest
export OPENSHIFT_INSTALL_CLUSTER_NAME=${install_dir:-${LOGNAME:-NOUSER}-${OPENSHIFT_INSTALL_PLATFORM}}

install_dir="${install_dir:-$OPENSHIFT_INSTALL_CLUSTER_NAME}"

if [[ -n $cleanup_only_dir ]] ; then
    if [[ ! -d $install_dir ]] ; then
	echo "No install directory $install_dir to clean up"
	exit 0
    fi
elif [[ -d $install_dir && $install_dir != . && $install_dir != .. &&
	    -n $(ls "$install_dir") && $overwrite -eq 0 ]] ; then
    fatal "Install directory $install_dir already present; will not overwrite without -O"
fi

run_install
