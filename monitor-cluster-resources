#!/usr/bin/python3 -u

# Copyright 2023 Robert Krawitz/Red Hat
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re
from datetime import datetime
import time
import sys
import subprocess
import selectors
import argparse
import fnmatch


node_cpu = {}
node_memory = {}
node_cpu_capacity = {}
node_memory_capacity = {}
node_pod_capacity = {}
pod_status = {}
pod_memory = {}
pod_cpu = {}
node_pods = {}
pod_nodes = {}
all_nodes = []
starting_time = None
resources_to_list = ['cpu', 'memory', 'pods']
interval = 5
first_time = True
last_row = None
last_row_base = None
last_changed = 0
tab = '\t'
n_timestamps = 0
nodes_schedulable = {}


parser = argparse.ArgumentParser(description='Monitor cluster resources')
parser.add_argument('-N', '--node-pattern', help='Pattern(s) of nodes to list',
                    metavar='pattern', action='append')
parser.add_argument('-P', '--pod-pattern', help='Pattern(s) of pods to list',
                    metavar='pattern', action='append')
parser.add_argument('-R', '--resource',
                    help='Resource(s) to list (memory, cpu, pods).  Repeat for multiple.',
                    metavar='resource', action='append')
parser.add_argument('-i', '--interval', help=f'Interval between scans (default {interval})',
                    metavar='time interval', type=float)
parser.add_argument('-q', '--quiet', help='Do not print rows for individual pods',
                    action='store_true')
parser.add_argument('-Q', '--veryquiet', help='Do not print individual pods that have changed',
                    action='store_true')
parser.add_argument('-c', '--changed-rows-only', help='Only print changed rows', action='store_true')
parser.add_argument('-t', '--relative-timestamps', help='Print relative timestamps', action='store_true')
parser.add_argument('-T', '--absolute-timestamps', help='Print absolute timestamps', action='store_true')
args = parser.parse_args()

if args.relative_timestamps:
    n_timestamps += 1
if args.absolute_timestamps is None or args.absolute_timestamps is True:
    n_timestamps += 1

if args.resource:
    resources_to_list = [resource for resource in resources_to_list if resource in args.resource]
if args.interval:
    interval = args.interval


def _ts(delimiter: str = ' '):
    global starting_time
    answers = []
    now_time = time.time()
    if args.absolute_timestamps is None or args.absolute_timestamps is True:
        answers.append(datetime.utcfromtimestamp(now_time).strftime('%Y-%m-%dT%T.%f'))
    if args.relative_timestamps:
        if starting_time is None:
            starting_time = now_time
        delta = now_time - starting_time
        answers.append(f'{delta:.3f}')
    return delimiter.join(answers)


def get_timestamp(string, delimiter: str = ' '):
    """
    Return a string with a timestamp prepended to the first line
    and any other lines indented
    :param string: String to be timestamped
    :return: Timestamped string
    """
    string = re.sub(r'\n(.*\S.*)', r'\n            \1', string)
    return delimiter.join([_ts(delimiter), string])


def timestamp(string, delimiter: str = ' '):
    """
    Timestamp a string and print it to stderr
    :param string: String to be printed to stderr with timestamp attached
    """
    print(get_timestamp(str(string), delimiter=delimiter))


def process_memory(token):
    if not token or token == '':
        return 0
    tokens = token.split()
    quantity = 0
    for token in tokens:
        m = re.match(r'([0-9]+)([kmg])?', token.lower())
        if m:
            mem = int(m.group(1))
            if m.group(2) == 'k':
                quantity += mem * 1024
            elif m.group(2) == 'm':
                quantity += mem * 1024 * 1024
            elif m.group(2) == 'g':
                quantity += mem * 1024 * 1024 * 1024
            else:
                quantity += mem
    return quantity


def process_cpu(token):
    if not token or token == '':
        return 0
    tokens = token.split()
    quantity = 0
    for token in tokens:
        m = re.match(r'([0-9]+)(m)?', token)
        cpu = int(m.group(1))
        if m.group(2) == 'm':
            quantity += cpu * .001
        else:
            quantity += cpu
    return quantity


def pformat(num: float, precision: int = 3):
    """
    Return a rounded representation of a number.
    :param num:
    :param precision:
    """
    num = num * 100
    precision = precision - 2
    try:
        if precision >= 1:
            return f'{num:.{precision}f}'
        else:
            return str(round(num))
    except Exception:
        return str(num)


def is_match(elt: str, patterns=None):
    if patterns:
        for pattern in patterns:
            if fnmatch.fnmatch(elt, pattern):
                return True
        return False
    else:
        return True


def define_node(line: str):
    node, cpu, memory, pods = line.split('|')
    global all_nodes
    if node not in node_cpu_capacity:
        node_cpu_capacity[node] = process_cpu(cpu)
        node_memory_capacity[node] = process_memory(memory)
        node_pod_capacity[node] = int(pods)
        node_cpu[node] = 0
        node_memory[node] = 0
        node_pods[node] = 0
        all_nodes = sorted([node for node in list(node_cpu_capacity.keys()) if is_match(node, args.node_pattern)])


def fetch_node(node: str):
    run_command(['sh', '-c', f'''
kubectl get node {node} -ojson | jq -r '.metadata.name + "|" + .status.allocatable.cpu + "|" + .status.allocatable.memory + "|" + .status.allocatable.pods'''], define_node)


def mk_header():
    line1_base = f'Node{tab * n_timestamps}{(tab * len(resources_to_list)).join(all_nodes)}{tab}%Capacity'
    line2_base = f'Timestamp{(tab * (n_timestamps - 1)) + ((tab + tab.join(resources_to_list)) * (len(all_nodes) + 1))}'
    if args.veryquiet:
        return f'''{line1_base}{(tab * len(resources_to_list))}Pods changed
{line2_base}{tab}add{tab}remove{tab}change{tab}total'''
    else:
        return f'''{line1_base}{(tab * len(resources_to_list))}Pods changed
{line2_base}{tab}add{tab}remove{tab}change{tab}total'''


def get_node_data():
    answer = []
    totals = {'cpu': 0, 'memory': 0, 'pods': 0}
    for node in all_nodes:
        if 'cpu' in resources_to_list:
            fraction = node_cpu[node] / node_cpu_capacity[node]
            answer.append(str(pformat(fraction)))
            if node in nodes_schedulable:
                totals['cpu'] += fraction
        if 'memory' in resources_to_list:
            fraction = node_memory[node] / node_memory_capacity[node]
            answer.append(str(pformat(node_memory[node] / node_memory_capacity[node])))
            if node in nodes_schedulable:
                totals['memory'] += fraction
        if 'pods' in resources_to_list:
            fraction = node_pods[node] / node_pod_capacity[node]
            answer.append(str(pformat(node_pods[node] / node_pod_capacity[node])))
            if node in nodes_schedulable:
                totals['memory'] += fraction
    for resource in ['cpu', 'memory', 'pods']:
        if resource in resources_to_list:
            answer.append(str(pformat(totals[resource] / len(nodes_schedulable) if len(nodes_schedulable) > 0 else 0)))
    return tab.join(answer)


def process_lines(lines: list):
    def node_status(lines: list):
        global nodes_schedulable
        nodes_schedulable = {}
        for line in lines:
            node, unschedulable = line.split('|')
            if node in all_nodes and not unschedulable.lower().endswith('true'):
                nodes_schedulable[node] = True

    global first_time, last_row, last_row_base
    new_pod_cpu = {}
    new_pod_memory = {}
    new_pod_nodes = {}
    pods_changed = []
    npods_added = 0
    npods_removed = 0
    npods_changed = 0
    npods_total = 0
    node_status(run_command(['kubectl', 'get', 'node', '-ojsonpath={range .items[*]}{.metadata.name}|u={.spec.unschedulable}{"\\n"}{end}'], process_stdout=True))
    for line in lines:
        pod, status, node, cpu, memory = line.split('|')
        if status != 'Running':
            continue
        new_pod_cpu[pod] = process_cpu(cpu)
        new_pod_memory[pod] = process_memory(memory)
        new_pod_nodes[pod] = node
    for pod in [spod for spod in pod_nodes if spod not in {pod: None for pod in new_pod_nodes}]:
        node = pod_nodes[pod]
        node_memory[node] -= pod_memory[pod]
        del pod_memory[pod]
        node_cpu[node] -= pod_cpu[pod]
        del pod_cpu[pod]
        node_pods[node] -= 1
        del pod_nodes[pod]
        if is_match(pod, args.pod_pattern):
            pods_changed.append(f'-{node}.{pod}')
            npods_removed += 1
            if not args.quiet and not args.veryquiet:
                timestamp(f'{get_node_data()}{tab}-{node}.{pod}')

    for pod, node in new_pod_nodes.items():
        cpu = new_pod_cpu[pod]
        memory = new_pod_memory[pod]
        prefix = '+'
        pod_node = None
        if is_match(pod, args.pod_pattern):
            npods_total += 1
        if pod in pod_nodes:
            if node == pod_nodes[pod] and cpu == pod_cpu[pod] and memory == pod_memory[pod]:
                continue
            else:
                pod_node = pod_nodes[pod]
                node_memory[pod_node] -= pod_memory[pod]
                node_cpu[pod_node] -= pod_cpu[pod]
                node_pods[pod_node] -= 1
                prefix = '!'
        pod_memory[pod] = memory
        pod_cpu[pod] = cpu
        pod_nodes[pod] = node
        node_memory[node] += memory
        node_cpu[node] += cpu
        node_pods[node] += 1
        if is_match(pod, args.pod_pattern):
            if prefix == '+':
                npods_added += 1
            else:
                npods_changed += 1
            pods_changed.append(f'{prefix}{node}.{pod}')
            if not args.quiet and not args.veryquiet and (not pod_node or pod_node in all_nodes) and node in all_nodes:
                timestamp(f'{get_node_data()}{tab}{prefix}{node}.{pod}')
    if args.quiet or args.veryquiet:
        if args.veryquiet:
            row_base = f'{get_node_data()}{tab}{npods_added}{tab}{npods_removed}{tab}{npods_changed}{tab}{npods_total}'
        elif args.quiet:
            row_base = f'{get_node_data()}{tab}{npods_added}{tab}{npods_removed}{tab}{npods_changed}{tab}{npods_total}{tab}{" ".join(sorted(pods_changed))}'
        row = get_timestamp(row_base, delimiter=tab)
        if first_time or row_base != last_row_base or not args.changed_rows_only:
            if last_row:
                print(last_row)
                last_row = None
            print(row)
            first_time = False
        else:
            last_row = row
        last_row_base = row_base


def run_command(cmd, process_stdout=None, process_stderr=None):
    """ Run specified command, capturing stdout and stderr as array of timestamped lines.
        Optionally fail if return status is non-zero.  Also optionally report
        stdout and/or stderr to the appropriate file descriptors
    """
    with subprocess.Popen(cmd, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as command:
        sel = selectors.DefaultSelector()
        sel.register(command.stdout, selectors.EVENT_READ)
        sel.register(command.stderr, selectors.EVENT_READ)
        foundSomething = True
        stdout_lines = []
        while foundSomething:
            # Keep reading until we reach EOF on both channels.
            # command.poll() is not a good criterion because the process
            # might complete before everything has been read.
            foundSomething = False
            for key, _ in sel.select():
                data = key.fileobj.readline()
                if len(data) > 0:
                    foundSomething = True
                    data = data.decode().rstrip()
                    if key.fileobj is command.stdout:
                        if process_stdout is True:
                            stdout_lines.append(data)
                        elif process_stdout:
                            process_stdout(data)
                        else:
                            timestamp(data)
                    elif key.fileobj is command.stderr:
                        if process_stderr:
                            process_stderr(data)
                        else:
                            timestamp(data)
        if process_stdout is True:
            return stdout_lines


try:
    run_command(['sh', '-c', '''
    kubectl get node -ojson | jq -r 'foreach .items[]? as $item ([[],[]];0; ($item.metadata.name + "|" + $item.status.allocatable.cpu + "|" + $item.status.allocatable.memory + "|" + $item.status.allocatable.pods))'
    '''],
                define_node)

    print(mk_header())
    exit_next = False
    while True:
        # Unfortunately, watching doesn't work here because we don't normally
        # receive any notification that the pod has gone away.
        curtime = time.time()
        process_lines(run_command(['kubectl', 'get', 'pod', '-A', '-o',
                                   ('jsonpath='
                                    '{range .items[*]}'
                                    '{.metadata.name}.{.metadata.namespace}|'
                                    '{.status.phase}|'
                                    '{.spec.nodeName}|'
                                    '{.spec.containers[*].resources.requests.cpu}|'
                                    '{.spec.containers[*].resources.requests.memory}{"\\n"}{end}')],
                                  process_stdout=True))
        if exit_next:
            sys.exit()
        try:
            now = time.time()
            if now - curtime < interval:
                time.sleep(interval - (now - curtime))
        except KeyboardInterrupt:
            first_time = True
            last_row = None
            exit_next = True
except KeyboardInterrupt:
    sys.exit()
