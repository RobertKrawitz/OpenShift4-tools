#!/usr/bin/python3 -u

# Copyright 2023 Robert Krawitz/Red Hat
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re
from datetime import datetime
import time
import sys
import subprocess
import selectors
import argparse
import fnmatch


def _ts():
    return datetime.utcfromtimestamp(time.time()).strftime('%Y-%m-%dT%T.%f')


def _get_timestamp(string):
    """
    Return a string with a timestamp prepended to the first line
    and any other lines indented
    :param string: String to be timestamped
    :return: Timestamped string
    """
    string = re.sub(r'\n(.*\S.*)', r'\n            \1', string)
    return '%s %s' % (_ts(), string)


def timestamp(string):
    """
    Timestamp a string and print it to stderr
    :param string: String to be printed to stderr with timestamp attached
    """
    print(_get_timestamp(str(string)))


node_cpu = {}
node_memory = {}
node_cpu_capacity = {}
node_memory_capacity = {}
node_pod_capacity = {}
pod_status = {}
pod_memory = {}
pod_cpu = {}
node_pods = {}
pod_nodes = {}
all_nodes = []


parser = argparse.ArgumentParser(description='Monitor cluster resources')
parser.add_argument('-N', '--node-pattern', help='Pattern(s) of nodes to list',
                    metavar='pattern', action='append')
parser.add_argument('-q', '--quiet', help='Do not print rows for individual pods',
                    action='store_true')
parser.add_argument('-Q', '--veryquiet', help='Do not print individual pods that have changed',
                    action='store_true')
args = parser.parse_args()


def process_memory(token):
    if not token or token == '':
        return 0
    tokens = token.split()
    quantity = 0
    for token in tokens:
        m = re.match(r'([0-9]+)(Ki|Mi|Gi)?', token)
        if m:
            mem = int(m.group(1))
            if m.group(2) == 'Ki':
                quantity += mem * 1024
            elif m.group(2) == 'Mi':
                quantity += mem * 1024 * 1024
            elif m.group(2) == 'Gi':
                quantity += mem * 1024 * 1024 * 1024
            else:
                quantity += mem
    return quantity


def process_cpu(token):
    if not token or token == '':
        return 0
    tokens = token.split()
    quantity = 0
    for token in tokens:
        m = re.match(r'([0-9]+)(m)?', token)
        cpu = int(m.group(1))
        if m.group(2) == 'm':
            quantity += cpu * .001
        else:
            quantity += cpu
    return quantity


def pformat(num: float, precision: int = 3):
    """
    Return a rounded representation of a number.
    :param num:
    :param precision:
    """
    num = num * 100
    precision = precision - 2
    try:
        if precision >= 1:
            return f'{num:.{precision}f}'
        else:
            return str(round(num))
    except Exception:
        return str(num)


def is_matching_node(node: str):
    if args.node_pattern:
        for arg in args.node_pattern:
            if fnmatch.fnmatch(node, arg):
                return True
        return False
    else:
        return True


def define_node(line: str):
    node, cpu, memory, pods = line.split('|')
    global all_nodes
    if node not in node_cpu_capacity:
        node_cpu_capacity[node] = process_cpu(cpu)
        node_memory_capacity[node] = process_memory(memory)
        node_pod_capacity[node] = int(pods)
        node_cpu[node] = 0
        node_memory[node] = 0
        node_pods[node] = 0
        all_nodes = sorted([node for node in list(node_cpu_capacity.keys()) if is_matching_node(node)])


def fetch_node(node: str):
    run_command(['sh', '-c', f'''
kubectl get node {node} -ojson | jq -r '.metadata.name + "|" + .status.allocatable.cpu + "|" + .status.allocatable.memory + "|" + .status.allocatable.pods'
'''], define_node)


def get_node_data():
    return '\t'.join([f'{node}\t{pformat(node_cpu[node] / node_cpu_capacity[node])}\t{pformat(node_memory[node] / node_memory_capacity[node])}\t{pformat(node_pods[node] / node_pod_capacity[node])}' for node in all_nodes])


def process_lines(lines: list):
    new_pod_cpu = {}
    new_pod_memory = {}
    new_pod_nodes = {}
    pods_changed = []
    for line in lines:
        pod, status, node, cpu, memory = line.split('|')
        if status != 'Running':
            continue
        new_pod_cpu[pod] = process_cpu(cpu)
        new_pod_memory[pod] = process_memory(memory)
        new_pod_nodes[pod] = node
    for pod in [spod for spod in pod_nodes if spod not in {pod: None for pod in new_pod_nodes}]:
        node = pod_nodes[pod]
        node_memory[node] -= pod_memory[pod]
        del pod_memory[pod]
        node_cpu[node] -= pod_cpu[pod]
        del pod_cpu[pod]
        node_pods[node] -= 1
        del pod_nodes[pod]
        pods_changed.append(f'-{pod}')
        if not args.quiet and not args.veryquiet:
            timestamp(f'{get_node_data()}\t-{pod}')

    for pod, node in new_pod_nodes.items():
        cpu = new_pod_cpu[pod]
        memory = new_pod_memory[pod]
        prefix = '+'
        pod_node = None
        if pod in pod_nodes:
            if node == pod_nodes[pod] and cpu == pod_cpu[pod] and memory == pod_memory[pod]:
                continue
            else:
                pod_node = pod_nodes[pod]
                node_memory[pod_node] -= pod_memory[pod]
                node_cpu[pod_node] -= pod_cpu[pod]
                node_pods[pod_node] -= 1
                prefix = '!'
        pod_memory[pod] = memory
        pod_cpu[pod] = cpu
        pod_nodes[pod] = node
        node_memory[node] += memory
        node_cpu[node] += cpu
        node_pods[node] += 1
        pods_changed.append(f'{prefix}{pod}')
        if not args.quiet and not args.veryquiet and (not pod_node or pod_node in all_nodes) and node in all_nodes:
            timestamp(f'{get_node_data()}\t{prefix}{pod}')
    if pods_changed:
        if args.veryquiet:
            timestamp(get_node_data())
        elif args.quiet:
            timestamp(f'{get_node_data()}\t{" ".join(sorted(pods_changed))}')


def run_command(cmd, process_stdout=None, process_stderr=None):
    """ Run specified command, capturing stdout and stderr as array of timestamped lines.
        Optionally fail if return status is non-zero.  Also optionally report
        stdout and/or stderr to the appropriate file descriptors
    """
    with subprocess.Popen(cmd, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as command:
        sel = selectors.DefaultSelector()
        sel.register(command.stdout, selectors.EVENT_READ)
        sel.register(command.stderr, selectors.EVENT_READ)
        foundSomething = True
        stdout_lines = []
        while foundSomething:
            # Keep reading until we reach EOF on both channels.
            # command.poll() is not a good criterion because the process
            # might complete before everything has been read.
            foundSomething = False
            for key, _ in sel.select():
                data = key.fileobj.readline()
                if len(data) > 0:
                    foundSomething = True
                    data = data.decode().rstrip()
                    if key.fileobj is command.stdout:
                        if process_stdout is True:
                            stdout_lines.append(data)
                        elif process_stdout:
                            process_stdout(data)
                        else:
                            timestamp(data)
                    elif key.fileobj is command.stderr:
                        if process_stderr:
                            process_stderr(data)
                        else:
                            timestamp(data)
        if process_stdout is True:
            return stdout_lines


try:
    run_command(['sh', '-c', '''
    kubectl get node -ojson | jq -r 'foreach .items[]? as $item ([[],[]];0; ($item.metadata.name + "|" + $item.status.allocatable.cpu + "|" + $item.status.allocatable.memory + "|" + $item.status.allocatable.pods))'
    '''],
                define_node)

    while True:
        # Unfortunately, watching doesn't work here because we don't normally
        # receive any notification that the pod has gone away.
        process_lines(run_command(['kubectl', 'get', 'pod', '-A', '-o',
                                   'jsonpath={range .items[*]}{.metadata.name}.{.metadata.namespace}|{.status.phase}|{.spec.nodeName}|{.spec.containers[*].resources.requests.cpu}|{.spec.containers[*].resources.requests.memory}{"\\n"}{end}'],
                                  process_stdout=True))
        time.sleep(5)
except KeyboardInterrupt:
    sys.exit()
