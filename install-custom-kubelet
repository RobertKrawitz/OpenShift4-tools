#!/bin/bash

# Find our helpers
function finddir() {
    local path_to_file
    path_to_file=$(readlink -f "$0")
    if [[ -z $path_to_file ]] ; then
	return 1
    elif [[ -d $path_to_file ]] ; then
	echo "$path_to_file/"
    elif [[ -e $path_to_file ]] ; then
	echo "${path_to_file%/*}/"
    else
	return 1
    fi
    return 0
}

cmddir=$(finddir "$0")
[[ -z $cmddir ]] && fatal "Can't find directory for $0"

PATH="${cmddir}:$PATH"

set -eu

declare godir=${GOPATH:-$HOME/go}
declare -r srcdir="$godir/src/github.com/openshift/origin"
declare lkubelet="$srcdir/_output/local/bin/linux/amd64/hyperkube"
declare bastion=bastion-
declare -i rebuild=1
declare -i do_setup_cert=0
declare -i do_uninstall=0
declare -i twidth=1000
declare -i install_infra=0
declare -i install_master=0
declare -i install_worker=1
declare -i copy_kubelet=1
declare -i parallel=1
declare -i pcount=0
declare private_key=

function help() {
    cat <<EOF
Usage: $0 [options] [specific_nodes...]
    Args:
      -B        Don't use ssh bastion host (direct ssh)
      -b	Use a bastion ssh host (default)
      -C	Don't setup node certs for ssh (default)
      -c	Set up node certs for ssh (must be done once)
      -I        Don't install on infra nodes (default)
      -i        Install on infra nodes
      -k file	Use the specified kubelet file
      -K file	Use the specified private key file
      -M        Don't install on master nodes (default)
      -m        Install on master nodes
      -p N      Set up ssh keys N-way parallel
      -R        Don't attempt to rebuild the kubelet
      -r        Rebuild the kubelet (default)
      -U        Install custom kubelet (default)
      -u	Uninstall (restore original kubelet)
      -W        Don't install on worker nodes
      -w        Install on worker nodes (default)
EOF
    exit 1
}

while getopts "BbCchIiK:k:MmNnp:RrUuWw" opt ; do
    case "$opt" in
	B) bastion=                      ;;
	b) bastion=bastion-              ;;
	C) do_setup_cert=0		 ;;
	c) do_setup_cert=1		 ;;
	I) install_infra=0		 ;;
	i) install_infra=1		 ;;
	K) private_key="$OPTARG"	 ;;
	k) lkubelet="$OPTARG"; rebuild=0 ;;
	M) install_master=0		 ;;
	m) install_master=1		 ;;
	N) copy_kubelet=0		 ;;
	n) copy_kubelet=1		 ;;
	p) parallel="$OPTARG"		 ;;
	R) rebuild=0			 ;;
	r) rebuild=1			 ;;
	U) do_uninstall=0		 ;;
	u) do_uninstall=1		 ;;
	W) install_worker=0		 ;;
	w) install_worker=1		 ;;
	*) help				 ;;
    esac
done

shift $((OPTIND - 1))

declare -a all_nodes=()

if [[ -n "$*" ]] ; then
    all_nodes=("$@")
else
    while read -r node status class rest ; do
	if [[ ($install_infra -eq 1 && $class == *infra*) ||
		  ($install_master -eq 1 && $class == *master*) ||
		  ($install_worker -eq 1 && $class == *worker*) ]] ; then
	    all_nodes+=("$node")
	fi
    done <<< "$(oc get nodes --no-headers=true)"
fi

function rcmd() {
    "${bastion}ssh" "$@"
}

function rcp() {
    "${bastion}scp" "$@"
}

function build_upload() {
    cd "$srcdir"
    make WHAT=vendor/k8s.io/kubernetes/cmd/hyperkube
    ls -l _output/local/bin/linux/amd64/hyperkube
    md5sum _output/local/bin/linux/amd64/hyperkube
}

if (( rebuild && !do_uninstall )) ; then
    (build_upload)
fi

declare expected_md5
expected_md5=$(md5sum "$lkubelet" |awk '{print $1}') || {
    echo "Can't checksum $lkubelet"
    exit 1
}

function generate_uninstall_kubelet() {
    cat <<'EOF'
#!/bin/bash
declare -r lbindir="/usr/bin"
cd "$lbindir" || {
    echo "Can't cd $lbindir!"
    exit 1
}

if [[ -f hyperkube.OLD ]] ; then
    echo "Restoring old kubelet"
    sudo mount -o remount,rw /usr || {
	echo "Can't remount /usr rw"
	exit 1
    }
    sudo mv hyperkube.OLD hyperkube || {
	echo "Can't rename hyperkube.OLD to hyperkube"
	cd /
	mount -o remount,ro /usr
	exit 1
    }
    cd /
    sudo mount -o remount,ro /usr
    sudo systemctl restart kubelet.service
else
    echo "No old hyperkube to restore"
fi
EOF
}

function generate_install_kubelet() {
    cat <<'EOF'
#!/bin/bash

declare lkubelet="$1"
declare -r expected_md5="$2"

declare -r lbindir="/usr/bin"

if [[ $lkubelet = *.gz ]] ; then
    if [[ -e ${lkubelet%.gz} ]] ; then
        rm -f "${lkubelet%.gz}"
    fi
    gunzip "$lkubelet"
    lkubelet=${lkubelet%.gz}
fi

cd "$lbindir" || {
    echo "Can't cd $lbindir!"
    exit 1
}
found_md5=$(md5sum "$lkubelet" |awk '{print $1}')
if [[ -f "$lkubelet" && $(stat -c %s "$lkubelet") -ge 1048576 && "$expected_md5" == "$found_md5" ]] ; then
    echo "Good kubelet!"
else
    echo "Bad kubelet"
    echo "Expected md5 $expected_md5, found $found_md5"
    exit 1
fi

sudo mount -o remount,rw /usr || {
    echo "Can't remount /usr rw"
    exit 1
}
sudo cp "$lkubelet" hyperkube.NEW
cmp "$lkubelet" hyperkube.NEW || {
    echo "$lkubelet and hyperkube.NEW failed compare!"
    cd /
    mount -o remount,ro /usr
    exit 1
}
if [[ -f hyperkube && ! -f hyperkube.OLD ]] ; then
    sudo mv hyperkube hyperkube.OLD
fi
sudo mv hyperkube.NEW hyperkube || {
    echo "Can't rename hyperkube.NEW to hyperkube!"
    cd /
    sudo mount -o remount,ro /usr
    exit 1
}
cd /
sudo mount -o remount,ro /usr
sudo sysctl -w kernel.pid_max=262144
sudo systemctl restart kubelet.service
EOF
}

function generate_grappling_hook_install() {
    cat <<'EOF'
#!/bin/bash
set -e
expected_md5="$1"
shift
myname="$1"
shift
cd /tmp
chmod +x hyperkube
echo "$myname: " "$(./install-kubelet /tmp/hyperkube "$expected_md5")"
rm -f /tmp/hyperkube.gz
gzip -c /tmp/hyperkube > /tmp/hyperkube.gz
chmod +x /tmp/hyperkube.gz
for node in "$@" ; do
    echo "$node: " "$(scp -o StrictHostKeyChecking=no -i ~/.ssh/temp_install -p install-kubelet /tmp/hyperkube.gz "$node:/tmp")" "$(ssh -o StrictHostKeyChecking=no -i ~/.ssh/temp_install "$node" /tmp/install-kubelet /tmp/hyperkube.gz "$expected_md5")"
done
rm -f /tmp/hyperkube.gz
ls -l /usr/bin/hyperkube
echo "$myname: " "$(ps aux |grep hyperkube |grep -v grep)"
for node in "$@" ; do
    echo "$node: " "$(ssh -o StrictHostKeyChecking=no -i ~/.ssh/temp_install  "$node" ps aux |grep hyperkube |grep -v grep)"
done
EOF
}

function generate_grappling_hook_uninstall() {
    cat <<'EOF'
#!/bin/bash
set -e
shift
myname="$1"
shift
cd /tmp
./uninstall-kubelet
for node in "$@" ; do
    echo "$node: " "$(scp -o StrictHostKeyChecking=no -i ~/.ssh/temp_install -p uninstall-kubelet "$node:/tmp")" "$(ssh -o StrictHostKeyChecking=no -i ~/.ssh/temp_install "$node" /tmp/uninstall-kubelet)"
done
ls -l /usr/bin/hyperkube
echo "$myname: " "$(ps aux |grep hyperkube |grep -v grep)"
for node in "$@" ; do
    echo "$node: " "$(ssh -o StrictHostKeyChecking=no -i ~/.ssh/temp_install  "$node" ps aux |grep hyperkube |grep -v grep)"
done
EOF
}

function generate_grappling_hook() {
    if (( do_uninstall )) ; then
	generate_grappling_hook_uninstall
    else
	generate_grappling_hook_install
    fi
}

function waitforit() {
    if ((++pcount >= parallel)) ; then
	wait -n
	pcount=$((pcount-1))
    fi
}

function waitforall() {
    wait
    pcount=0
}

function setup_cert() {
    local tmpdir
    local private_key="$1"

    if [[ -z "$private_key" ]] ; then
	tmpdir=$(mktemp -d) || {
	    echo "Can't create temporary cert dir"
	    exit 1
	}
	private_key="$tmpdir/temp_install"
	ssh-keygen -q -f "$private_key" -N '' || {
	    echo "Can't create temporary key"
	    rm -rf "$tmpdir"
	    exit 1
	}
    fi
    for f in "${all_nodes[@]}" ; do
	(rcp "$private_key" "$f:.ssh" && rcmd "$f" "sudo chown core .ssh/authorized_keys; sudo chmod 644 .ssh/authorized_keys; cat >> .ssh/authorized_keys" < "${private_key}.pub")&
	waitforit
    done
    waitforall
    if [[ -n "${tmpdir:-}" && -d "${tmpdir:-}" ]] ; then
	rm -rf "$tmpdir"
    fi
}

if [[ -n $TERM ]] ; then
    twidth=$(tput cols)
fi

if (( do_setup_cert )) ; then
    setup_cert "$private_key"
fi

if (( ! do_uninstall )) ; then
    if (( copy_kubelet )) ; then
	rcp -C "$lkubelet" "${all_nodes[0]}:/tmp"
    fi
    generate_install_kubelet | rcmd "${all_nodes[0]}" "cat > /tmp/install-kubelet; chmod +x /tmp/install-kubelet"
else
    generate_uninstall_kubelet | rcmd "${all_nodes[0]}" "cat > /tmp/uninstall-kubelet; chmod +x /tmp/uninstall-kubelet"
fi
generate_grappling_hook | rcmd "${all_nodes[0]}" "cat > /tmp/kubelet-grappling-hook; chmod +x /tmp/kubelet-grappling-hook; /tmp/kubelet-grappling-hook $expected_md5 ${all_nodes[*]}" |cut "-c1-$twidth"
oc get nodes
