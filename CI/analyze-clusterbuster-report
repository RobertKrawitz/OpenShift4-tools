#!/usr/bin/env perl
# Copyright 2022 Robert Krawitz/Red Hat
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use Cwd ('realpath');

my (%scaling_data);
my (%uperf_data);
my (%fio_data);
my (%files_data);

sub read_summary($) {
    my ($fh) = @_;
    while (<$fh>) {
	chomp;
	my ($jobname, $data) = split(/\./, $_, 2);
	my ($key, $value) = split(/: */, $data, 2);
	next if $value <= 0;
	my ($workload, $runtime_env, $idx, @rest) = split(/-/, $jobname);
	if ($runtime_env ne 'kata' && $runtime_env ne 'nonkata') {
	    warn("Unknown runtime_env $runtime_env ($_)\n");
	    next;
	}
	if ($workload eq 'podscale' || $workload eq 'cpusoaker') {
	    my ($count) = int($rest[0]);
	    if ($key eq 'summary.pod_start_rate') {
		$scaling_data{$count}{$runtime_env}{'start_rate'} = $value;
	    } elsif ($key eq 'summary.first_pod_start') {
		$scaling_data{$count}{$runtime_env}{'first_pod_start'} = $value;
	    } elsif ($key eq 'summary.last_pod_start') {
		$scaling_data{$count}{$runtime_env}{'last_pod_start'} = $value;
	    } elsif ($key eq 'summary.iterations_cpu_sec' ||
		     $key eq 'summary.interations_cpu_sec') {
		$scaling_data{$count}{$runtime_env}{'iterations_cpu_sec'} = $value;
	    } elsif ($key eq 'summary.iterations_sec' ||
		     $key eq 'summary.interations_sec') {
		$scaling_data{$count}{$runtime_env}{'iterations_sec'} = $value;
	    } elsif ($key =~ 'summary.metrics.maximum_memory_working_set') {
		if (! defined $scaling_data{$count}{$runtime_env}{'memory'} ||
		    ($scaling_data{$count}{$runtime_env}{'memory'} < $value)) {
		    $scaling_data{$count}{$runtime_env}{'memory'} = $value;
		}
	    }
	} elsif ($workload eq 'uperf') {
	    if ($jobname =~ /([[:digit:]]+)B-([[:digit:]])i-([[:digit:]])P-(stream|rr)/) {
		my ($msgsize) = $1;
		my ($threads) = $2;
		my ($pods) = $3;
		my ($op) = $4;
		if ($op eq 'stream') {
		    if ($key =~ /summary\.job_detail.*\.bytes_sec/) {
			$uperf_data{$pods}{$msgsize}{$threads}{$runtime_env}{'rate'} = $value;
		    }
		} elsif ($op eq 'rr') {
		    if ($key =~ /summary\.job_detail.*\.ops_sec/) {
			$uperf_data{$pods}{$msgsize}{$threads}{$runtime_env}{'ops_sec'} = $value;
		    } elsif ($key =~ /summary\.job_detail.*\.total.avg_time_op/) {
			$uperf_data{$pods}{$msgsize}{$threads}{$runtime_env}{'avg_time_op'} = $value;
		    } elsif ($key =~ /summary\.job_detail.*\.total.max_time_op/) {
			$uperf_data{$pods}{$msgsize}{$threads}{$runtime_env}{'max_time_op'} = $value;
		    }
		}
		if ($key =~ /summary\.cpu_utilization/) {
		    $uperf_data{$pods}{$msgsize}{$threads}{$runtime_env}{"cpu_util_$op"} = $value;
		}
	    }
	} elsif ($workload eq 'fio') {
	    my ($pods, $engine, $workload, $blocksize, $iodepth, $fdatasync, $direct, $op);
	    if ($jobname =~ /([[:digit:]]*)P/) {
		$pods = $1;
	    } else {
		next;
	    }
	    if ($key =~ /\.job_[[:digit:]]+-([[:alpha:]]+)-([[:digit:]]+)-([[:digit:]]+)-([[:digit:]]+)-([[:digit:]]+)-([[:alpha:]]+)\.operation_([[:alpha:]]+)/) {
		$workload = $1;
		$blocksize = $2;
		$iodepth = $3;
		$fdatasync = $4;
		$direct = $5;
		$engine = $6;
		$op = $7;
	    } else {
		next;
	    }
	    if ($key =~ /io_rate$/) {
		$fio_data{$pods}{$engine}{$iodepth}{$fdatasync}{$direct}{$workload}{$blocksize}{$runtime_env}{$op}{'iops'} = $value;
		$fio_data{$pods}{$engine}{$iodepth}{$fdatasync}{$direct}{$workload}{$blocksize}{$runtime_env}{'total'}{'iops'} += $value;
	    } elsif ($key =~ /io_data_rate$/) {
		$fio_data{$pods}{$engine}{$iodepth}{$fdatasync}{$direct}{$workload}{$blocksize}{$runtime_env}{$op}{'throughput'} = $value;
		$fio_data{$pods}{$engine}{$iodepth}{$fdatasync}{$direct}{$workload}{$blocksize}{$runtime_env}{'total'}{'throughput'} += $value;
	    }
	} elsif ($workload eq 'files') {
	    my ($pods, $dirs, $files, $blocksize, $blocks, $direct);
	    if ($jobname =~ /([[:digit:]]+)P-([[:digit:]]+)D-([[:digit:]]+)F-([[:digit:]]+)B-([[:digit:]]+)S-([[:digit:]]+)T/) {
		$pods = $1;
		$dirs = $2;
		$files = $3;
		$blocksize = $4;
		$blocks = $5;
		$direct = $6;
	    } else {
		next;
	    }
	    if ($key =~ /summary\.(read|create|remove)\.(.*)/) {
		my ($op) = $1;
		my ($subkey) = $2;
		$files_data{$pods}{$dirs}{$files}{$blocksize}{$blocks}{$direct}{$runtime_env}{$op}{$subkey} = $value;
	    }
	} else {
	    warn("Unknown workload $workload ($_)\n");
	}
    }
}

sub print_value_bin($$) {
    my ($value, $suffix) = @_;
    if (! defined $value || $value eq '') {
 	return '';
    } elsif ($value < 1024) {
	return sprintf("%d $suffix", $value);
    } elsif ($value < 1024 * 1024) {
	return sprintf("%d Ki$suffix", $value / 1024);
    } elsif ($value < 1024 * 1024 * 1024) {
	return sprintf("%d Mi$suffix", $value / 1024 / 1024);
    } elsif ($value < 1024 * 1024 * 1024 * 1024) {
	return sprintf("%d Gi$suffix", $value / 1024 / 1024 / 1024);
    } else {
	return sprintf("%d Ti$suffix", $value / 1024 / 1024 / 1024 / 1024);
    }
}

sub print_value($;$) {
    my ($value, $prec) = @_;
    if (! defined $prec) {
	$prec = 6;
    }
    if (! defined $value || $value eq '') {
	return '';
    } else {
	return sprintf("%.${prec}f", ref $value eq 'HASH' ? exp($$value{'logvalue'} / $$value{'count'}) : $value)
    }
}

sub safe_div($$;$) {
    my ($num, $denom, $prec) = @_;
    if (! defined $prec) {
	$prec = 6;
    }
    if (! defined $num || ! defined $denom) {
	return '';
    } else {
	$num = print_value($num, $prec);
	$denom = print_value($denom, $prec);
	if ($denom == 0 || $denom eq '' || $num eq '') {
	    return '';
	} else {
	    return sprintf("%.${prec}f", $num / $denom);
	}
    }
}

sub safe_sub($$;$) {
    my ($v1, $v2, $prec) = @_;
    if (! defined $v1 || ! defined $v2 || $v2 == 0) {
	return '';
    } else {
	$v1 = print_value($v1, $prec);
	$v2 = print_value($v2, $prec);
	return $v1 - $v2;
    }
}

sub process_scaling() {
    my (@scaling_keys) = sort {$a <=> $b} keys %scaling_data;
    return if (!@scaling_keys);
    print "\n";
    print "Scaling: memory\n";
    printf("%s\t%s\t%s\t%s\t%s\n", 'Pods', 'Non-Kata mem', 'Kata mem', 'ratio', 'Kata ovhd');
    foreach my $key (@scaling_keys) {
	next if (! defined $scaling_data{$key}{'nonkata'} && ! defined $scaling_data{'kata'});
	my ($nonkatamem) = $scaling_data{$key}{'nonkata'}{'memory'};
	my ($katamem) = $scaling_data{$key}{'kata'}{'memory'};
	printf("%d\t%s\t%s\t%s\t%s\n",
	       $key,
	       safe_div($nonkatamem, $key, 0),
	       safe_div($katamem, $key, 0),
	       safe_div($katamem, $nonkatamem, 3),
	       safe_div(safe_sub($katamem, $nonkatamem), $key, 0));
    }

    print "\nScaling: pod starts\n";
    printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", 'Pods', 'Non-Kata', 'Kata', 'ratio', 'Non-Kata 1st', 'Non-Kata last', 'Kata 1st', 'Kata last');
    foreach my $key (@scaling_keys) {
	next if (! defined $scaling_data{$key}{'nonkata'} && ! defined $scaling_data{'kata'});
	printf("%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
	       $key,
	       safe_div($key, $scaling_data{$key}{'nonkata'}{'last_pod_start'}, 3),
	       safe_div($key, $scaling_data{$key}{'kata'}{'last_pod_start'}, 3),
	       safe_div($scaling_data{$key}{'kata'}{'last_pod_start'}, $scaling_data{$key}{'nonkata'}{'last_pod_start'}, 3),
	       print_value($scaling_data{$key}{'nonkata'}{'first_pod_start'}, 3),
	       print_value($scaling_data{$key}{'nonkata'}{'last_pod_start'}, 3),
	       print_value($scaling_data{$key}{'kata'}{'first_pod_start'}, 3),
	       print_value($scaling_data{$key}{'kata'}{'last_pod_start'}, 3));
    }

    print "\nScaling: CPU load (work iterations)\n";
    printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\n", 'Pods', 'Non-Kata CPU', 'Kata CPU', 'Ratio', 'Non-Kata clock', 'Kata clock', 'Ratio');
    foreach my $key (@scaling_keys) {
	next if (! defined $scaling_data{$key}{'nonkata'} && ! defined $scaling_data{'kata'});
	printf("%d\t%s\t%s\t%s\t%s\t%s\t%s\n",
	       $key,
	       print_value($scaling_data{$key}{'nonkata'}{'iterations_cpu_sec'}, 0),
	       print_value($scaling_data{$key}{'kata'}{'iterations_cpu_sec'}, 0),
	       safe_div($scaling_data{$key}{'kata'}{'iterations_cpu_sec'}, $scaling_data{$key}{'nonkata'}{'iterations_cpu_sec'}, 3),
	       print_value($scaling_data{$key}{'nonkata'}{'iterations_sec'}, 0),
	       print_value($scaling_data{$key}{'kata'}{'iterations_sec'}, 0),
	       safe_div($scaling_data{$key}{'kata'}{'iterations_sec'}, $scaling_data{$key}{'nonkata'}{'iterations_sec'}), 3);
    }
}

sub process_uperf() {
    my (@uperf_pods) = keys %uperf_data;
    return if (! @uperf_pods);
    print "\n";
    foreach my $pod_count (sort { $a <=> $b } @uperf_pods) {
	printf("\nNetworking: %d pod%s\n", $pod_count, ($pod_count == 1 ? '' : 's'));
	printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
	       'msgsize', 'nthr',
	       'runc thruput', 'runc latency', 'runc thru cpu', 'runc lat cpu',
	       'kata thruput', 'kata latency', 'kata thru cpu', 'kata lat cpu',
	       'rel thruput cpu', 'rel latency cpu');
	foreach my $msg_size (sort { $a <=> $b } keys %{$uperf_data{$pod_count}}) {
	    foreach my $nthr (sort { $a <=> $b } keys %{$uperf_data{$pod_count}{$msg_size}}) {
		my ($stuff) = $uperf_data{$pod_count}{$msg_size}{$nthr};
		printf("%d\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
		       $msg_size, $nthr,
		       print_value($$stuff{'nonkata'}{'rate'}, 0),
		       print_value($$stuff{'nonkata'}{'avg_time_op'}, 6),
		       print_value($$stuff{'nonkata'}{'cpu_util_stream'}, 3),
		       print_value($$stuff{'nonkata'}{'cpu_util_rr'}, 3),
		       print_value($$stuff{'kata'}{'rate'}, 0),
		       print_value($$stuff{'kata'}{'avg_time_op'}, 6),
		       print_value($$stuff{'kata'}{'cpu_util_stream'}, 3),
		       print_value($$stuff{'kata'}{'cpu_util_rr'}, 3),
		       safe_div($$stuff{'kata'}{'rate'}, $$stuff{'nonkata'}{'rate'}, 3),
		       safe_div($$stuff{'kata'}{'avg_time_op'}, $$stuff{'nonkata'}{'avg_time_op'}, 3));
	    }
	}
    }
}

sub process_fio() {
    my (@fio_pods) = keys %fio_data;
    return if (! @fio_pods);
    print "\n";
    foreach my $pod_count (sort { $a <=> $b } @fio_pods) {
	foreach my $engine (sort keys %{$fio_data{$pod_count}}) {
	    my ($f1) = $fio_data{$pod_count}{$engine};
	    foreach my $iodepth (sort { $a <=> $b } keys %{$f1}) {
		my ($f2) = $$f1{$iodepth};
		foreach my $fdatasync (sort { $a <=> $b } keys %{$f2}) {
		    my ($f3) = $$f2{$fdatasync};
		    foreach my $direct (sort { $a <=> $b } keys %{$f3}) {
			my ($stuff) = $$f3{$direct};
			printf("\nI/O: engine %s, iodepth %d, fdatasync %d, direct %d, %d pod%s\n",
			       $engine, $iodepth, $fdatasync, $direct, $pod_count, ($pod_count == 1 ? '' : 's'));
			printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
			       "Runtime", "Workload", "Blocksize", "Read rate", "Read IOPS", "Write rate", "Write IOPS", "Total rate", "Total IOPS");
			foreach my $workload (sort keys %$stuff) {
			    my ($printed_workload) = 0;
			    foreach my $blocksize (sort { $a <=> $b } keys %{$$stuff{$workload}}) {
				my ($printed_blocksize) = 0;
				my ($stuff1) = $$stuff{$workload}{$blocksize};
				foreach my $runtime ('kata', 'nonkata') {
				    printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
					   $runtime,
					   $printed_workload++ ? '' : $workload,
					   $printed_blocksize++ ? '' : $blocksize,
					   print_value($$stuff1{$runtime}{'read'}{'throughput'}, 0),
					   print_value($$stuff1{$runtime}{'read'}{'iops'}, 0),
					   print_value($$stuff1{$runtime}{'write'}{'throughput'}, 0),
					   print_value($$stuff1{$runtime}{'write'}{'iops'}, 0),
					   print_value($$stuff1{$runtime}{'total'}{'throughput'}, 0),
					   print_value($$stuff1{$runtime}{'total'}{'iops'}, 0));
				}
				printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
				       'relative', '', '',
				       safe_div($$stuff1{'kata'}{'read'}{'throughput'},
						$$stuff1{'nonkata'}{'read'}{'throughput'}, 3),
				       safe_div($$stuff1{'kata'}{'read'}{'throughput'},
						$$stuff1{'nonkata'}{'read'}{'throughput'}, 3),
				       safe_div($$stuff1{'kata'}{'write'}{'throughput'},
						$$stuff1{'nonkata'}{'write'}{'throughput'}, 3),
				       safe_div($$stuff1{'kata'}{'write'}{'throughput'},
						$$stuff1{'nonkata'}{'write'}{'throughput'}, 3),
				       safe_div($$stuff1{'kata'}{'total'}{'throughput'},
						$$stuff1{'nonkata'}{'total'}{'throughput'}, 3),
				       safe_div($$stuff1{'kata'}{'total'}{'throughput'},
						$$stuff1{'nonkata'}{'total'}{'throughput'}, 3));
				print("\n");
			    }
			}
		    }
		}
	    }
	}
    }
}

sub print_one_files_job($) {
    my ($data) = @_;
    printf("Runtime\tCreate\t\t\tRead\t\t\t\tRemove\n");
    printf("\tElapsed Time\tCPU Time\tFiles/sec\t");
    printf("Elapsed Time\tCPU Time\tFiles/sec\tBytes/sec\t");
    printf("Elapsed Time\tCPU Time\tFiles/sec\n");
    foreach my $runtime ('kata', 'nonkata') {
	printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
	       $runtime,
	       print_value($$data{$runtime}{'create'}{'elapsed_time'}, 3),
	       print_value($$data{$runtime}{'create'}{'cpu_time'}, 3),
	       print_value($$data{$runtime}{'create'}{'rate'}, 0),
	       print_value($$data{$runtime}{'read'}{'elapsed_time'}, 3),
	       print_value($$data{$runtime}{'read'}{'cpu_time'}, 3),
	       print_value($$data{$runtime}{'read'}{'rate'}, 0),
	       print_value($$data{$runtime}{'read'}{'io_throughput'}, 0),
	       print_value($$data{$runtime}{'remove'}{'elapsed_time'}, 3),
	       print_value($$data{$runtime}{'remove'}{'cpu_time'}, 3),
	       print_value($$data{$runtime}{'remove'}{'rate'}, 0));
    }
    printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
	   'relative',
	   safe_div($$data{'kata'}{'create'}{'elapsed_time'}, $$data{'nonkata'}{'create'}{'elapsed_time'}, 3),
	   safe_div($$data{'kata'}{'create'}{'cpu_time'}, $$data{'nonkata'}{'create'}{'cpu_time'}, 3),
	   safe_div($$data{'nonkata'}{'create'}{'elapsed_time'}, $$data{'kata'}{'create'}{'elapsed_time'}, 3),
	   safe_div($$data{'kata'}{'read'}{'elapsed_time'}, $$data{'nonkata'}{'read'}{'elapsed_time'}, 3),
	   safe_div($$data{'kata'}{'read'}{'cpu_time'}, $$data{'nonkata'}{'read'}{'cpu_time'}, 3),
	   safe_div($$data{'nonkata'}{'read'}{'elapsed_time'}, $$data{'kata'}{'read'}{'elapsed_time'}, 3),
	   safe_div($$data{'kata'}{'read'}{'io_throughput'}, $$data{'nonkata'}{'read'}{'io_throughput'}, 3),
	   safe_div($$data{'kata'}{'remove'}{'elapsed_time'}, $$data{'nonkata'}{'remove'}{'elapsed_time'}, 3),
	   safe_div($$data{'kata'}{'remove'}{'cpu_time'}, $$data{'nonkata'}{'remove'}{'cpu_time'}, 3),
	   safe_div($$data{'nonkata'}{'remove'}{'elapsed_time'}, $$data{'kata'}{'remove'}{'elapsed_time'}, 3));
}

sub process_files() {
    my (@files_pods) = keys %files_data;
    return if (! @files_pods);
    print "\n";
    my (%geomean);
    foreach my $pods (sort { $a <=> $b } @files_pods) {
	my ($f1) = $files_data{$pods};
	foreach my $dirs (sort { $a <=> $b } keys %$f1) {
	    my ($f2) = $$f1{$dirs};
	    foreach my $files (sort { $a <=> $b } keys %$f2) {
		my ($f3) = $$f2{$files};
		foreach my $blocksize (sort { $a <=> $b } keys %$f3) {
		    my ($f4) = $$f3{$blocksize};
		    foreach my $blocks (sort { $a <=> $b } keys %$f4) {
			my ($f5) = $$f4{$blocks};
			foreach my $direct (sort { $a <=> $b } keys %$f5) {
			    my ($f6) = $$f5{$direct};
			    foreach my $runtime ('kata', 'nonkata') {
				foreach my $op ('create', 'read', 'remove') {
				    $$f6{$runtime}{$op}{'rate'} = safe_div($dirs * $files, $$f6{$runtime}{$op}{'elapsed_time'});
				}
			    }
			    printf("\nPods: %d, Dirs: %d, files per dir: %d, total files: %d, block size: %d, file size: %d, total bytes %s, direct: $direct\n",
				   $pods, $dirs, $files, $dirs * $files * $pods, $blocksize, $blocks, print_value_bin($pods * $dirs * $files * $blocks, "B"));
			    print_one_files_job($f6);
			    foreach my $runtime ('kata', 'nonkata') {
				foreach my $op ('create', 'read', 'remove') {
				    foreach my $var ('elapsed_time', 'cpu_time', 'rate', 'io_throughput') {
					if ($$f6{'kata'}{$op}{$var} > 0 && $$f6{'nonkata'}{$op}{$var} > 0) {
					    $geomean{$direct}{$runtime}{$op}{$var}{'logvalue'} += log($$f6{$runtime}{$op}{$var});
					    $geomean{$direct}{$runtime}{$op}{$var}{'count'}++;
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    }
    foreach my $direct (sort keys %geomean) {
	printf("\nGeomean: direct: $direct\n");
	print_one_files_job($geomean{$direct});
    }
}

sub analyze_directory($) {
    my ($dir) = @_;
    my ($analyze_cmd) = realpath($0);
    $analyze_cmd =~ s,[^/]*$,../clusterbuster-report,;
    open(my $summary, '-|', realpath($analyze_cmd), '-o', 'parseable-summary', $dir) || die "Can't run $analyze_cmd: $!\n";
    read_summary($summary);
    close($summary);
}

if (! @ARGV) {
    warn("Reading summary from stdin\n");
    read_summary(\*STDIN);
} else {
    foreach my $dir (@ARGV) {
	if (-d $dir) {
	    if (-f "$dir/clusterbuster-report.json") {
		analyze_directory($dir);
	    } elsif (opendir (my $dh, $dir)) {
		while (readdir($dh)) {
		    my ($fn) = "$dir/$_";
		    if (-d $fn &&
			/^(cpusoaker|fio|uperf|files)-(kata|nonkata)-[[:digit:]]+/ &&
			! /(\.FAIL|\.tmp)$/) {
			analyze_directory($fn);
		    }
		}
		closedir($dh);
	    }
	}
    }
}

process_scaling();
process_uperf();
process_fio();
process_files();
